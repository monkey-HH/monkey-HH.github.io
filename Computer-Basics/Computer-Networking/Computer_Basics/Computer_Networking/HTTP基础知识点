



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://monkeyhh.top/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://monkeyhh.top/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://monkeyhh.top/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="Computer_Networking,HTTP,HTTPS" />


<link rel="canonical" href="https://monkeyhh.top/Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9">



  <title>
HTTP基础知识点 - Computer_Networking - Computer_Basics |
Monkey's Blog = </title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">HTTP基础知识点
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-08-08 09:28:32">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-08-08T09:28:32+08:00">2021-08-08</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>22k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>20 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Monkey's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202111012245441.png">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Computer-Basics/" itemprop="item" rel="index" title="In Computer_Basics"><span itemprop="name">Computer_Basics</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Computer-Basics/Computer-Networking/" itemprop="item" rel="index" title="In Computer_Networking"><span itemprop="name">Computer_Networking</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://monkeyhh.top/Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Monkey-HH">
    <meta itemprop="description" content=", Learn, share, make progress">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="HTTP特点和缺点"><a href="#HTTP特点和缺点" class="headerlink" title="HTTP特点和缺点"></a>HTTP特点和缺点</h1><h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><p>HTTP 的特点概括如下:</p>
<ol>
<li><code>简单可扩展</code>，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li>
<li><code>可靠传输</code>。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li>
<li><code>请求-应答</code>。也就是<code>一发一收</code>、<code>有来有回</code>， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演<strong>请求方</strong>的角色。</li>
<li><code>无状态</code>。这里的状态是指<strong>通信过程的上下文信息</strong>，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</li>
</ol>
<h2 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h2><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的<strong>无状态</strong>。</p>
<p>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p>
<p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p>
<h4 id="安全性不行"><a href="#安全性不行" class="headerlink" title="安全性不行"></a>安全性不行</h4><p>（1） <strong>窃听风险</strong>（eavesdropping）：通信使用明文（不加密），内容可能会被窃听。<code>WIFI陷阱</code>就是利用不加密，窃听报文，获取信息。</p>
<p>（2） <strong>篡改风险</strong>（tampering）：无法证明报文的完整性，所以有可能已遭篡改。</p>
<p>（3） <strong>冒充风险</strong>（pretending）：不验证通信方的身份，因此有可能遭遇伪装。</p>
<h4 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h4><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的<strong>队头阻塞</strong>问题。接下来会有一小节讨论这个问题。</p>
<h1 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h1><p>用于 HTTP 协议交互的信息被称为 <strong>HTTP 报文</strong>。请求端（客户端）的 HTTP 报文叫做<strong>请求报文</strong>，响应端（服务器端）的叫做<strong>响应报文</strong>。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p>
<p>对于 TCP 而言，在传输的时候分为两个部分:<strong>TCP头</strong>和<strong>数据部分</strong>。</p>
<p>而 HTTP 类似，也是<code>header + body</code>的结构，请求报文的body对应<strong>请求体</strong>，响应报文对应<strong>响应体</strong>。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082129385.png" alt="image-20211008212948344"></p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>请求报文的首部如下</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082138915.png" alt="image-20211008213853882"></p>
<p>请求报文的实体如下</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082142245.png" alt="image-20211008214257203"></p>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>响应报文的首部如下</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082139075.png" alt="image-20211008213907044"></p>
<p>响应报文的实例如下</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082142896.png" alt="image-20211008214234844"></p>
<h2 id="怎么理解URI和URL"><a href="#怎么理解URI和URL" class="headerlink" title="怎么理解URI和URL"></a>怎么理解URI和URL</h2><p>URI并不是我们常说的<code>网址</code>, 网址指的是<code>URL</code>, 实际上<code>URI</code>包含了<code>URN</code>和<code>URL</code>两个部分，即<u>URL是URI的子集</u>，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p>
<ul>
<li><p><strong>URI</strong>（Uniform Resource Identifier 的缩写），统一资源标识符，可以唯一标识一个资源；</p>
</li>
<li><p><strong>URL</strong>（Uniform Resource Locator 的缩写），统一资源定位符，不仅可以标识一个资源，还提供找到该资源的路径；</p>
</li>
<li><p><strong>URN</strong>（Uniform Resource Name 的缩写），统一资源名称，用特定命名空间的名字标识资源，使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。</p>
</li>
</ul>
<h3 id="URI结构"><a href="#URI结构" class="headerlink" title="URI结构"></a>URI结构</h3><p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082203504.png" alt="image-20211008220351463"></p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082204633.png" alt="image-20211008220446601"></p>
<ul>
<li><p><strong>scheme</strong> 表示协议名，比如<code>http</code>, <code>https</code>, <code>file</code>等等。后面必须和<code>://</code>连在一起。</p>
</li>
<li><p><strong>user:passwd</strong>@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</p>
</li>
<li><p><strong>host:port</strong>表示主机名和端口。</p>
</li>
<li><p><strong>path</strong>表示请求路径，标记资源所在位置。</p>
</li>
<li><p><strong>query</strong>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用<code>&amp;</code>隔开。</p>
</li>
<li><p><strong>fragment</strong>表示 URI 所定位的资源内的一个<strong>锚点</strong>，浏览器可以根据这个锚点跳转到对应的位置。</p>
</li>
</ul>
<h3 id="URI编码"><a href="#URI编码" class="headerlink" title="URI编码"></a>URI编码</h3><p>URI 只能使用<code>ASCII</code>, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。</p>
<p>因此，URI 引入了<code>编码</code>机制，将所有<strong>非 ASCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个<code>%</code>。</p>
<p>如，空格被转义成了<code>%20</code>，<strong>三元</strong>被转义成了<code>%E4%B8%89%E5%85%83</code>。</p>
<h2 id="常见HTTP首部"><a href="#常见HTTP首部" class="headerlink" title="常见HTTP首部"></a>常见HTTP首部</h2><p><strong>请求头</strong>和<strong>响应头</strong>的部分有通用首部、请求首部、响应首部和实体首部、其他（如cookie等HTTP的RFC里未定义的首部）等分类</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJz">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</span></p>
<h3 id="通用首部字段General-headers"><a href="#通用首部字段General-headers" class="headerlink" title="通用首部字段General headers"></a>通用首部字段<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9HZW5lcmFsX2hlYWRlcg==">General headers</span></h3><p><strong>通用首部</strong>指的是可以应用于请求和响应中，但是不能应用于消息内容自身的 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9IVFRQX2hlYWRlcg==">HTTP 首部</span> 。 取决于应用的上下文环境，通用首部可以是<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9SZXNwb25zZV9oZWFkZXI=">响应头部</span>或者<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9SZXF1ZXN0X2hlYWRlcg==">请求头部</span>。但是不可以是<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9FbnRpdHlfaGVhZGVy">实体头部</span>。</p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">描述</th>
<th align="center">特殊说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control"><code>Cache-Control</code></a></td>
<td align="center">控制强缓存的行为，有多个属性</td>
<td align="center">优先级大于Expires；只有服务器端才能开缓存；客户端只有一种用途：强制刷新资源，不走缓存，即设置 <code>no-cache</code> 或 <code>max-age=0, must-revalidate</code></td>
</tr>
<tr>
<td align="center">Connection</td>
<td align="center">逐跳首部、连接的管理</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Date</td>
<td align="center">创建报文的日期时间</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Pragma</td>
<td align="center">报文指令</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Trailer</td>
<td align="center">报文末端的首部一览</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Transfer-Encoding</td>
<td align="center">指定报文主体的传输编码方式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Upgrade</td>
<td align="center">升级为其他协议</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Via</td>
<td align="center">代理服务器的相关信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Warning</td>
<td align="center">错误通知</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="请求首部字段Request-headers"><a href="#请求首部字段Request-headers" class="headerlink" title="请求首部字段Request headers"></a>请求首部字段<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9SZXF1ZXN0X2hlYWRlcg==">Request headers</span></h3><p>包含更多有关要获取的资源或客户端本身信息的消息头。</p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">描述</th>
<th align="center">特殊说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">用户代理可处理的MIME类型，对标服务端返回的Content-Type</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Accept-Charset</td>
<td align="center">优先的字符集</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">优先的内容编码</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Accept-Language</td>
<td align="center">优先的语言（自然语言）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Authorization</td>
<td align="center">Web认证信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>Cookie</code></td>
<td align="center">Cookie信息，是<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Gb3JiaWRkZW5faGVhZGVyX25hbWU=">Forbidden header name</span></td>
<td align="center">如果浏览器禁用则无法携带</td>
</tr>
<tr>
<td align="center">Expect</td>
<td align="center">期待服务器的特定行为</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">From</td>
<td align="center">用户的电子邮箱地址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Host</td>
<td align="center">请求资源所在服务器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">If-Match</td>
<td align="center">比较实体标记（ETag）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">If-Modified-Since</td>
<td align="center">对应服务端的比较资源的更新时间</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">If-None-Match</td>
<td align="center">比较实体标记（与 If-Match 相反）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">If-Range</td>
<td align="center">资源未更新时发送实体 Byte 的范围请求</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">If-Unmodified-Since</td>
<td align="center">比较资源的更新时间（与If-Modified-Since相反）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Max-Forwards</td>
<td align="center">最大传输逐跳数</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>Origin</code></td>
<td align="center">最初的请求是从哪里发起的(只会精确到端口) ,Origin比Referer更 尊重隐私</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Proxy-Authorization</td>
<td align="center">代理服务器要求客户端的认证信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Range</td>
<td align="center">实体的字节范围请求</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Referer</td>
<td align="center">对请求中 URI 的原始获取方</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">TE</td>
<td align="center">传输编码的优先级</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">User-Agent</td>
<td align="center">用户客户端程序的信息</td>
<td align="center">例如浏览器的版本号</td>
</tr>
</tbody></table>
<h3 id="响应首部字段Response-headers"><a href="#响应首部字段Response-headers" class="headerlink" title="响应首部字段Response headers"></a>响应首部字段<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9SZXNwb25zZV9oZWFkZXI=">Response headers</span></h3><p>包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">描述</th>
<th align="center">特殊说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept-Ranges</td>
<td align="center">是否接受字节范围请求</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>⭐Access-Control-Allow-*</code></td>
<td align="center">代指多个CORS跨域请求头，实现跨域的一种方式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Age</td>
<td align="center">推算资源创建经过时间</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag"><code>ETag</code></a></td>
<td align="center">协商缓存，资源的特定版本的标识符，Etags类似于指纹</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Expires</td>
<td align="center">强缓存，应该在什么时候认为文档已经过期，从而不再缓存它</td>
<td align="center">HTTP1.0使用，后被HTTP1.1的Cache-Control替代</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified"><code>Last-Modified</code></a></td>
<td align="center">协商缓存，资源的最后修改日期时间</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Location</td>
<td align="center">令客户端重定向至指定URI</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Proxy-Authenticate</td>
<td align="center">代理服务器对客户端的认证信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Retry-After</td>
<td align="center">对再次发起请求的时机要求</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Server</td>
<td align="center">HTTP服务器的安装信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie"><code>Set-Cookie</code></a></td>
<td align="center">设置和页面关联的cookie,服务器通过这个头部把cookie传给客户端</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Vary</td>
<td align="center">代理服务器缓存的管理信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">WWW-Authenticate</td>
<td align="center">服务器对客户端的认证信息</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="实体首部字段Entity-headers"><a href="#实体首部字段Entity-headers" class="headerlink" title="实体首部字段Entity headers"></a>实体首部字段<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9FbnRpdHlfaGVhZGVy">Entity headers</span></h3><p>包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。</p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">描述</th>
<th align="center">特殊说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Allow</td>
<td align="center">资源可支持的HTTP方法</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Content-Encoding</td>
<td align="center">实体主体适用的编码方式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Content-Language</td>
<td align="center">实体主体的自然语言</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Content-Length</td>
<td align="center">实体主体的大小（单位：字节）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Content-Location</td>
<td align="center">替代对应资源的URI</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Content-MD5</td>
<td align="center">实体主体的报文摘要</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Content-Range</td>
<td align="center">实体主体的位置范围</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td align="center">请求或响应的实体内容的媒体类型</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="非正式的首部字段"><a href="#非正式的首部字段" class="headerlink" title="非正式的首部字段"></a>非正式的首部字段</h3><p>在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定 义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。 这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。</p>
<h3 id="端到端消息头-与-逐跳消息头"><a href="#端到端消息头-与-逐跳消息头" class="headerlink" title="端到端消息头 与 逐跳消息头"></a><strong>端到端消息头</strong> 与 <strong>逐跳消息头</strong></h3><p>上面的都是根据不同上下文的分类，消息头也可以根据代理对其的处理方式分为：</p>
<p><strong>端到端首部</strong>（End-to-end Header）</p>
<p>这类消息头必须被传输到最终的消息接收者，也即，请求的服务器或响应的客户端。中间的代理服务器必须转发未经修改的端到端消息头，并且必须缓存它们。</p>
<p><strong>逐跳首部</strong>（Hop-by-hop Header）</p>
<p>这类消息头仅对单次传输连接有意义，不能通过代理或缓存进行重新转发。这些消息头包括 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive"><code>Keep-Alive</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authenticate"><code>Proxy-Authenticate</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authorization"><code>Proxy-Authorization</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/TE"><code>TE</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Trailer"><code>Trailer</code></a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding"><code>Transfer-Encoding</code></a> 及 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1VwZ3JhZGU=">Upgrade (en-US)</span>。注意，只能使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 来设置逐跳一般头。</p>
<h1 id="常见HTTP状态码"><a href="#常见HTTP状态码" class="headerlink" title="常见HTTP状态码"></a>常见HTTP状态码</h1><p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082149477.png" alt="image-20211008214919445"></p>
<p>接下来就一一分析这里面具体的状态码。</p>
<h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p><strong>101 Switching Protocols</strong>。在<code>HTTP</code>升级为<code>WebSocket</code>的时候，如果服务器同意变更，就会发送状态码 101。</p>
<h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p><strong>200 OK</strong>是见得最多的成功状态码。通常在响应体中放有数据。</p>
<p><strong>204 No Content</strong>含义与 200 相同，但响应头后没有 body 数据。</p>
<p><strong>206 Partial Content</strong>顾名思义，表示示客户端进行了范围请求，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段<code>Content-Range</code>。</p>
<h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p><strong>301 Moved Permanently</strong>即永久重定向，对应着<strong>302 Found</strong>，即临时重定向。</p>
<p>比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做缓存优化（如书签更新），在第二次访问的时候自动访问重定向的那个地址。</p>
<p>而如果只是暂时不可用，那么直接返回<code>302</code>即可，和<code>301</code>不同的是，<u>浏览器并不会做缓存优化（如书签不更新）。</u></p>
<p><strong>304 Not Modified</strong>: 当<u>协商缓存命中时</u>会返回这个状态码。详见下面HTTP缓存的章节</p>
<h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p><strong>400 Bad Request</strong>: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。</p>
<p><strong>401 Unauthorized</strong>：未通过认证，发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。</p>
<p><strong>403 Forbidden</strong>: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p>
<p><strong>404 Not Found</strong>: 资源未找到，表示没在服务器上找到相应的资源。</p>
<p><strong>405 Method Not Allowed</strong>: 请求方法不被服务器端允许。</p>
<p><strong>406 Not Acceptable</strong>: 资源无法满足客户端的条件。</p>
<p><strong>408 Request Timeout</strong>: 服务器等待了太长时间。</p>
<p><strong>409 Conflict</strong>: 多个请求发生了冲突。</p>
<p><strong>413 Request Entity Too Large</strong>: 请求体的数据过大。</p>
<p><strong>414 Request-URI Too Long</strong>: 请求行里的 URI 太大。</p>
<p><strong>429 Too Many Request</strong>: 客户端发送的请求过多。</p>
<p><strong>431 Request Header Fields Too Large</strong>请求头的字段内容太大。</p>
<h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p><strong>500 Internal Server Error</strong>: 仅仅告诉你服务器出错了，出了啥错咱也不知道，常见的就是服务器内部代码语法错误。</p>
<p><strong>501 Not Implemented</strong>: 表示客户端请求的功能还不支持。</p>
<p><strong>502 Bad Gateway</strong>: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。</p>
<p><strong>503 Service Unavailable</strong>: 表示服务器当前很忙，暂时无法响应服务。</p>
<h1 id="常见HTTP方法"><a href="#常见HTTP方法" class="headerlink" title="常见HTTP方法"></a>常见HTTP方法</h1><p>HTTP/1.0 和 HTTP/1.1 支持的方法如下</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082227474.png" alt="image-20211008222728434"></p>
<p>Safe安全的：不会修改服务器的数据的方法，GET HEAD OPTIONS</p>
<p>Idempotent幂等：同样的请求被执行一次和连续执行多次效果是一样的，服务器的状态也是一样的。所有的safe方法都是幂等的。GET HEAD OPTIONS PUT DELETE</p>
<h2 id="get和post有啥区别"><a href="#get和post有啥区别" class="headerlink" title="get和post有啥区别"></a>get和post有啥区别</h2><ul>
<li><p>从<strong>语义</strong>的角度，GET是获取资源，POST是提交数据（创建资源、更新资源）</p>
</li>
<li><p>从<strong>参数</strong>的角度，GET请求参数有长度限制，POST没有。</p>
</li>
<li><p>从<strong>安全</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</p>
</li>
<li><p>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存，留下历史记录，而 POST 默认不会。</p>
</li>
<li><p>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</p>
</li>
<li><p>从<strong>幂等性</strong>的角度，<code>GET</code>是<strong>幂等</strong>的，而<code>POST</code>不是。(<code>幂等</code>表示执行相同的操作，结果也是相同的)</p>
</li>
<li><p>从<strong>TCP</strong>的角度，GET 请求会产生一个TCP数据包，而 POST 会产生两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(<strong>火狐</strong>浏览器除外，它的 POST 请求只发一个 TCP 包)</p>
</li>
</ul>
<h2 id="POST和PUT用于创建资源时有什么区别"><a href="#POST和PUT用于创建资源时有什么区别" class="headerlink" title="POST和PUT用于创建资源时有什么区别?"></a>POST和PUT用于创建资源时有什么区别?</h2><p>POST和PUT在创建资源的区别在于，<strong>所创建的资源的名称(URI)是否由客户端决定</strong>。前者不是，后者是。</p>
<p>例如为我的博文增加一个java的分类，生成的路径就是分类名/categories/java，那么就可以采用PUT方法。</p>
<p>不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。</p>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>一种API设计风格;REST-Representational State Transfer，表述性状态转移。</p>
<p>（1）每一个URI代表一种资源</p>
<p>（2）客户端和服务器之间，传递这种资源的某些表现层</p>
<p>（3）客户端通过HTTP method，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<p>于是就得抛弃以前的什么getUser、updateUser啦，没必要，又冗余又麻烦。</p>
<p>这里推荐一篇<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMDM5NjM5MQ==">文章</span>，帮助我更好地理解了RESTful风格。</p>
<p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<blockquote>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
</blockquote>
<p>还有两个不常用的HTTP动词。</p>
<blockquote>
<ul>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
</blockquote>
<p>下面是一些例子。</p>
<blockquote>
<ul>
<li>GET /zoos：列出所有动物园</li>
<li>POST /zoos：新建一个动物园</li>
<li>GET /zoos/ID：获取某个指定动物园的信息</li>
<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>
<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>
<li>DELETE /zoos/ID：删除某个动物园</li>
<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>
<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>
</ul>
</blockquote>
<h1 id="说说如何理解HTTP缓存及缓存代理"><a href="#说说如何理解HTTP缓存及缓存代理" class="headerlink" title="说说如何理解HTTP缓存及缓存代理"></a>说说如何理解HTTP缓存及缓存代理</h1><p>缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：</p>
<ul>
<li>强缓存</li>
<li>协商缓存</li>
<li>缓存位置</li>
</ul>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110121538683.png" alt="image-20211012153843514"></p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110121623980.png" alt="image.png"></p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>浏览器中的缓存作用分为两种情况，一种是需要发送<code>HTTP</code>请求，一种是不需要发送。</p>
<p>首先是检查强缓存，这个阶段<code>不需要</code>发送HTTP请求。</p>
<p>如何来检查呢？通过相应的字段来进行，但是说起这个字段就有点门道了。</p>
<p>在<code>HTTP/1.0</code>和<code>HTTP/1.1</code>当中，这个字段是不一样的。在早期，也就是<code>HTTP/1.0</code>时期，使用的是<strong>Expires</strong>，而<code>HTTP/1.1</code>使用的是<strong>Cache-Control</strong>。让我们首先来看看Expires。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Nov <span class="number">2019</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure>

<p>表示资源在<code>2019年11月22号8点41分</code>过期，过期了就得向服务端发请求。</p>
<p>这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是<strong>服务器的时间和浏览器的时间可能并不一致</strong>，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NhY2hlLUNvbnRyb2w=">Cache-Control</span></h3><p>当<strong>Expires</strong>和<strong>Cache-Control</strong>同时存在的时候，<strong>Cache-Control</strong>会优先考虑。</p>
<p>它和<code>Expires</code>本质的不同在于它并没有采用<code>具体的过期时间点</code>这个方式，而是采用<code>过期时长</code>来控制缓存，对应的字段是<strong>max-age</strong>。比如这个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=<span class="number">3600</span></span><br><span class="line"><span class="comment">//代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。</span></span><br></pre></td></tr></table></figure>

<p>它其实可以组合非常多的指令，用逗号隔开，完成更多场景的缓存判断，详细可以点击标题进MDN查看</p>
<p><code> Cache-Control</code> 通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。缓存指令是<code>单向的</code>，这意味着在请求中设置的指令，不一定被包含在响应中。</p>
<table>
<thead>
<tr>
<th align="center">Cache-Control 指令</th>
<th align="center">用途</th>
<th align="center">说明</th>
<th align="center">请求头？</th>
<th align="center">响应头？</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>public</strong></td>
<td align="center">可缓存性</td>
<td align="center">表明可以被任何对象（客户端、代理服务器等）缓存</td>
<td align="center"></td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center"><strong>private</strong></td>
<td align="center">可缓存性</td>
<td align="center">只有浏览器可缓存，代理服务器等不可以</td>
<td align="center"></td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center"><strong>no-cache</strong></td>
<td align="center">可缓存性</td>
<td align="center">直接进入协商缓存</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center"><strong>no-store</strong></td>
<td align="center">可缓存性</td>
<td align="center">禁止所有缓存（包括强缓存和协商缓存）</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center"><strong>max-age=<seconds></strong></td>
<td align="center">到期</td>
<td align="center"><strong>客户端</strong>缓存的最大周期，超过这个时间缓存被认为过期(单位秒)</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center"><strong>s-maxage=<seconds></strong></td>
<td align="center">到期</td>
<td align="center"><strong>代理服务器</strong>缓存的最大周期，超过这个时间缓存被认为过期(单位秒)</td>
<td align="center"></td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center"><strong>max-stale[=<seconds>]</strong></td>
<td align="center">到期</td>
<td align="center"><strong>客户端</strong>愿意接收一个过期时间不超过n秒的资源。</td>
<td align="center">✔️</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>min-fresh=<seconds></strong></td>
<td align="center">到期</td>
<td align="center"><strong>客户端</strong>希望获取一个离过期至少n秒的资源。</td>
<td align="center">✔️</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>must-revalidate</strong></td>
<td align="center">重新验证和重新加载</td>
<td align="center"><strong>客户端</strong>缓存过期就去源服务器获取</td>
<td align="center"></td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center"><strong>proxy-revalidate</strong></td>
<td align="center">重新验证和重新加载</td>
<td align="center"><strong>代理服务器</strong>的缓存过期后到源服务器获取</td>
<td align="center"></td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center"><strong>no-transform</strong></td>
<td align="center">其他</td>
<td align="center">不得对资源进行转换或转变。<code>Content-Encoding</code>、<code>Content-Range</code>、<code>Content-Type</code>等HTTP头不能由代理修改。</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center"><strong>only-if-cached</strong></td>
<td align="center">其他</td>
<td align="center"><strong>客户端</strong>只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。</td>
<td align="center">✔️</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>当然，还存在一种情况，当资源缓存时间超时了，也就是<code>强缓存</code>失效了，接下来怎么办？没错，这样就进入到第二级屏障——<strong>协商缓存</strong>了。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存失效之后，浏览器在请求头中携带相应的<code>缓存tag</code>来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是<strong>协商缓存</strong>。</p>
<p>具体来说，这样的缓存tag分为两种: <strong>Last-Modified</strong> 和 <strong>ETag</strong>。这两者各有优劣，并不存在谁对谁有<code>绝对的优势</code>，跟上面强缓存的两个 tag 不一样。</p>
<p>根据上面的流程图可以看出，事实上会优先考虑<code>ETag</code></p>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p><code>ETag</code> 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。</p>
<p>首先服务器通过<code>响应头</code>把这个值给浏览器。</p>
<p>浏览器接收到<code>ETag</code>的值，会在下次请求时，将这个值作为<code>If-None-Match</code>这个字段的内容，并放到请求头中，然后发给服务器。</p>
<p>服务器接收到<strong>If-None-Match</strong>后，会跟服务器上该资源的<strong>ETag</strong>进行比对:</p>
<ul>
<li>如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li>
<li>否则返回304，告诉浏览器直接用缓存。</li>
</ul>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段，表示即最后修改时间。</p>
<p>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。</p>
<p>服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，其实会和这个服务器中<code>该资源的最后修改时间</code>对比:</p>
<ul>
<li>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li>
<li>否则返回304，告诉浏览器直接用缓存。</li>
</ul>
<blockquote>
<p>两者对比：</p>
<ol>
<li>在<code>精准度</code>上，<code>ETag</code>优于<code>Last-Modified</code>。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:</li>
</ol>
<ul>
<li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li>
<li>Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li>
</ul>
<ol start="2">
<li>在性能上，<code>Last-Modified</code>优于<code>ETag</code>，也很简单理解，<code>Last-Modified</code>仅仅只是记录一个时间点，而 <code>Etag</code>需要根据文件的具体内容生成哈希值。</li>
</ol>
</blockquote>
<h2 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h2><p>对于源服务器来说，它也是有缓存的，比如<strong>Redis, Memcache</strong>，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。</p>
<p>由此引入了<strong>缓存代理</strong>的机制。让<code>代理服务器</code>接管一部分的服务端HTTP缓存，客户端缓存过期后<strong>就近</strong>到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。</p>
<p>那缓存代理究竟是如何做到的呢？</p>
<p>总的来说，缓存代理的控制分为两部分，一部分是<strong>源服务器</strong>端的控制，一部分是<strong>客户端</strong>的控制。</p>
<h3 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h3><h4 id="private-和-public"><a href="#private-和-public" class="headerlink" title="private 和 public"></a>private 和 public</h4><p>在源服务器的响应头中，会加上<code>Cache-Control</code>这个字段进行缓存控制字段，那么它的值当中可以加入<code>private</code>或者<code>public</code>表示是否允许代理服务器缓存，前者禁止，后者为允许。</p>
<p>比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的<code>Cache-Control</code>设为<code>private</code>，而不是<code>public</code>。</p>
<h4 id="proxy-revalidate"><a href="#proxy-revalidate" class="headerlink" title="proxy-revalidate"></a>proxy-revalidate</h4><p><code>must-revalidate</code>的意思是<strong>客户端</strong>缓存过期就去源服务器获取，而<code>proxy-revalidate</code>则表示<strong>代理服务器</strong>的缓存过期后到源服务器获取。</p>
<h4 id="s-maxage"><a href="#s-maxage" class="headerlink" title="s-maxage"></a>s-maxage</h4><p><code>s</code>是<code>share</code>的意思，限定了缓存在<strong>代理服务器</strong>中可以存放多久，和限制客户端缓存时间的<code>max-age</code>并不冲突。</p>
<p>讲了这几个字段，我们不妨来举个小例子，源服务器在响应头中加入这样一个字段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public, max-age=1000, s-maxage=2000</span><br></pre></td></tr></table></figure>

<p>相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000 s。</p>
<h3 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h3><h4 id="max-stale-和-min-fresh"><a href="#max-stale-和-min-fresh" class="headerlink" title="max-stale 和 min-fresh"></a>max-stale 和 min-fresh</h4><p>在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行<strong>宽容</strong>和<strong>限制</strong>操作。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max-stale: 5</span><br></pre></td></tr></table></figure>

<p>表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在<strong>5秒之内</strong>，还是可以从代理中获取的。</p>
<p>又比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min-fresh: 5</span><br></pre></td></tr></table></figure>

<p>表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在<strong>到期前 5 秒</strong>之前的时间拿，否则拿不到。</p>
<h4 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h4><p>这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回<code>504（Gateway Timeout）</code>。</p>
<p>这点有待考究</p>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>前面我们已经提到，当<code>强缓存</code>命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？</p>
<p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问<code>DOM</code>。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如<code>离线缓存</code>、<code>消息推送</code>和<code>网络代理</code>等功能。其中的<code>离线缓存</code>就是 <strong>Service Worker Cache</strong>。</p>
<p>Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍。</p>
<h3 id="Memory-Cache-和-Disk-Cache"><a href="#Memory-Cache-和-Disk-Cache" class="headerlink" title="Memory Cache 和 Disk Cache"></a>Memory Cache 和 Disk Cache</h3><p><strong>Memory Cache</strong>指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p>
<p><strong>Disk Cache</strong>就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。</p>
<p>好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p>
<ul>
<li>比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存</li>
<li>内存使用率比较高的时候，文件优先进入磁盘</li>
</ul>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>即推送缓存，这是浏览器缓存的最后一道防线。它是 <code>HTTP/2</code> 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。关于 Push Cache，有非常多的内容可以挖掘，不过这已经不是本文的重点，大家可以参考这篇<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbi8/dGFyZ2V0PWh0dHBzOi8vamFrZWFyY2hpYmFsZC5jb20vMjAxNy9oMi1wdXNoLXRvdWdoZXItdGhhbi1pLXRob3VnaHQv">扩展文章</span>。 </p>
<h1 id="说说对Cookie和HTTP的联系"><a href="#说说对Cookie和HTTP的联系" class="headerlink" title="说说对Cookie和HTTP的联系"></a>说说对Cookie和HTTP的联系</h1><h4 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h4><p>Cookie 的有效期可以通过<strong>Expires</strong>和<strong>Max-Age</strong>两个属性来设置。</p>
<ul>
<li><strong>Expires</strong>即<code>过期时间</code></li>
<li><strong>Max-Age</strong>用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。</li>
</ul>
<p>若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>关于作用域也有两个属性: <strong>Domain</strong>和<strong>path</strong>, 给 <strong>Cookie</strong> 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，<code>/</code>表示域名下的任意路径都允许使用 Cookie。</p>
<h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><p>如果带上<code>Secure</code>，说明只能通过 HTTPS 传输 cookie。</p>
<p>如果 cookie 字段带上<code>HttpOnly</code>，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p>
<p>相应的，对于 CSRF 攻击的预防，也有<code>SameSite</code>属性。</p>
<p><code>SameSite</code>可以设置为三个值，<code>Strict</code>、<code>Lax</code>和<code>None</code>。</p>
<p><strong>a.</strong> 在<code>Strict</code>模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>sanyuan.com</code>网站只能在<code>sanyuan.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</p>
<p><strong>b.</strong> 在<code>Lax</code>模式，就宽松一点了，但是只能在 <code>get 方法提交表单</code>况或者<code>a 标签发送 get 请求</code>的情况下可以携带 Cookie，其他情况均不能。</p>
<p><strong>c.</strong> 在<code>None</code>模式下，也就是默认模式，请求会自动携带上 Cookie。</p>
<h3 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h3><ol>
<li>容量缺陷。Cookie 的体积上限只有<code>4KB</code>，只能用来存储少量的信息。</li>
<li>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过<code>Domain</code>和<code>Path</code>指定<strong>作用域</strong>来解决。</li>
<li>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在<code>HttpOnly</code>为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</li>
</ol>
<h1 id="说说HTTP代理"><a href="#说说HTTP代理" class="headerlink" title="说说HTTP代理"></a>说说HTTP代理</h1><p>我们知道在 HTTP 是基于<code>请求-响应</code>模型的协议，一般由客户端发请求，服务器来进行响应。</p>
<p>当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有<strong>双重身份</strong>。</p>
<p>那代理服务器到底是用来做什么的呢？</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li><strong>负载均衡</strong>。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性hash</strong>、<strong>LRU</strong><code>(最近最少使用)</code>等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</li>
<li><strong>保障安全</strong>。利用<strong>心跳</strong>机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</li>
<li><strong>缓存代理</strong>。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。</li>
</ol>
<h3 id="相关头部字段"><a href="#相关头部字段" class="headerlink" title="相关头部字段"></a>相关头部字段</h3><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？</p>
<p>通过<code>Via</code>字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 -&gt; 代理1 -&gt; 代理2 -&gt; 源服务器</span><br></pre></td></tr></table></figure>

<p>在源服务器收到请求后，会在<code>请求头</code>拿到这个字段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: proxy_server1, proxy_server2</span><br></pre></td></tr></table></figure>

<p>而源服务器响应时，最终在客户端会拿到这样的<code>响应头</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: proxy_server2, proxy_server1</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Via</code>中代理的顺序即为在 HTTP 传输中报文传达的顺序。</p>
<h4 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h4><p>字面意思就是<code>为谁转发</code>, 它记录的是<strong>请求方</strong>的<code>IP</code>地址(注意，和<code>Via</code>区分开，<code>X-Forwarded-For</code>记录的是请求方这一个IP)。</p>
<h4 id="X-Real-IP"><a href="#X-Real-IP" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h4><p>是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的IP。</p>
<p>相应的，还有<code>X-Forwarded-Host</code>和<code>X-Forwarded-Proto</code>，分别记录<strong>客户端</strong>(注意哦，不包括代理)的<code>域名</code>和<code>协议名</code>。</p>
<h3 id="X-Forwarded-For产生的问题"><a href="#X-Forwarded-For产生的问题" class="headerlink" title="X-Forwarded-For产生的问题"></a>X-Forwarded-For产生的问题</h3><p>前面可以看到，<code>X-Forwarded-For</code>这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从<code>客户端</code>到<code>代理1</code>，这个字段是客户端的 IP，从<code>代理1</code>到<code>代理2</code>，这个字段就变为了代理1的 IP。</p>
<p>但是这会产生两个问题:</p>
<ol>
<li>意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。</li>
<li>在 HTTPS 通信加密的过程中，原始报文是不允许修改的。</li>
</ol>
<p>由此产生了<code>代理协议</code>，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口</span><br><span class="line">PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这样就可以解决<code>X-Forwarded-For</code>带来的问题了。</p>
<h1 id="HTTP如何处理大文件传输"><a href="#HTTP如何处理大文件传输" class="headerlink" title="HTTP如何处理大文件传输"></a>HTTP如何处理大文件传输</h1><p>对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了<code>范围请求</code>的解决方案，允许客户端仅仅请求一个资源的一部分。</p>
<h3 id="如何支持"><a href="#如何支持" class="headerlink" title="如何支持"></a>如何支持</h3><p>当然，前提是服务器要支持<strong>范围请求</strong>，要支持这个功能，就必须加上这样一个响应头:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: none</span><br></pre></td></tr></table></figure>

<p>用来告知客户端这边是支持范围请求的。</p>
<h3 id="Range-字段拆解"><a href="#Range-字段拆解" class="headerlink" title="Range 字段拆解"></a>Range 字段拆解</h3><p>而对于客户端而言，它需要指定请求哪一部分，通过<code>Range</code>这个请求头字段确定，格式为<code>bytes=x-y</code>。接下来就来讨论一下这个 Range 的书写格式:</p>
<ul>
<li><strong>0-499</strong>表示从开始到第 499 个字节。</li>
<li><strong>500</strong>- 表示从第 500 字节到文件终点。</li>
<li><strong>-100</strong>表示文件的最后100个字节。</li>
</ul>
<p>服务器收到请求之后，首先验证范围<strong>是否合法</strong>，如果越界了那么返回<code>416</code>错误码，否则读取相应片段，返回<code>206</code>状态码。</p>
<p>同时，服务器需要添加<code>Content-Range</code>字段，这个字段的格式根据请求头中<code>Range</code>字段的不同而有所差异。</p>
<p>具体来说，请求<code>单段数据</code>和请求<code>多段数据</code>，响应头是不一样的。</p>
<p>举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 单段数据</span><br><span class="line">Range: bytes=0-9</span><br><span class="line">// 多段数据</span><br><span class="line">Range: bytes=0-9, 30-39</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来我们就分别来讨论着两种情况。</p>
<h3 id="单段数据"><a href="#单段数据" class="headerlink" title="单段数据"></a>单段数据</h3><p>对于<code>单段数据</code>的请求，返回的响应如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Length: 10</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Range: bytes 0-9/100</span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br></pre></td></tr></table></figure>

<p>值得注意的是<code>Content-Range</code>字段，<code>0-9</code>表示请求的返回，<code>100</code>表示资源的总大小，很好理解。</p>
<h3 id="多段数据"><a href="#多段数据" class="headerlink" title="多段数据"></a>多段数据</h3><p>接下来我们看看多段请求的情况。得到的响应会是下面这个形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=00000010101</span><br><span class="line">Content-Length: 189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 0-9/96</span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 20-29/96</span><br><span class="line"></span><br><span class="line">eex jspy e</span><br><span class="line">--00000010101--</span><br></pre></td></tr></table></figure>

<p>这个时候出现了一个非常关键的字段<code>Content-Type: multipart/byteranges;boundary=00000010101</code>，它代表了信息量是这样的:</p>
<ul>
<li>请求一定是多段数据请求</li>
<li>响应体中的分隔符是 00000010101</li>
</ul>
<p>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上<code>--</code>表示结束。</p>
<p>以上就是 http 针对大文件传输所采用的手段。</p>
<h1 id="HTTP如何处理表单数据"><a href="#HTTP如何处理表单数据" class="headerlink" title="HTTP如何处理表单数据"></a>HTTP如何处理表单数据</h1><p>挖坑，以后填</p>
<h1 id="HTTP历史"><a href="#HTTP历史" class="headerlink" title="HTTP历史"></a>HTTP历史</h1><p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110090028726.png" alt="image-20211009002851540"></p>
<h1 id="HTTP-1-0（1996）解决了什么问题？"><a href="#HTTP-1-0（1996）解决了什么问题？" class="headerlink" title="HTTP/1.0（1996）解决了什么问题？"></a>HTTP/1.0（1996）解决了什么问题？</h1><p>HTTP/0.9只有<strong>GET</strong>，且服务器只能回应HTML格式的字符串。</p>
<p>1.0引入了<code>POST</code>命令和<code>HEAD</code>命令，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p>
<p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>
<h2 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h2><p>下面是一个0.9版的HTTP请求的例子。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure>

<p>下面是一个1.0版的HTTP请求的例子。</p>
<blockquote>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，这个格式与0.9版有很大变化。</p>
<p>第一行是请求命令，必须在尾部添加协议版本（<code>HTTP/1.0</code>）。后面就是多行头信息，描述客户端的情况。</p>
<h2 id="回应格式"><a href="#回应格式" class="headerlink" title="回应格式"></a>回应格式</h2><p>下面是一个0.9版的HTTP请求的例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面是一个1.0版的HTTP请求的例子。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>137582</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache 0.84</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p>
<h2 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h2><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。</p>
<p>下面是一些常见的<code>Content-Type</code>字段的值。</p>
<blockquote>
<ul>
<li>text/plain</li>
<li>text/html</li>
<li>text/css</li>
<li>image/jpeg</li>
<li>image/png</li>
<li>image/svg+xml</li>
<li>audio/mp4</li>
<li>video/mp4</li>
<li>application/javascript</li>
<li>application/pdf</li>
<li>application/zip</li>
<li>application/atom+xml</li>
</ul>
</blockquote>
<p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。</p>
<p>除了预定义的类型，厂商也可以自定义类型。</p>
<blockquote>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/vnd.debian.binary-package</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的类型表明，发送的是Debian系统的二进制数据包。</p>
<p><code>MIME type</code>还可以在尾部使用分号，添加参数。</p>
<blockquote>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p>
<p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p>
<blockquote>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
<p><code>MIME type</code>不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a>Content-Encoding 字段</h2><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p>
<blockquote>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>compress</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>deflate</span><br></pre></td></tr></table></figure>
</blockquote>
<p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p>
<blockquote>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="HTTP-1-1（1997）解决了什么问题？"><a href="#HTTP-1-1（1997）解决了什么问题？" class="headerlink" title="HTTP/1.1（1997）解决了什么问题？"></a>HTTP/1.1（1997）解决了什么问题？</h1><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。</p>
<p>另外，客户端请求的头信息新增了<code>Host</code>字段，用来指定服务器的域名。</p>
<blockquote>
<p>⭐简而言之：支持长连接，一个TCP连接可以有多个HTTP请求处理和响应，提高效率，支持管线化。</p>
</blockquote>
<h2 id="持久连接-长连接"><a href="#持久连接-长连接" class="headerlink" title="持久连接/长连接"></a>持久连接/长连接</h2><p><code>http1.0</code>协议采用的是”请求-应答”模式，当使用普通模式，每个请求/应答客户与服务器都要新建一个连接，完成之后立即断开连接(<code>http</code>协议为<code>无连接</code>的协议)，即常说的短连接，虽然有Connection: keep-alive实现长连接，但是是非标准字段，实现的行为可能不一致。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082256178.png" alt="image-20211008225625115"></p>
<p><code>http1.1</code>版本默认为<strong>长连接</strong>，即请求头添加<code>Connection: Keep-Alive</code>，使用Keep-Alive模式(又称持久连接，连接复用)建立一个<code>TCP</code>连接后使客户端到服务端的连接持续有效，可以发送/接受多个<code>http</code>请求/响应，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或者重新建立连接</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082256630.png" alt="image-20211008225637561">客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>
<blockquote>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><p><strong>管线化</strong>： 请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收。</p>
<p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术 出现后，不用等待响应亦可直接发送下一个请求。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082258022.png" alt="image-20211008225832965"></p>
<p>注意的是：HTTP/1.0一样一次只能发一个，答复完该请求才能发下一个请求</p>
<p>而管线化则是一次可以发多个请求，但接受响应还是得按照顺序来，这点非常重要，所以如果前面的请求的相应出了问题，后面的请求还是没法正常响应，所以会导致队头阻塞的问题。</p>
<h2 id="HTTP1-1中持久连接的缺点：队头阻塞"><a href="#HTTP1-1中持久连接的缺点：队头阻塞" class="headerlink" title="HTTP1.1中持久连接的缺点：队头阻塞"></a>HTTP1.1中持久连接的缺点：队头阻塞</h2><blockquote>
<p>需要注意的点一：这里的队头阻塞指的是<code>HTTP队头阻塞</code>，不是<code>TCP队头阻塞</code>。</p>
<p>需要注意的点二：队头阻塞问题是<code>请求-应答</code>的模式导致的，即前一个请求正确发送且其响应正确才能处理下一个任务，<strong>和长连接管线化这些没有关系</strong>。（❓那有没有方法可以不按照请求的顺序来处理响应呢，有的，在HTTP2里通过SPDY协议完成这个操作，后面会讲到）</p>
</blockquote>
<p>HTTP 1.1传输是基于<code>请求-应答</code>的模式进行的，<u>报文必须是一发一收，一个接一个</u>，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理，就是<strong>队头阻塞</strong>。</p>
<p>例如：一个 TCP 连接同时传输 10 个请求，其中第 1、2、3 个请求已被客户端接收，但第 4 个请求丢失，那么后面第 5 - 10 个请求都被阻塞，需要等第 4 个请求处理完毕才能被处理，这样就浪费了带宽资源。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110101728809.png" alt="image-20211010172824744"></p>
<h2 id="⭐队头阻塞的解决方案：多个长连接"><a href="#⭐队头阻塞的解决方案：多个长连接" class="headerlink" title="⭐队头阻塞的解决方案：多个长连接"></a>⭐队头阻塞的解决方案：多个长连接</h2><h3 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h3><p>对于<u>一个域名允许分配多个长连接</u>，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p>
<p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p>
<h3 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h3><p>多分几个二级域名，每个域名都并发连接</p>
<blockquote>
<p>⚠不足：但其实没有根本地从HTTP长连接本身解决这个问题，因为<u><em>每个连接中还是会队头阻塞问题</em></u>。并且有一个弊端：多条 TCP 连接会竞争<strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理。</p>
</blockquote>
<h2 id="说说如何避免长连接资源浪费？"><a href="#说说如何避免长连接资源浪费？" class="headerlink" title="说说如何避免长连接资源浪费？"></a>说说如何避免长连接资源浪费？</h2><blockquote>
<p>长连接一直开着不是很浪费资源吗？如何避免长连接资源浪费？</p>
</blockquote>
<p><strong>客户端请求头声明</strong>：<code>Connection: close</code>，本次通信后就关闭连接</p>
<p><strong>服务端配置</strong>：如Nginx，设置<code>keepalive_timeout</code>设置长连接超时时间，<code>keepalive_requests</code>设置长连接请求次数上限</p>
<p><strong>系统内核参数设置</strong>：</p>
<ul>
<li><code>net.ipv4.tcp_keepalive_time = 60</code>，连接闲置60秒后，服务端尝试向客户端发送侦测包，判断TCP连接状态，如果没有收到ack反馈就在</li>
<li><code>net.ipv4.tcp_keepalive_intvl = 10</code>，就在10秒后再次尝试发送侦测包，直到收到ack反馈，一共会</li>
<li><code>net.ipv4.tcp_keepalive_probes = 5</code>，一共会尝试5次，要是都没有收到就关闭这个TCP连接了</li>
</ul>
<h1 id="HTTP-2（2015）解决了什么问题？"><a href="#HTTP-2（2015）解决了什么问题？" class="headerlink" title="HTTP/2（2015）解决了什么问题？"></a>HTTP/2（2015）解决了什么问题？</h1><blockquote>
<p>简而言之：实现了头部压缩、多路复用、</p>
</blockquote>
<p>在讲HTTP/2.0之前得先讲讲SPDY协议</p>
<h2 id="SPDY协议（2009）"><a href="#SPDY协议（2009）" class="headerlink" title="SPDY协议（2009）"></a>SPDY协议（2009）</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p>
<p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之 间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规 定通信中使用 SSL。</p>
<p>SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、 Cookie 以及 HTTP 报文等。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110082329278.png" alt="image-20211008232948226"></p>
<p>很快啊，SPDY核心人员都参加到HTTP/2.0开发中去了，自HTTP2.0开发完成就不再支持SPDY协议了，并在Chrome 51中删掉了SPDY的支持。HTTP/2.0的新特性基本从这个协议来的。</p>
<h2 id="HTTP头部压缩"><a href="#HTTP头部压缩" class="headerlink" title="HTTP头部压缩"></a>HTTP头部压缩</h2><p>HPACK算法，此处不细究，只讲其起到的作用。</p>
<ul>
<li>头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送</li>
<li>对于多次请求的重复的字段，用<code>哈夫曼编码</code>建立索表，所有字段都会存入这个表，生成一个<strong>索引号</strong>，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li>
</ul>
<h2 id="二进制帧Frame与流Stream"><a href="#二进制帧Frame与流Stream" class="headerlink" title="二进制帧Frame与流Stream"></a>二进制帧Frame与流Stream</h2><p>HTTP/2 把报文全部换成二进制格式，全部传输<code>01</code>串，方便了机器的解析。</p>
<p>把每一个HTTP请求或响应都转为二进制后，进行拆分，分成了多个<code>二进制帧（frame）</code>。帧是HTTP/2的最小单位，每个帧都会有<code>帧头Frame header</code>（至少也会表示出当前所属的数据流）和<code>帧体Frame body</code>。</p>
<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110122004645.png" alt="image-20211012200436542" style="zoom: 67%;" />

<blockquote>
<p>咱来详细看看帧的结构：</p>
<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110122039323.png" alt="image-20211012203925241" style="zoom:50%;" />

<p>先是三个字节的帧长度，这个长度表示的是<code>帧体</code>的长度。</p>
<p>然后是帧类型，大概可以分为<strong>数据帧</strong>和<strong>控制帧</strong>两种。数据帧用来存放 HTTP 报文，控制帧用来管理<code>流</code>的传输。</p>
<p>接下来的一个字节是<strong>帧标志</strong>，里面一共有 8 个标志位，常用的有 <strong>END_HEADERS</strong>表示头数据结束，<strong>END_STREAM</strong>表示单方向数据发送结束。</p>
<p>后 4 个字节是<code>Stream ID</code>, 也就是<code>流标识符</code>，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。</p>
</blockquote>
<p><code>消息message</code>：与逻辑请求或响应信息对应的完整的一系列帧，即<u>由帧组成</u>。</p>
<p><code>数据流Stream</code>：已建立的连接内的双向字节流，可以承载一条或多条信息，即<u>由消息组成</u>。</p>
<p>每个数据流中的二进制帧都有一个的独一无二的<code>Stream ID</code> ，那相同ID的二进制帧就可以看到属于用一个流。</p>
<p>客户端还可以指定数据流的<strong>优先级</strong>。优先级越高，服务器就会越早回应。</p>
<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110122003795.png" alt="image-20211012200316640" style="zoom:67%;" />

<h2 id="⭐队头阻塞解决方案：多路复用"><a href="#⭐队头阻塞解决方案：多路复用" class="headerlink" title="⭐队头阻塞解决方案：多路复用"></a>⭐队头阻塞解决方案：多路复用</h2><blockquote>
<p>前情提要：在HTTP/1.1中，解决队头阻塞的问题就是多开几个长连接，但其实没有根本地从HTTP长连接本身解决这个问题，因为<u><em>每个连接中还是会队头阻塞问题</em></u>。并且有一个弊端：多条 TCP 连接会竞争<strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理。</p>
</blockquote>
<blockquote>
<p>简单来说：将请求转换为流形式，流由帧组成，帧可乱序发送，以此可以“乱序响应”。</p>
</blockquote>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110101947160.jpeg" alt="img"></p>
<p>HTTP/2 用<code>流</code>来在一个 TCP 连接上来进行多个数据帧的通信，这就是<strong>多路复用</strong>的概念。</p>
<p>可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？</p>
<p>首先要声明的是，所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的<strong>请求报文</strong>和<strong>响应报文</strong>。</p>
<p>如下图所示，不同颜色代表不同的请求，相同颜色的色块代表请求被切分的 Frame。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110101951742.png" alt="image-20211010195139687"></p>
<blockquote>
<p>注：这里的多路复用是指HTTP层面的多路复用，解决的是<code>HTTP请求-响应</code>这一粒度的队头阻塞，而没有解决<code>TCP层面</code>的队头阻塞，所以会有一个问题出现，如果有每一个<code>帧</code>丢失，则它后面的<code>帧</code>都不算收到（接收窗口不会往前滑，应用就无法读取，具体过程可以看我TCP的文章），那它以及它后面的所有<code>帧</code>所对应的流都是被阻塞了（即无法重组成<code>流</code>交给应用层），只能等TCP层面上把缺失的<code>帧</code>重传。具体这个层次的改进在HTTP/3中得到了解决，后面章节会提到。</p>
</blockquote>
<h2 id="服务器推送功能"><a href="#服务器推送功能" class="headerlink" title="服务器推送功能"></a>服务器推送功能</h2><p>在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。</p>
<p>看下面一个详细的例子，右边客户端打开网页请求了page.html，这时候服务器端看到HTML文件里引用了script.js和style.css于是把这两个文件也主动推送给你。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110122008471.png" alt="image-20211012200822377"></p>
<h1 id="HTTPS解决了什么问题？"><a href="#HTTPS解决了什么问题？" class="headerlink" title="HTTPS解决了什么问题？"></a>HTTPS解决了什么问题？</h1><blockquote>
<p>简而言之：通过SSL/TLS等加密手段，对HTTP的安全性进行保障，解决HTTP的安全性问题。</p>
</blockquote>
<p>即<code>HTTP+ SSL/TLS =HTTPS</code></p>
<p>传统的HTTP协议明文传输会有以下的问题 </p>
<p>（1） <strong>窃听风险</strong>（eavesdropping）：通信使用明文（不加密），内容可能会被窃听。</p>
<p>（2） <strong>篡改风险</strong>（tampering）：无法证明报文的完整性，所以有可能已遭篡改。</p>
<p>（3） <strong>冒充风险</strong>（pretending）：不验证通信方的身份，因此有可能遭遇伪装。</p>
<p>所以，HTTPS利用SSL/TLS等协议达到以下效果</p>
<p>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。</p>
<p>（2） 具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</p>
<p>（3） 配备<strong>身份证书</strong>，防止身份被冒充。</p>
<h2 id="HTTPS加密方式概述"><a href="#HTTPS加密方式概述" class="headerlink" title="HTTPS加密方式概述"></a>HTTPS加密方式概述</h2><blockquote>
<p>首先了解一下常见的加密机制</p>
<p>①<code>对称密钥加密/共享密钥加密</code>：双方用同一个<code>公开密钥</code>对信息进行加密解密。</p>
<p>特点：简单、效率高</p>
<p>问题：怎么传输这个<code>公开密钥</code>？通信中传该密钥可能导致泄露</p>
<p>②<code>非对称密钥加密/公开密钥加密</code>：A→B发信息，A用B的<code>公开密钥</code>加密，B用<code>私有密钥</code>解密。</p>
<p>特点：复杂、安全性更高</p>
<p>问题：怎么确保A拿到的的<code>公开密钥</code>是可信的，不是被篡改后的密钥？</p>
<p>③<code>混合加密</code>:在通信刚开始的时候使用 <code>非对称加密</code> 算法，解决密钥交换的问题。后续全都使用 <code>对称加密</code> 进行通信。</p>
</blockquote>
<p>HTTPS采用混合加密机制，在交换密钥环节使用<strong>公开密钥加密</strong>方式，之后的建立通信交换报文阶段则使用<strong>共享密钥加密</strong>方式。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110112253491.png" alt="image-20211011225337361"></p>
<p>❓那么问题来了，方案②怎么确保A拿到的<code>公开密钥</code>就是B给的<code>公开密钥</code>呢？有没有一个“公信人”出来，双方都信服，B把<code> 公开密钥</code> 给这个“公信人”保管，“公信人”把<code>公开密钥</code>写成一张有自己<u>亲笔签名的证书</u>（当然证书上还有加密过后的<code>公开密钥</code>），A再向“公信人”要这张证书，亲笔签名是没法伪造的，A在解密证书拿到的<code>公开密钥</code>就保真了。</p>
<p>欸，HTTPS就是这么干的，可以由<code>数字证书认证机构CA(Certificate Authority)</code>充当“公信人”。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110112302549.png" alt="image-20211011230234392"></p>
<blockquote>
<p>将公钥放在<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlnaXRhbF9jZXJ0aWZpY2F0ZQ==">数字证书</span>中。只要证书是可信的，公钥就是可信的。</p>
</blockquote>
<h2 id="说说什么是SSL-TLS"><a href="#说说什么是SSL-TLS" class="headerlink" title="说说什么是SSL/TLS"></a>说说什么是SSL/TLS</h2><p><code>SSL 即安全套接层协议（Secure Sockets Layer）</code>，在 OSI 七层模型中处于会话层(第 5 层)。之前 SSL 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 <code>TLS（传输层安全协议，Transport Layer Security）</code>，并被当做 TLS1.0 的版本，准确地说，<strong>TLS1.0 = SSL3.1</strong>。</p>
<p>现在主流的版本是 TLS/1.2, 之前的 TLS1.0、TLS1.1 都被认为是不安全的，在不久的将来会被完全淘汰。因此我们接下来主要讨论的是 TLS1.2, 当然在 2018 年推出了更加优秀的 TLS1.3，大大优化了 TLS 握手过程，这个我们放在下一节再去说。</p>
<h2 id="说说TLS具体握手过程"><a href="#说说TLS具体握手过程" class="headerlink" title="说说TLS具体握手过程"></a>说说TLS具体握手过程</h2><p>上面我们提到了HTTPS是通过非对称密钥的方式进行报文的加密的，并且提到了用CA来解决服务器端的<code>公开密钥</code>安全传输问题，但其实绕不开的一个问题是，通信双方有密钥，怎么进行加密和解密呢，这个</p>
<p>挖个坑：以后有机会填上，以下是一些博客，可以参考一下</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zYW55dWFuMDcwNC50b3AvYmxvZ3MvYnJvd3Nlci9icm93c2VyLXNlY3VyaXR5LzAwMy5odG1sIyVFNSVBRiVCOSVFNyVBNyVCMCVFNSU4QSVBMCVFNSVBRiU4NiVFNSU5MiU4QyVFOSU5RCU5RSVFNSVBRiVCOSVFNyVBNyVCMCVFNSU4QSVBMCVFNSVBRiU4Ng==">https://sanyuan0704.top/blogs/browser/browser-security/003.html#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MTAwMDM1ODIxNTc1I2hlYWRpbmctNzE=">https://juejin.cn/post/6844904100035821575#heading-71</span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTMvMDYvcnNhX2FsZ29yaXRobV9wYXJ0X29uZS5odG1s">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODk1NjI0MzI3ODk2NDMyNjU0I2hlYWRpbmctMA==">https://juejin.cn/post/6895624327896432654#heading-0</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE0LzAyL3NzbF90bHMuaHRtbA==">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE0LzA5L2lsbHVzdHJhdGlvbi1zc2wuaHRtbA==">https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE0LzA5L3NzbC1sYXRlbmN5Lmh0bWw=">https://www.ruanyifeng.com/blog/2014/09/ssl-latency.html</span></p>
<h1 id="HTTP-3（2018）-解决了什么问题？"><a href="#HTTP-3（2018）-解决了什么问题？" class="headerlink" title="HTTP/3（2018） 解决了什么问题？"></a>HTTP/3（2018） 解决了什么问题？</h1><blockquote>
<p>简而言之：彻底解决队头阻塞问题、使用UDP代替TCP………</p>
</blockquote>
<p>在讲HTTP/3之前，同样离不开谷歌的一个QUIC协议</p>
<h2 id="QUIC（2013）"><a href="#QUIC（2013）" class="headerlink" title="QUIC（2013）"></a>QUIC（2013）</h2><p>无论 SPDY 还是 HTTP/2，都是基于 TCP 的，TCP 与 UDP 相比效率上存在天然的劣势，所以 2013 年 Google 开发了基于 UDP 的名为 QUIC 的传输层协议，QUIC 全称 Quick UDP Internet Connections，希望它能<u>替代 TCP</u>，使得网页传输更加高效。后经**<span class="exturl" data-url="aHR0cHM6Ly9tYWlsYXJjaGl2ZS5pZXRmLm9yZy9hcmNoL21zZy9xdWljL1JMUnM0bkIxbHdGQ1pfN2swaXV6MFpCYTM1cw==">提议</span>**，互联网工程任务组正式将基于 QUIC 协议的 HTTP （HTTP over QUIC）重命名为 HTTP/3。</p>
<p>因此想要了解 HTTP/3，QUIC 是绕不过去的。</p>
<p>QUIC（Quick UDP Internet Connections，快速 UDP 网络连接） 基于 UDP，正是看中了 UDP 的速度与效率。同时 QUIC 也整合了 TCP、TLS 和 HTTP/2 的优点，并加以优化。用一张图可以清晰地表示他们之间的关系。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110101700207.png" alt="image-20211010165948157"></p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110101706416.png" alt="image-20211010170644354"></p>
<h2 id="⭐队头阻塞更进一步的解决方案"><a href="#⭐队头阻塞更进一步的解决方案" class="headerlink" title="⭐队头阻塞更进一步的解决方案"></a>⭐队头阻塞更进一步的解决方案</h2><blockquote>
<p>前情提要：HTTP/2中多路复用的方式，虽然可以解决<code>HTTP层面</code>的队头阻塞问题，但是<code>TCP层面</code>和<code>TLS层面</code>的队头阻塞问题无法解决。</p>
<p>并且还有一个问题：由于 HTTP/2 必须使用 HTTPS（浏览器设定），而 <code>HTTPS 使用的 TLS 协议也存在队头阻塞问题</code>。TLS 基于 Record 组织数据，将一堆数据放在一起（即一个 Record）加密，加密完后又拆分成多个 TCP 包传输。一般每个 Record 16K，包含 12 个 TCP 包，这样如果 12 个 TCP 包中有任何一个包丢失，那么整个 Record 都无法解密。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202110102013812.png" alt="image-20211010201320721"></p>
<p>所以HTTP3换个方式解决了队头阻塞的问题。</p>
</blockquote>
<p>那 QUIC 是如何解决队头阻塞问题的呢？主要有两点。</p>
<ul>
<li>QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题；</li>
<li>QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理。</li>
</ul>
<p>简而言之，TCP层面的队头阻塞是由于TCP本身的特性，UDP不会对上层报文进行切割，整个发送，并且不会前面丢了的不影响后面丢了的包，所以不会有阻塞问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p>《图解HTTP》</p>
</li>
<li><p>《计算机网络 第七版》谢希仁</p>
</li>
<li><p>[三元博客]: <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTk0NjI5ODczOTg1NjUwNjk2I2hlYWRpbmctNDQ=">https://juejin.cn/post/6994629873985650696#heading-44</span></p>
</li>
<li><p>[HTTP/3原理实战 腾讯技术工程]: <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDM0NjQzMzQ=">https://zhuanlan.zhihu.com/p/143464334</span></p>
</li>
</ol>

      <div class="tags">
          <a href="/tags/Computer-Networking/" rel="tag"><i class="ic i-tag"></i> Computer_Networking</a>
          <a href="/tags/HTTP/" rel="tag"><i class="ic i-tag"></i> HTTP</a>
          <a href="/tags/HTTPS/" rel="tag"><i class="ic i-tag"></i> HTTPS</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-12-28 12:23:25" itemprop="dateModified" datetime="2021-12-28T12:23:25+08:00">2021-12-28</time>
  </span>
  <span id="Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/HTTP基础知识点" class="item leancloud_visitors" data-flag-title="HTTP基础知识点" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>Monkey-HH <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://monkeyhh.top/Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" title="HTTP基础知识点">https://monkeyhh.top/Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/HTTP基础知识点</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%A1%88" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202109201019726.png" title="JavaScript中的异步编程方案">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> JavaScript</span>
  <h3>JavaScript中的异步编程方案</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/TCP%E5%92%8CUDP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202111020852730.png" title="TCP和UDP基础知识点">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> Computer_Networking</span>
  <h3>TCP和UDP基础知识点</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E7%89%B9%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">HTTP特点和缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">HTTP特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">HTTP缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">无状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E8%A1%8C"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">安全性不行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">队头阻塞问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">HTTP报文结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">2.1.</span> <span class="toc-text">请求报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">2.2.</span> <span class="toc-text">响应报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3URI%E5%92%8CURL"><span class="toc-number">2.3.</span> <span class="toc-text">怎么理解URI和URL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URI%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">URI结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URI%E7%BC%96%E7%A0%81"><span class="toc-number">2.3.2.</span> <span class="toc-text">URI编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81HTTP%E9%A6%96%E9%83%A8"><span class="toc-number">2.4.</span> <span class="toc-text">常见HTTP首部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5General-headers"><span class="toc-number">2.4.1.</span> <span class="toc-text">通用首部字段General headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5Request-headers"><span class="toc-number">2.4.2.</span> <span class="toc-text">请求首部字段Request headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5Response-headers"><span class="toc-number">2.4.3.</span> <span class="toc-text">响应首部字段Response headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5Entity-headers"><span class="toc-number">2.4.4.</span> <span class="toc-text">实体首部字段Entity headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%AD%A3%E5%BC%8F%E7%9A%84%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">2.4.5.</span> <span class="toc-text">非正式的首部字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B6%88%E6%81%AF%E5%A4%B4-%E4%B8%8E-%E9%80%90%E8%B7%B3%E6%B6%88%E6%81%AF%E5%A4%B4"><span class="toc-number">2.4.6.</span> <span class="toc-text">端到端消息头 与 逐跳消息头</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">常见HTTP状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1xx"><span class="toc-number">3.0.1.</span> <span class="toc-text">1xx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2xx"><span class="toc-number">3.0.2.</span> <span class="toc-text">2xx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3xx"><span class="toc-number">3.0.3.</span> <span class="toc-text">3xx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4xx"><span class="toc-number">3.0.4.</span> <span class="toc-text">4xx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5xx"><span class="toc-number">3.0.5.</span> <span class="toc-text">5xx</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81HTTP%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">常见HTTP方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#get%E5%92%8Cpost%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">get和post有啥区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POST%E5%92%8CPUT%E7%94%A8%E4%BA%8E%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E6%97%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">POST和PUT用于创建资源时有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RESTful-API"><span class="toc-number">4.3.</span> <span class="toc-text">RESTful API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3HTTP%E7%BC%93%E5%AD%98%E5%8F%8A%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">说说如何理解HTTP缓存及缓存代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-number">5.1.</span> <span class="toc-text">强缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Expires"><span class="toc-number">5.1.1.</span> <span class="toc-text">Expires</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Control"><span class="toc-number">5.1.2.</span> <span class="toc-text">Cache-Control</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">5.2.</span> <span class="toc-text">协商缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ETag"><span class="toc-number">5.2.1.</span> <span class="toc-text">ETag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Last-Modified"><span class="toc-number">5.2.2.</span> <span class="toc-text">Last-Modified</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98"><span class="toc-number">5.3.</span> <span class="toc-text">代理缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.1.</span> <span class="toc-text">源服务器的缓存控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#private-%E5%92%8C-public"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">private 和 public</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proxy-revalidate"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">proxy-revalidate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#s-maxage"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">s-maxage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">客户端的缓存控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#max-stale-%E5%92%8C-min-fresh"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">max-stale 和 min-fresh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#only-if-cached"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">only-if-cached</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.4.</span> <span class="toc-text">缓存位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-Worker"><span class="toc-number">5.4.1.</span> <span class="toc-text">Service Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Cache-%E5%92%8C-Disk-Cache"><span class="toc-number">5.4.2.</span> <span class="toc-text">Memory Cache 和 Disk Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Push-Cache"><span class="toc-number">5.4.3.</span> <span class="toc-text">Push Cache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9Cookie%E5%92%8CHTTP%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">6.</span> <span class="toc-text">说说对Cookie和HTTP的联系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">生存周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.0.0.2.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">6.0.0.3.</span> <span class="toc-text">安全相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.0.1.</span> <span class="toc-text">Cookie 的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4HTTP%E4%BB%A3%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">说说HTTP代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">7.0.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">7.0.2.</span> <span class="toc-text">相关头部字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Via"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">Via</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#X-Forwarded-For"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">X-Forwarded-For</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#X-Real-IP"><span class="toc-number">7.0.2.3.</span> <span class="toc-text">X-Real-IP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X-Forwarded-For%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.0.3.</span> <span class="toc-text">X-Forwarded-For产生的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-number">8.</span> <span class="toc-text">HTTP如何处理大文件传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81"><span class="toc-number">8.0.1.</span> <span class="toc-text">如何支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Range-%E5%AD%97%E6%AE%B5%E6%8B%86%E8%A7%A3"><span class="toc-number">8.0.2.</span> <span class="toc-text">Range 字段拆解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%AE%B5%E6%95%B0%E6%8D%AE"><span class="toc-number">8.0.3.</span> <span class="toc-text">单段数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%AE%B5%E6%95%B0%E6%8D%AE"><span class="toc-number">8.0.4.</span> <span class="toc-text">多段数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="toc-number">9.</span> <span class="toc-text">HTTP如何处理表单数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%8E%86%E5%8F%B2"><span class="toc-number">10.</span> <span class="toc-text">HTTP历史</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP-1-0%EF%BC%881996%EF%BC%89%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">HTTP&#x2F;1.0（1996）解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">请求格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E5%BA%94%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.2.</span> <span class="toc-text">回应格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Content-Type-%E5%AD%97%E6%AE%B5"><span class="toc-number">11.3.</span> <span class="toc-text">Content-Type 字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Content-Encoding-%E5%AD%97%E6%AE%B5"><span class="toc-number">11.4.</span> <span class="toc-text">Content-Encoding 字段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP-1-1%EF%BC%881997%EF%BC%89%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">HTTP&#x2F;1.1（1997）解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5-%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">12.1.</span> <span class="toc-text">持久连接&#x2F;长连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%BA%BF%E5%8C%96"><span class="toc-number">12.2.</span> <span class="toc-text">管线化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-1%E4%B8%AD%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">12.3.</span> <span class="toc-text">HTTP1.1中持久连接的缺点：队头阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%A4%9A%E4%B8%AA%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-number">12.4.</span> <span class="toc-text">⭐队头阻塞的解决方案：多个长连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5"><span class="toc-number">12.4.1.</span> <span class="toc-text">并发连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E5%88%86%E7%89%87"><span class="toc-number">12.4.2.</span> <span class="toc-text">域名分片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90%E6%B5%AA%E8%B4%B9%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">说说如何避免长连接资源浪费？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP-2%EF%BC%882015%EF%BC%89%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">HTTP&#x2F;2（2015）解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPDY%E5%8D%8F%E8%AE%AE%EF%BC%882009%EF%BC%89"><span class="toc-number">13.1.</span> <span class="toc-text">SPDY协议（2009）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="toc-number">13.2.</span> <span class="toc-text">HTTP头部压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7Frame%E4%B8%8E%E6%B5%81Stream"><span class="toc-number">13.3.</span> <span class="toc-text">二进制帧Frame与流Stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">13.4.</span> <span class="toc-text">⭐队头阻塞解决方案：多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD"><span class="toc-number">13.5.</span> <span class="toc-text">服务器推送功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTPS%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">HTTPS解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">14.1.</span> <span class="toc-text">HTTPS加密方式概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFSSL-TLS"><span class="toc-number">14.2.</span> <span class="toc-text">说说什么是SSL&#x2F;TLS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4TLS%E5%85%B7%E4%BD%93%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">14.3.</span> <span class="toc-text">说说TLS具体握手过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP-3%EF%BC%882018%EF%BC%89-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">HTTP&#x2F;3（2018） 解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC%EF%BC%882013%EF%BC%89"><span class="toc-number">15.1.</span> <span class="toc-text">QUIC（2013）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">15.2.</span> <span class="toc-text">⭐队头阻塞更进一步的解决方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">16.</span> <span class="toc-text">参考</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li class="active"><a href="/Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" rel="bookmark" title="HTTP基础知识点">HTTP基础知识点</a></li><li><a href="/Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/TCP%E5%92%8CUDP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" rel="bookmark" title="TCP和UDP基础知识点">TCP和UDP基础知识点</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Monkey-HH"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Monkey-HH</p>
  <div class="description" itemprop="description">Learn, share, make progress</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">35</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">13</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">17</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vbmtleS1ISA==" title="https:&#x2F;&#x2F;github.com&#x2F;monkey-HH"><i class="ic i-github"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOmhoanNjYXVAMTYzLmNvbQ==" title="mailto:hhjscau@163.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>Links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%A1%88" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/TCP%E5%92%8CUDP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E7%AF%87%E3%80%91%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" title="【V8引擎原理篇】浏览器原理介绍">【V8引擎原理篇】浏览器原理介绍</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Computer-Basics/" title="In Computer_Basics">Computer_Basics</a>
<i class="ic i-angle-right"></i>
<a href="/categories/Computer-Basics/Operating-System/" title="In Operating_System">Operating_System</a>
</div>

    <span><a href="/Computer-Basics/Operating-System/Computer_Basics/Operating_System/%E7%A3%81%E7%9B%98%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" title="磁盘与常见磁盘调度算法">磁盘与常见磁盘调度算法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%ADDOM%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93" title="JavaScript中DOM操作总结">JavaScript中DOM操作总结</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" title="JavaScript事件循环">JavaScript事件循环</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" title="JavaScript执行上下文">JavaScript执行上下文</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91this%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E3%80%81bind%E3%80%81apply" title="【手撕JavaScript系列】this原理以及模拟实现call、bind、apply">【手撕JavaScript系列】this原理以及模拟实现call、bind、apply</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/NodeJS/" title="In NodeJS">NodeJS</a>
</div>

    <span><a href="/FrontEnd/NodeJS/FrontEnd/NodeJS/NodeJS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8" title="NodeJS基础知识入门">NodeJS基础知识入门</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Module-Bundler/" title="In Module_Bundler">Module_Bundler</a>
</div>

    <span><a href="/FrontEnd/Module-Bundler/FrontEnd/Module_Bundler/Webpack5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%A5%E9%97%A8" title="Webpack5基础知识点入门">Webpack5基础知识点入门</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Computer-Basics/" title="In Computer_Basics">Computer_Basics</a>
<i class="ic i-angle-right"></i>
<a href="/categories/Computer-Basics/Computer-Networking/" title="In Computer_Networking">Computer_Networking</a>
</div>

    <span><a href="/Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/TCP%E5%92%8CUDP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" title="TCP和UDP基础知识点">TCP和UDP基础知识点</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91JavaScript%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D" title="【手撕JavaScript系列】JavaScript中的浅拷贝和深拷贝">【手撕JavaScript系列】JavaScript中的浅拷贝和深拷贝</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Monkey-HH @ Monkey's Blog</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="Symbols count total">469k words</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="Reading time total">7:07</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'Computer-Basics/Computer-Networking/Computer_Basics/Computer_Networking/HTTP基础知识点',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
