



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://monkeyhh.top/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://monkeyhh.top/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://monkeyhh.top/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="Vue" />


<link rel="canonical" href="https://monkeyhh.top/FrontEnd/Vue/FrontEnd/Vue/%E3%80%90Vue%E8%BF%9B%E9%98%B6%E3%80%91%E6%B5%85%E8%B0%88Vue2%E4%B8%8EVue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86">



  <title>
【Vue进阶】浅谈Vue2与Vue3响应式原理 - Vue - FrontEnd |
Monkey's Blog = </title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">【Vue进阶】浅谈Vue2与Vue3响应式原理
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-12-06 12:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-12-06T12:00:00+08:00">2021-12-06</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>21k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>19 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Monkey's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112281046623.jpeg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/" itemprop="item" rel="index" title="In FrontEnd"><span itemprop="name">FrontEnd</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/Vue/" itemprop="item" rel="index" title="In Vue"><span itemprop="name">Vue</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://monkeyhh.top/FrontEnd/Vue/FrontEnd/Vue/%E3%80%90Vue%E8%BF%9B%E9%98%B6%E3%80%91%E6%B5%85%E8%B0%88Vue2%E4%B8%8EVue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Monkey-HH">
    <meta itemprop="description" content=", Learn, share, make progress">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>提到Vue的基本原理，最首先要知道的就是Vue的响应式原理，下面谈谈我自己对于Vue响应式的理解。</p>
<h1 id="什么是响应式（reactivity）？"><a href="#什么是响应式（reactivity）？" class="headerlink" title="什么是响应式（reactivity）？"></a>什么是响应式（reactivity）？</h1><blockquote>
<p>简而言之：将“数据的变化”映射到“DOM的变化”。</p>
</blockquote>
<p>对于Vue来说最终要实现的响应式的效果就是，UI=f(state)，只要有state，就能渲染出对应的UI界面。</p>
<p>而深挖其中，我们把问题给简化，则可以表示为两个变量之间的响应式，举个最简单的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span> </span><br><span class="line"><span class="keyword">let</span> b = a*<span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 30</span></span><br><span class="line">a=<span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 还是30!</span></span><br></pre></td></tr></table></figure>

<p>响应式是什么效果呢，我们希望b永远是a的10倍，只要a变动了，b立马能侦测到并且更新自己的值，就像下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onAChanged(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	b = a * <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么同样，在界面上想实现UI根据state自动更新，代码像下面这样</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;cell b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    onStateChanged(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.cell.b&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        .textContent = state.a * <span class="number">10</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 我们再往上走一步，我们知道Vue是<code>声明式编程</code>的，在Vue，我们则是要达到下面的效果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;cell b&quot;</span>&gt;</span></span><br><span class="line">	&#123;&#123; state.a * 10 &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	onStateChanged(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        view = render(state)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="Vue1-Vue2的变化？"><a href="#Vue1-Vue2的变化？" class="headerlink" title="Vue1-Vue2的变化？"></a>Vue1-Vue2的变化？</h1><p>由于Vue1更新粒度太细，每个状态绑定的依赖太多，依赖追踪在内存上开销太大。</p>
<p>因此Vue2引入了虚拟DOM，将粒度调整为中等粒度。<strong>即一个状态所绑定的依赖不再是具体的DOM节点，而是一个组件。</strong></p>
<p>这样状态变化后，会通知到组件，组件内部再使用虚拟DOM进行比对。<u>大大降低依赖数量，从而降低依赖追踪所消耗的内存。</u></p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202111282350307.png"></p>
<h1 id="Vue2的响应式"><a href="#Vue2的响应式" class="headerlink" title="Vue2的响应式"></a>Vue2的响应式</h1><p>我们来看下面的图，解释了Vue2响应式实现的全过程</p>
<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202111290929698.png" alt="image-20211129092743606" style="zoom:67%;" />

<p>Data就是一个对象，例如{a:123}。</p>
<p>Observer、Dep、Watcher在Vue2中都是es6的类，他们之间的关系如下：</p>
<blockquote>
<ul>
<li>Data通过Observer转换成了getter/setter 的形式来追踪变化。</li>
<li>当外界通过Watcher读取数据时，会触发getter 从而将Watcher添加到依赖中。</li>
<li>当数据发生了变化时，会触发setter，从而向Dep中的依赖( Watcher )发送通知。</li>
<li>Watcher接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li>
</ul>
</blockquote>
<p>是不是有点乱，别担心，接下来我们逐步讲解。</p>
<h2 id="如何用getter、setter做到数据变化侦测？"><a href="#如何用getter、setter做到数据变化侦测？" class="headerlink" title="如何用getter、setter做到数据变化侦测？"></a>如何用getter、setter做到数据变化侦测？</h2><p>在正式开始之前，先用一个简单的例子讲解一下这一点，方便后面深入学习。</p>
<p>几个关键词的意思：</p>
<ul>
<li><code>Dep</code>：Dependency依赖的简写，管理依赖的地方，负责收集依赖、删除依赖、向依赖发送消息。</li>
<li><code>effect</code>：意思是副作用，即属性变化时候的“回调”，也可以理解为“响应”</li>
<li><code>depend</code>：为effect依赖注册，对应effect将会在notify之后才调用</li>
<li><code>notify</code>：用于通知该dep：“嘿，变化了，你得调用effect了”</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span> <span class="comment">//只是用来暂时存要注册的effect</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用来存effects</span></span><br><span class="line">	subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">			<span class="built_in">this</span>.subscribers.add(activeEffect)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.subscribers.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">			effect()</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">	activeEffect = effect</span><br><span class="line">	effect()</span><br><span class="line">	activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个依赖关系</span></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把effect</span></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	dep.depend()<span class="comment">//手动在effect事件中调用depend</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;effect run&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动触发</span></span><br><span class="line">dep.notify()</span><br></pre></td></tr></table></figure>

<p>现在的效果就是我们可以往一个依赖里添加effect，也可以通过手动的方式调用notify来“通知”依赖。</p>
<p>但是好像和我们要讲的响应式还有很大的区别，比如，响应式最起码是有和一个“值”关联，根据这个值做出“响应式”的effect。</p>
<p>最简单的，咱们在new依赖的时候，传入一个值value，模拟要监听这个值。</p>
<p>并且，我们希望在value改变的时候，会自动触发notify函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">		<span class="built_in">this</span>._value = value<span class="comment">// 下划线没错阿，setter/getter是hook函数，而真实的存储变量是_value</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">		<span class="built_in">this</span>.depend()<span class="comment">//在访问值的时候，就会自动注册effect</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>._value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>._value = newValue</span><br><span class="line">		<span class="built_in">this</span>.notify()<span class="comment">//当值更新的时候，自动通知依赖去执行effect</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">			<span class="built_in">this</span>.subscribers.add(activeEffect)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.subscribers.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">			effect()</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">	activeEffect = effect</span><br><span class="line">	effect()</span><br><span class="line">	activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(dep.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>好，此时打开浏览器验证一下，咱们通过以下代码修改dep的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep.value = <span class="string">&#x27;changed&#x27;</span></span><br></pre></td></tr></table></figure>

<p>结果如下，发现在值改变的时候，会“自动”提示了</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202111282329564.png" alt="image-20211128232927517"></p>
<blockquote>
<p>此处基础不牢固的同学可能不知道什么时候把事件给注册了？</p>
<p>回答这个问题其实就是看什么时候调用了getter方法，在watchEffects函数中的“dep.value”就是调用了getter。</p>
<p>顺便扩展一个小知识，如果dep.value改成dep._value，那么是不会调用getter的。</p>
</blockquote>
<p>小总结：Object可以通过Object.defineProperty将属性的getter/set进行改造从而追踪变化。读取数据时会触发getter，修改数据时会触发setter。</p>
<p>到这里大家就能大概明白如何通过setter和getter做到数据侦测了，接下来往vue的源码靠。</p>
<h2 id="Dep类：注册依赖、派发更新"><a href="#Dep类：注册依赖、派发更新" class="headerlink" title="Dep类：注册依赖、派发更新"></a>Dep类：注册依赖、派发更新</h2><blockquote>
<p>源码位于：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9ibG9iLzA2MDNmZjY5NWQyZjQxMjg2MjM5Mjk4MjEwMTEzY2JlMmIyMDllMjgvc3JjL2NvcmUvb2JzZXJ2ZXIvZGVwLmpz">src/core/observer/dep.js</span></p>
</blockquote>
<p>Dep就是dependency的缩写，其目的就是帮助我们收集【究竟要通知到哪里的】，它会有一个数组专门帮助我们管理订阅者。</p>
<p>我们用一个生活中的例子来方便理解：每家报社都有一个订阅服务，当顾客（订阅者）想得知最新的刊物信息，就可以去报刊里注册一下个人信息，报刊就会把这个人记录在报刊的名册中，当出新刊物时，就会查阅这个名册，按照名册给每个顾客<strong>逐个</strong>发送一条短信：“我们出了一本新的杂志，请问您有兴趣购买吗？”</p>
<p>那么这个场景的角色对应到代码中则是：</p>
<ul>
<li>报刊：Dep类</li>
<li>名册：Dep类实例的subs数组</li>
<li>顾客（订阅者）：Watcher类。</li>
</ul>
<p>我们看下源码怎么写的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.subs = [] <span class="comment">// 订阅者数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 工具函数-增加订阅者</span></span><br><span class="line">	<span class="function"><span class="title">addSub</span>(<span class="params">sub:Watcher</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 工具函数-移除订阅者</span></span><br><span class="line">	<span class="function"><span class="title">removeSub</span>(<span class="params">sub:Watcher</span>)</span> &#123;</span><br><span class="line">		remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 注册订阅者——将Dep.target加入到订阅者数组</span></span><br><span class="line">    <span class="comment">// Dep.target事实上是一个Watcher类，后面会提到</span></span><br><span class="line">	<span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">            </span><br><span class="line">            Dep.target.addDep(<span class="built_in">this</span>)</span><br><span class="line">            <span class="comment">// Dep.target是一个Watcher实例，内部的addDep(dep)方法，干了以下两件事</span></span><br><span class="line">            <span class="comment">// 保存dep实例：把当前dep实例添加到Watcher内部的队列中，即 this.newDeps.push(dep)</span></span><br><span class="line">            <span class="comment">// 注册依赖：把Dep.target添加到当前dep的subs队列中，相当于 this.addSub(Dep.target)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派发更新 函数</span></span><br><span class="line">	<span class="comment">// 在数据被更新时，会遍历subs对象，触发每一个订阅者的update方法</span></span><br><span class="line">    <span class="comment">// 这意味着Watch类会有update方法</span></span><br><span class="line">	<span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">			subs[i].update()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span> <span class="comment">// 我们用来存放Watcher实例的地方</span></span><br></pre></td></tr></table></figure>

<p>此处我们可以看到Dep的几个重要方法:</p>
<ul>
<li><code>dep.depend</code>：注册订阅者，内部就是把watcher加到subs数组中去。</li>
<li><code>dep.notify</code>：派发更新，遍历subs数组，调用每一个watcher（订阅者）的update方法。</li>
</ul>
<p>❓咱们现在有一个可以管理订阅者的地方了，在第二节里面的例子，我们提到了如何对“一个值”进行监听，但是我们在vue中是对state等的“一个对象”进行监听，明显是不符合要求的，我们要通过一个方式将“obj对象里的key”和“dep类依赖”联系起来，所以咱们要进行改造一下。</p>
<h2 id="核心逻辑：数据劫持（defineReactive方法）"><a href="#核心逻辑：数据劫持（defineReactive方法）" class="headerlink" title="核心逻辑：数据劫持（defineReactive方法）"></a>核心逻辑：数据劫持（defineReactive方法）</h2><blockquote>
<p>源码位于：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9ibG9iLzA2MDNmZjY5NWQyZjQxMjg2MjM5Mjk4MjEwMTEzY2JlMmIyMDllMjgvc3JjL2NvcmUvb2JzZXJ2ZXIvaW5kZXguanM=">src/core/observer/index.js</span></p>
</blockquote>
<p>上面我们提到了报社的例子，我们继续用这里例子。还有两件小疑问：</p>
<ol>
<li>订阅者如何才能注册？答案就是改造数组的getter！我们提前把订阅者（Watcher实例）的个人资料放在一个地方（Dep.target）。当初次渲染界面的时候，会访问到这个数据，会触发getter，在getter中将订阅者个人资料注册到报刊的名册中(dep.subs)。</li>
<li>“出版新刊物”就相当于给某个响应式的数据<strong>赋新值</strong>，那怎么实现在上新刊的时候“自动”发送短信呢？答案就是通过改造数据的Setter。当数据发生变化的时候，会触发数据的setter，这时候我们就可以给每个订阅者发短信了（遍历dep.subs，调用watcher.update）。</li>
</ol>
<p>在Vue2中，则是<u>obj的每个key都有一个对应的dep实例来存储该key所对应的所有依赖</u>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj为实现响应式的数据对象</span></span><br><span class="line"><span class="comment">// key为要监听的属性名</span></span><br><span class="line"><span class="comment">// val：[key]对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> dep  = <span class="keyword">new</span> Dep()<span class="comment">//  保证每一个属性能保存自己的value和dep</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">		<span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(Dep.target)&#123;</span><br><span class="line">                dep.depend() <span class="comment">//⭐</span></span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">return</span> val</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (val == newValue)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			val = newVal</span><br><span class="line">			dep.notify()  <span class="comment">//⭐</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>欸，那么很明显了，咱们defineReactive()方法对Object.property()方法进行了封装，顾名思义，其作用是定义一个响应式数据。</p>
<p>getter方法里注册依赖并且把依赖放在dep里，setter方法则会派发更新。</p>
<p>❓现在是有这个defineReactive方法了，能够实现对obj的一个key的依赖的管理，那怎么对一个obj的所有key都这样操作一波呢？没错，就是遍历对象的所有key，对其所有的key都调用该方法，那么由谁来进行这个操作呢？答案就是Observer类。</p>
<h2 id="Observer类：将数据转为响应式"><a href="#Observer类：将数据转为响应式" class="headerlink" title="Observer类：将数据转为响应式"></a>Observer类：将数据转为响应式</h2><blockquote>
<p>源码位于：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9ibG9iLzA2MDNmZjY5NWQyZjQxMjg2MjM5Mjk4MjEwMTEzY2JlMmIyMDllMjgvc3JjL2NvcmUvb2JzZXJ2ZXIvaW5kZXguanM=">src/core/observer/index.js</span></p>
</blockquote>
<p>现实生活中一家报社是不会只有一份刊物的，就像我们的数据对象一样，往往是由多个值组成。因此，我们需要一个对象来对Data对象里的数据进行遍历，改造所有数据的getter和setter。</p>
<p>Observer对象：观察者，可以理解为通过Observer来监视Data。只要我们将一个Data传到Observer中，Obeserver就会遍历Data对象，对Data对象的所有数据调用Object.defineProperty()进行改造，使得这个Data就会变成响应式数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 调用Observer</span></span><br><span class="line">  <span class="keyword">new</span> Observer(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer类会附加到每一个被侦测的object上。</span></span><br><span class="line"><span class="comment">// 一旦被附加上，Observer会将object的所有属性转换为getter/setter的形式</span></span><br><span class="line"><span class="comment">// 来收集属性的依赖，并且当属性发生变化时会通知这些依赖</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入的value为一个Object对象，比如说一个state对象</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">	    <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="comment">//是对象则调用walk</span></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">			<span class="built_in">this</span>.walk(value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// walk翻译过来就是：遍历！</span></span><br><span class="line">    <span class="comment">// 会将每一个属性都转换成getter/setter的形式来侦测变化</span></span><br><span class="line">	<span class="comment">// 这个方法只有在数据类型为object时被调用</span></span><br><span class="line">	<span class="function"><span class="title">walk</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历key，把obj的所有key遍历，都设为响应式，</span></span><br><span class="line">		<span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;keys.length;i++)&#123;</span><br><span class="line">			defineReactive(obj,keys[i]]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，相信细心的同学会发现一个问题，单纯地遍历所有key进行响应式的改造，那如果其中有一个key是引用类型呢？我们这样子的做法，其实只能实现数据的“浅”响应，即如果属性对应的引用对象值改变，我们是检测不到的。</p>
<p>所以要对defineReactive进行改造，改造方案也很简单，如果判断到某个key的值是引用类型，那就对这个key再用Observer遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> val  === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">new</span> Observer(val)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小总结：到目前为止，已经可以对一个数据对象obj的getter和setter进行改造了，使得访问对象值的时候会注册依赖（即window.target加入到dep中）；更新对象某个属性值会派发更新（即执行dep中的所有依赖的update方法）。</p>
<p>❓说了半天， Dep.target到底是什么？你要注册的这个“订阅者”到底是什么？答案就是Watcher类！</p>
<h2 id="Watcher类：订阅者！"><a href="#Watcher类：订阅者！" class="headerlink" title="Watcher类：订阅者！"></a>Watcher类：订阅者！</h2><p>Watcher依赖于数据的变更，Watcher其实就类似一个<strong>订阅者</strong>的作用，它会订阅数据改变时，我们说的注册依赖，其实就是将watcher放到对象对应key的dep实例中。当数据变更时（即调用了数据的getter），getter中会遍历dep的订阅者数组</p>
<p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<img data-src="https://cn.vuejs.org/images/data.png" alt="data" style="zoom:50%;" />

<p>我们来看下Watcher类的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A watcher parses an expression, collects dependencies,</span></span><br><span class="line"><span class="comment"> * and fires callback when the expression value changes.</span></span><br><span class="line"><span class="comment"> * This is used for both the $watch() api and directives.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * vm：一个数据对象</span></span><br><span class="line"><span class="comment">    * expression：表达式，如b.c，根据data和expression就可以获取watcher依赖的数据</span></span><br><span class="line"><span class="comment">    * cb：回调函数，即update函数中会执行的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">vm, expOrFn, cb</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.vm = vm</span><br><span class="line">		<span class="comment">// 将this.getter设置为parsePath（）函数</span></span><br><span class="line">         <span class="comment">// parsePath能对路径进行解析</span></span><br><span class="line">         <span class="comment">// 这样就可以读取data.a.b.c的内容</span></span><br><span class="line">		<span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">		<span class="built_in">this</span>.cb = cb</span><br><span class="line">		<span class="built_in">this</span>.value = <span class="built_in">this</span>.get()</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里不是定义getter，只是定义了一个名为get的函数</span></span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		Dep.target = <span class="built_in">this</span></span><br><span class="line">		<span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.vm)	</span><br><span class="line">		Dep.target = <span class="literal">undefined</span></span><br><span class="line">		<span class="keyword">return</span> value</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新回调</span></span><br><span class="line">	<span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span> oldValue = <span class="built_in">this</span>.value</span><br><span class="line">		<span class="built_in">this</span>.value = <span class="built_in">this</span>.get()</span><br><span class="line">		<span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.value, oldValue)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该函数会返回一个新的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> bailRE = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`[^<span class="subst">$&#123;unicodeRegExp.source&#125;</span>.$_\\d]`</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path: string</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new Watcher()</code>时执行<code>constructor</code>，调用了实例的<code>get</code>方法，将Dep.target设置为当前Watcher实例，同时Watcher实例的<code>get</code>方法会读取数据的值，从而触发了数据的<code>getter</code>，触发了getter， 就会触发收集依赖的逻辑。而关于收集依赖，上面已经介绍了，会window.target中读取一个依赖并添加到Dep中。</p>
<p>依赖注人到Dep中后,每当data.a.b.c的值发生变化时，就会让依赖列表中所有的依赖循环触发update方法，也就是Watcher中的update方法。而update方法会执行参数中的回调函数，将value和oldValue传到参数中。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a>1. 闭包</h3><p><code>Vue</code>能够实现如此强大的功能，离不开闭包的功劳：在<code>defineReactive</code>中就形成了闭包，这样每个对象的每个属性就能保存自己的值<code>value</code>和依赖对象<code>dep</code>。</p>
<h3 id="2-只要触发getter就会收集依赖吗"><a href="#2-只要触发getter就会收集依赖吗" class="headerlink" title="2. 只要触发getter就会收集依赖吗"></a>2. 只要触发getter就会收集依赖吗</h3><p>答案是否定的。在<code>Dep</code>的<code>depend</code>方法中，我们看到，只有<code>Dep.target</code>为真时才会添加依赖。比如在派发更新时会触发<code>watcher</code>的<code>update</code>方法，该方法也会触发<code>parsePath</code>来取值，但是此时的<code>Dep.target</code>为<code>null</code>，不会添加依赖。仔细观察可以发现，只有<code>watcher</code>的<code>get</code>方法中会调用<code>pushTarget(this)</code>来对<code>Dep.target</code>赋值，其他时候<code>Dep.target</code>都是<code>null</code>，而<code>get</code>方法只会在实例化<code>watcher</code>的时候调用，因此，在我们的实现中，一个<code>watcher</code>的依赖在其实例化时就已经确定了，之后任何读取值的操作均不会增加依赖。</p>
<h3 id="3-依赖嵌套的对象属性"><a href="#3-依赖嵌套的对象属性" class="headerlink" title="3. 依赖嵌套的对象属性"></a>3. 依赖嵌套的对象属性</h3><p>我们结合上面的代码来思考下面这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> w2 = <span class="keyword">new</span> Watcher(obj, <span class="string">&#x27;b.m.n&#x27;</span>, <span class="function">(<span class="params">val, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`obj.b.m.n 从 <span class="subst">$&#123;oldVal&#125;</span>(oldVal) 变成了 <span class="subst">$&#123;val&#125;</span>(newVal)`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们知道，<code>w2</code>会依赖<code>obj.b.m.n</code>， 但是<code>w2</code>会依赖<code>obj.b, obj.b.m</code>吗？或者说，<code>obj.b,和obj.b.m</code>，它们闭包中保存的<code>dep</code>中会有<code>w2</code>吗？答案是会。我们先不从代码角度分析，设想一下，如果我们让<code>obj.b = null</code>，那么很显然<code>w2</code>的回调函数应该被触发，这就说明<code>w2</code>会依赖中间层级的对象属性。</p>
<p>接下来我们从代码层面分析一下：<code>new Watcher()</code>时，会调用<code>watcher的get</code>方法，将<code>Dep.target</code>设置为<code>w2</code>，<code>get</code>方法会调用<code>parsePath</code>来取值，我们来看一下取值的具体过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">obj, expression</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> segments = expression.split(<span class="string">&#x27;.&#x27;</span>) <span class="comment">// 先将表达式分割，segments:[&#x27;b&#x27;, &#x27;m&#x27;, &#x27;n&#x27;]</span></span><br><span class="line">  <span class="comment">// 循环取值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> segments) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">    obj = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上代码流程如下：</p>
<ol>
<li>局部变量<code>obj</code>为对象<code>obj</code>，读取<code>obj.b</code>的值，触发<code>getter</code>，触发<code>dep.depend()</code>(该<code>dep</code>是<code>obj.b</code>的闭包中的<code>dep</code>)，<code>Dep.target</code>存在，添加依赖</li>
<li>局部变量<code>obj</code>为<code>obj.b</code>，读取<code>obj.b.m</code>的值，触发<code>getter</code>，触发<code>dep.depend()</code>(该<code>dep</code>是<code>obj.b.m</code>的闭包中的<code>dep</code>)，<code>Dep.target</code>存在，添加依赖</li>
<li>局部变量<code>obj</code>为对象<code>obj.b.m</code>，读取<code>obj.b.m.n</code>的值，触发<code>getter</code>，触发<code>dep.depend()</code>(该<code>dep</code>是<code>obj.b.m.n</code>的闭包中的<code>dep</code>)，<code>Dep.target</code>存在，添加依赖</li>
</ol>
<p>从上面的代码可以看出，<code>w2</code>会依赖与目标属性相关的每一项，这也是符合逻辑的。</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>变化侦测就是侦测数据的变化。当数据发生变化时，要能侦测到并发出通知。可以通过Object.defineProperty将属性转换成getter/setter的形式来追踪变化。读取数据时会触发getter，修改数据时会触发setter。我们需要在getter中收集有哪些依赖使用了数据。当setter被触发时，去通知getter中收集的依赖数据发生了变化。</p>
<p>收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了Dep，它用来收集依赖、删除依赖和向依赖发送消息等。</p>
<p>所谓的依赖，其实就是Watcher。只有Watcher触发的getter才会收集依赖，哪个Watcher触发了getter, 就把哪个Watcher收集到Dep中。当数据发生变化时，会循环依赖列表，把所有的Watcher都通知一遍。</p>
<p>Watcher的原理是先把自己设置到全局唯一的指定位置 ( 例如Dep.target ),然后读取数据。因为读取了数据，所以会触发这个数据的getter。 接着，在getter 中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个Watcher收集到Dep中去.通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。</p>
<p>此外，我们创建了Observer类，它的作用是把一个object中的所有数据( 包括子数据)都转换成响应式的，也就是它会侦测object中所有数据(包括子数据)的变化。</p>
<p>我们再来过一遍整个完整的过程：</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202202261321827.jpeg" alt="img"></p>
<p>（<span class="exturl" data-url="aHR0cHM6Ly9zZWF3aW5kODg4OC5naXRodWIuaW8vMjAxOS8wNy8xNS8lRTQlQjglODAlRTUlOUIlQkUlRTclOUMlOEIlRTYlODclODJWdWUlRTYlOTUlQjAlRTYlOEQlQUUlRTclQkIlOTElRTUlQUUlOUElRTUlOEUlOUYlRTclOTAlODYv">图源自</span>）</p>
<ol>
<li><p>我们将Data数据对象通过new Observer(data)的形式传给Observer。</p>
</li>
<li><p>Observer会调用walk(data)方法遍历Data的每一个key，并调用Object.defineProperty()转换每一个key的getter/setter，同时每个key会new一个对应的Dep类实例（用以存放watcher）：</p>
<ul>
<li>当调用getter的时候，会调用dep.depend()，将watcher添加到dep队列中</li>
<li>当调用setter的时候，会调用dep.notify()，让每一个watcher去执行自己的update()方法向外界发送通知。变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li>
</ul>
</li>
</ol>
<h2 id="Vue2响应式的弊端"><a href="#Vue2响应式的弊端" class="headerlink" title="Vue2响应式的弊端"></a>Vue2响应式的弊端</h2><p>这部分我们可以查看<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sIyVFNSVBNiU4MiVFNCVCRCU5NSVFOCVCRiVCRCVFOCVCOCVBQSVFNSU4RiU5OCVFNSU4QyU5Ng==">Vue官方文档-如何追踪变化</span>。</p>
<h3 id="对于对象"><a href="#对于对象" class="headerlink" title="对于对象"></a>对于对象</h3><p>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `vm.a` 是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 是非响应式的</span></span><br></pre></td></tr></table></figure>

<p>当我们向object中添加属性或者删除属性的时候，Vue.js通过object. defineProperty来将对象的key转换成gttersetter的形式来追踪变化，<br>但getter/setter 只能追踪一个数据是否被修改，无法追踪新增属性和删除属性（因为新属性是在new Observer（）才加进去的，其getter/setter都没有被改造过）。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 或 <code>vm.$set</code> 方法向嵌套对象添加响应式 property。例如，对于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObject, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.someObject,<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<p>根本解决方案：利用proxy，元编程，在语言层面改造，则新增、删除属性后就不用进行额外操作了，这就是vue3的做法。</p>
<h3 id="对于数组"><a href="#对于数组" class="headerlink" title="对于数组"></a>对于数组</h3><p>Vue 不能检测以下数组的变动：</p>
<ol>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ol>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">items</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure>

<p>看到这里其实会有一点让人很疑惑，Vue不能通过数组索引的方式更改值，用Object.defineProperty对其进行监测不是能改掉这个“Bug”吗？我们来尝试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, value</span>) </span>&#123;</span><br><span class="line">	 <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">		 <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">		 <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">		 <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">defineGet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			 <span class="built_in">console</span>.log(<span class="string">`get key: <span class="subst">$&#123;key&#125;</span> value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">			 <span class="keyword">return</span> value</span><br><span class="line">		 &#125;,</span><br><span class="line">		 <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">defineSet</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">			 <span class="built_in">console</span>.log(<span class="string">`set key: <span class="subst">$&#123;key&#125;</span> value: <span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">			 value = newVal</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">		defineReactive(data, key, data[key])</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">observe(arr)</span><br></pre></td></tr></table></figure>

<p>然后我们执行以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">1</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202202261705719.png" alt="image-20220226170532306" style="zoom:67%;" />

<p>欸，这不是可以解决吗？我们通过索引下标更改数组的时候，Object.defineProperty()可以监测到数据的变化啊，为啥官方不直接这样子提供支持呢？我们来看看Vue作者尤大的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9pc3N1ZXMvODU2Mg==">回答</span>：</p>
<img data-src="C:/Users/monkey/AppData/Roaming/Typora/typora-user-images/image-20220226171207526.png" alt="image-20220226171207526" style="zoom:50%;" />

<p>那就解决了这个疑问了。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将在响应式系统内触发状态更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br><span class="line"><span class="comment">// vm.$set，全局方法 `Vue.set` 的一个别名</span></span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>

<p>为了解决第二类问题，你可以使用 <code>splice</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>

<p>然而<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvbGlzdC5odG1sIyVFNiU5NSVCMCVFNyVCQiU4NCVFNiU5QiVCNCVFNiU5NiVCMCVFNiVBMyU4MCVFNiVCNSU4Qg==">Vue的文档</span>提到了Vue是可以检测到数组变化的，但是只有以下七种方法：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<p>为什么只支持了七种方法？Vue内部又是如何实现这一点的呢？我们接着往下看！</p>
<h2 id="Vue2如何监测数组的变化？"><a href="#Vue2如何监测数组的变化？" class="headerlink" title="Vue2如何监测数组的变化？"></a>Vue2如何监测数组的变化？</h2><p>上面的所有过程中，我们只分析了Vue是如何监测数据对象Object的变化的，没有提到如何监测数组对象的变化，我们知道以上几种方法都会引起数组的变化，但是在ES6之前，我们并没有方法可以监测到数组执行了这几种方法从而导致数组发生了变化。那么Vue是如何做到能够监测由于这几种方法引起的数组的变化的呢？</p>
<p>我们从入口的部分开始研究，即Observer对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入的value为一个Object对象，比如说一个state对象</span></span><br><span class="line">    <span class="title">constructor</span> (<span class="params">value: any</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">// 将数组的原型指向arrayMethods</span></span><br><span class="line">            protoAugment(value, arrayMethods)</span><br><span class="line">            <span class="built_in">this</span>.observeArray(value) <span class="comment">// 调用observeArray()方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="comment">// 逐项进行observe</span></span><br><span class="line">            observe(items[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工具函数：将target的原型指向src</span></span><br><span class="line"><span class="comment"> * Augment a target Object or Array by intercepting the prototype chain using __proto__</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    target.__proto__ = src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vue采用了<strong>函数劫持</strong>的方法：在“Array.prototype”及“数组实例对象”的原型链之间，插入一个Vue内部的类，称为arrayMethods，即</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>] <span class="comment">// 假设一个数组实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayPrototype = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayPrototype) <span class="comment">// arrayMethods.__proto__ === Array.prototype</span></span><br><span class="line"></span><br><span class="line">arr.__proto__ = arrayMethods </span><br></pre></td></tr></table></figure>

<p>画个图演示就是这样子的：</p>
<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202202261654852.png" alt="image-20220226165437235" style="zoom:33%;" />

<p>那么，我们就可以在arrayMethods里定义（改写）我们需要改写的方法，就可以覆盖掉原生方法了啦。我们看看源码是怎么实现这一点的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/src/core/observer/arrar.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)<span class="comment">// 更改arrayMethods的原型指向，指向Array.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示需要改写（增强）的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 备份原方法</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始定义（改写）方法</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 调用原生方法</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把这个数组身上的__ob__取出来</span></span><br><span class="line">    <span class="comment">// 在拦截器中获取Observer的实例</span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> inserted <span class="comment">// 存放插入的新数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有三种方法 push、unshift、splice能插入新项，要劫持（侦测）这些数据（插入新项）</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看有没有新插入的项inserted，有的话就劫持</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么很显然可以看到这里做了几件事情，把需要转换的数组和数组的原型中间插入一个新的对象“arrayMethods”。那么我们就可以在</p>
<p>改写的不是七个，而是只有三个：push、unshift、splice；其次，改写的原因是因为这三个方法可能会向数组添加对象，而现有的监听方法是没有办法对这些新增的对象进行监听的。</p>
<h1 id="Vue3响应式"><a href="#Vue3响应式" class="headerlink" title="Vue3响应式"></a>Vue3响应式</h1><h2 id="ES6-Reflect-and-ES6-Proxy：数据劫持"><a href="#ES6-Reflect-and-ES6-Proxy：数据劫持" class="headerlink" title="ES6 Reflect and ES6 Proxy：数据劫持"></a>ES6 Reflect and ES6 Proxy：数据劫持</h2><p>这里就不讲解Reflect和Proxy的基础知识了，具体可以看红宝书或者<span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9lczYvcmVmbGVjdC5odG1s">阮一峰的ES6</span></p>
<p>我们知道，Proxy在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，那么我们就可以利用这一点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>target：数据对象</span></span><br><span class="line"><span class="comment"> * return：该函数返回一个对target的代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> handler = &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>target：数据对象 </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>key：对象某个属性</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>receiver: 代理对象或继承代理对象的对象</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">			track(target, key) <span class="comment">//⭐,注册依赖</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>target：数据对象 </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>key：对象某个属性</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>value：setter传入的新值</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">receiver</span></span></span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">			<span class="keyword">let</span> oldValue = target[key]</span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span> (oldValue != value) &#123;</span><br><span class="line">				trigger(target, key)<span class="comment">// ⭐当数据更新时，派发更新</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子我们就能得到一个代理过后的数据对象了，并且他的getter和setter都被改造过了：</p>
<ul>
<li>在访问数据的时候，会触发getter，然后track()函数会注册依赖。</li>
<li>随后当更新数据的时候，会触发setter，trigger()函数就会将该对象指定key的所有依赖一一执行。</li>
</ul>
<p>这样子，我们就一了百了，直接从语言层面定义getter和setter，不需要像Vue2一样遍历一个Data的所有key，逐个使用Object.defineProperty()了，非常简便。</p>
<h2 id="注册依赖、派发更新"><a href="#注册依赖、派发更新" class="headerlink" title="注册依赖、派发更新"></a>注册依赖、派发更新</h2><p>上面我们讲到了如何实现数据劫持，下面来讲讲依赖具体是如何注册的、在Vue中是如何存储的。</p>
<p>在vue3中，有很多API进行了改变，例如直接删掉了Dep类等，至于为什么要这样做，可以查看最后面尤雨溪采访记录。</p>
<p>我们用一个简单例子来看看Vue3的响应式中，名词解释（和源码一样）：</p>
<ul>
<li>dep：依赖集合</li>
<li>effect：依赖事件本身，被存到dep里的依赖</li>
<li>track：注册依赖，将effect加入到dep中</li>
<li>trigger：触发器函数，类似于派发更新的作用</li>
</ul>
<p>我们先通过实现一个简单，来看一下如何实现注册依赖、派发更新。好，接下来详细看一下Vue里具体是如何实现的，直接上模型图：</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112011100035.png" alt="image-20211201110020874"></p>
<p>接下来我们依次解释一下：</p>
<ul>
<li><code>targetMap</code>：存储所有的响应式对象，key为对象名，value为对象引用。</li>
<li><code>depsMap</code>：存储某一个响应式对象的所有属性，key为响应式对象的属性，value为一个称为dep的集合。</li>
<li><code>dep</code>：某个响应式对象的某个属性，所对应的所有依赖。</li>
</ul>
<p>好，那么我们现在利用这个模型图，来实现<code>注册依赖</code>以及<code>派发更新</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeEffect = <span class="literal">null</span>;<span class="comment">// 全局对象，用于存放依赖，该依赖为一个函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() <span class="comment">// 全局对象！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>target 响应式数据对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>key 对应的属性名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> depsMap = targetMap.get(target)<span class="comment">// 先获取响应式数据对象所对应的depsMap</span></span><br><span class="line">	<span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">		targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> dep = depsMap.get(key)<span class="comment">// 获取该响应式数据对象某个属性的所有依赖</span></span><br><span class="line">	<span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">		depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">	&#125;</span><br><span class="line">	dep.add(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>target 要查的obj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>key 对应的属性名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">	<span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">	<span class="keyword">if</span> (dep) &#123;</span><br><span class="line">		dep.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> effect())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们实现了注册依赖和派发更新，接下来我们通过下面的一段代码查看简单的过程：</p>
<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112011616977.png" alt="image-20211201161612779" style="zoom: 50%;" />



<p>现在虽然是实现了功能，但是有一个问题，似乎当我们每一次访问product的值的时候，都会导致其执行一次track()，例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(product.quantity)</span><br></pre></td></tr></table></figure>

<p>我们只希望在effect函数里访问getter的时候才调用track，还记得我们代码里面存着的activeEffect吗？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span> <span class="comment">//⭐</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">eff</span>)</span>&#123;</span><br><span class="line">    activeEffect = eff</span><br><span class="line">    activeEffect()</span><br><span class="line">    activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">effect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    total = product.price * product.quantity</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(activeEffect)&#123;</span><br><span class="line">        </span><br><span class="line">		dep.add(activeEffect)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子，虽然在访问getter的时候还是会调用track函数，但是不会执行内部代码，就不会有额外的执行性能浪费。</p>
<h2 id="实现ref"><a href="#实现ref" class="headerlink" title="实现ref"></a>实现ref</h2><p>咱们在Vue3中是这么使用<code>ref</code>的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = ref(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num.value) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>然后<code>num</code>就会成为一个响应式的数据，而且使用<code>num</code>时需要这么写<code>num.value</code>才能使用</p>
<p>实现ref其实很简单，咱们上面已经实现了<code>reactive</code>，只需要这么做就可以实现<code>ref</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span> (<span class="params">initValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reactive(&#123;</span><br><span class="line">        <span class="attr">value</span>: initValue</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咱们可以来试试效果如何</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = ref(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">effect(<span class="function">() =&gt;</span> sum = num.value * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 500</span></span><br><span class="line"></span><br><span class="line">num.value = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>这样子确实可以实现功能，但是Vue3中不是这样实现的，至于为什么要这样子设置，可以看第六节的问题五。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> r = &#123;</span><br><span class="line">		<span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">			track(r, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">			<span class="keyword">return</span> raw</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="keyword">set</span> <span class="title">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (raw != newVal) &#123;</span><br><span class="line">				raw = newVal</span><br><span class="line">				trigger(r, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现computed"><a href="#实现computed" class="headerlink" title="实现computed"></a>实现computed</h2><p>咱们顺便简单实现一下<code>computed</code>吧，其实也很简单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computed</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = ref()</span><br><span class="line">    effect(<span class="function">() =&gt;</span> result.value = fn()) <span class="comment">// 执行computed传入函数</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咱们来看看结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = ref(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> num2 = ref(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">let</span> sum1 = computed(<span class="function">() =&gt;</span> num1.value * num2.value)</span><br><span class="line"><span class="keyword">let</span> sum2 = computed(<span class="function">() =&gt;</span> sum1.value * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum1.value) <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2.value) <span class="comment">// 400</span></span><br><span class="line"></span><br><span class="line">num1.value = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum1.value) <span class="comment">// 80</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2.value) <span class="comment">// 800</span></span><br><span class="line"></span><br><span class="line">num2.value = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum1.value) <span class="comment">// 160</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2.value) <span class="comment">// 1600</span></span><br></pre></td></tr></table></figure>

<p>自此咱们就实现了本文章所有功能</p>
<h2 id="Proxy方案的弊端"><a href="#Proxy方案的弊端" class="headerlink" title="Proxy方案的弊端"></a>Proxy方案的弊端</h2><p>使用了Proxy，就代表了放弃对低版本浏览器的兼容（兼容版本ie11以上）。</p>
<h1 id="尤雨溪采访记录"><a href="#尤雨溪采访记录" class="headerlink" title="尤雨溪采访记录"></a>尤雨溪采访记录</h1><p>以下是Vue的创始人尤雨溪回答的一些问题，可以让我们直接地了解到作者在响应式这件事情上的想法。</p>
<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><blockquote>
<p>Q：在Vue2中用<code>depend</code>、<code>notify</code> 而Vue3改用<code>track</code>、<code>trigger</code>，来对应描述effects的<code>保存</code>与<code>调用</code>，为什么要改称谓？</p>
</blockquote>
<img data-src="C:/Users/monkey/AppData/Roaming/Typora/typora-user-images/image-20211128213456492.png" alt="image-20211128213456492" style="zoom:67%;" />

<p>回答总结：本质两个说法是一个东西，当提到<code>depend</code>、<code>notify</code> ，由于这两个词是动词，自然会想到这是和它的Owner所有者有关，即Vue2里的<code>Dep</code>类，所以可以说一个<code>Dep</code>类的实例正在被依赖，或者说它通知了它的订阅者。</p>
<p>在Vue3中已经没有<code>Dep</code>类了，<code>depend</code>、<code>notify</code> 的逻辑被抽离到两个独立的函数（track、trigger）里，当调用track、trigger时更像跟踪什么，而不是什么东西被依赖，只是动词的变化，就好像a.b到b.call(a)。</p>
<p>虽然但是，确实有点绕，大家当看个乐。</p>
<h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><blockquote>
<p>Q：Vue里Dep是一个类，在Vue3里dep只是一个Set集合，为什么这样改？</p>
</blockquote>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202111282135172.png" alt="image-20211128211044673"></p>
<p>回答总结：Vue2里用类容易让人思考依赖关系（作为一个有着特定行为的类）。从另一方面就是我们从第一个问题可以看出，具体实现细节变了，用一个set就能搞定的东西，干嘛要用一个更重的 类来表明，这样弄能优化性能。</p>
<h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><blockquote>
<p>Q：Vue3里为什么不把dep叫成effects？</p>
</blockquote>
<p>其他地方会用到effects，但是他们不是一个概念，容易弄混淆。</p>
<h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2><blockquote>
<p>Q：怎么搞出下方这个解决方案来存effects的？</p>
</blockquote>
<p>Vue2里能有闭包存储对应的dep，而Vue3的写法中没法有闭包。</p>
<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202111282206761.png" alt="image-20211128220631616" style="zoom: 80%;" />

<h2 id="问题五"><a href="#问题五" class="headerlink" title="问题五"></a>问题五</h2><blockquote>
<p>为什么定义ref的时候不用左边的方案，而用右边的？</p>
</blockquote>
<p>定义上来说，ref应该返回一个值，如果使用左边的方案，会给它附加一些新属性，这样就违背了ref的目的。 </p>
<p>另外，我们有isRef检查，返回的ref实际上有一些特殊的东西，让我们知道实际上它是一个ref，而不是“响应式对象”。</p>
<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112020907749.png" alt="image-20211202090731594" style="zoom: 80%;" />

<h2 id="问题六"><a href="#问题六" class="headerlink" title="问题六"></a>问题六</h2><blockquote>
<p>Vue3里用Proxy、Reflect的方式还有啥好处？</p>
</blockquote>
<p>把对象的响应式转化可以变成lazy的。</p>

      <div class="tags">
          <a href="/tags/Vue/" rel="tag"><i class="ic i-tag"></i> Vue</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-02-26 20:18:21" itemprop="dateModified" datetime="2022-02-26T20:18:21+08:00">2022-02-26</time>
  </span>
  <span id="FrontEnd/Vue/FrontEnd/Vue/【Vue进阶】浅谈Vue2与Vue3响应式原理" class="item leancloud_visitors" data-flag-title="【Vue进阶】浅谈Vue2与Vue3响应式原理" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>Monkey-HH <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://monkeyhh.top/FrontEnd/Vue/FrontEnd/Vue/%E3%80%90Vue%E8%BF%9B%E9%98%B6%E3%80%91%E6%B5%85%E8%B0%88Vue2%E4%B8%8EVue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86" title="【Vue进阶】浅谈Vue2与Vue3响应式原理">https://monkeyhh.top/FrontEnd/Vue/FrontEnd/Vue/【Vue进阶】浅谈Vue2与Vue3响应式原理</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/FrontEnd/Babel/FrontEnd/Babel/Babel%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202202101724865.png" title="Babel的基本使用与原理介绍">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> Babel</span>
  <h3>Babel的基本使用与原理介绍</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/FrontEnd/Package-Manager/FrontEnd/Package_Manager/pnpm%E7%9B%B8%E8%BE%83%E4%BA%8Enpm%E5%92%8Cyarn%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202112281044723.jpeg" title="pnpm相较于npm和yarn有什么优点？">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> Package_Manager</span>
  <h3>pnpm相较于npm和yarn有什么优点？</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%88reactivity%EF%BC%89%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是响应式（reactivity）？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue1-Vue2%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">Vue1-Vue2的变化？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">Vue2的响应式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8getter%E3%80%81setter%E5%81%9A%E5%88%B0%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">如何用getter、setter做到数据变化侦测？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dep%E7%B1%BB%EF%BC%9A%E6%B3%A8%E5%86%8C%E4%BE%9D%E8%B5%96%E3%80%81%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0"><span class="toc-number">4.2.</span> <span class="toc-text">Dep类：注册依赖、派发更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%EF%BC%88defineReactive%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">核心逻辑：数据劫持（defineReactive方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Observer%E7%B1%BB%EF%BC%9A%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E4%B8%BA%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">Observer类：将数据转为响应式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Watcher%E7%B1%BB%EF%BC%9A%E8%AE%A2%E9%98%85%E8%80%85%EF%BC%81"><span class="toc-number">4.5.</span> <span class="toc-text">Watcher类：订阅者！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">4.6.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AD%E5%8C%85"><span class="toc-number">4.6.1.</span> <span class="toc-text">1. 闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AA%E8%A6%81%E8%A7%A6%E5%8F%91getter%E5%B0%B1%E4%BC%9A%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96%E5%90%97"><span class="toc-number">4.6.2.</span> <span class="toc-text">2. 只要触发getter就会收集依赖吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BE%9D%E8%B5%96%E5%B5%8C%E5%A5%97%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">4.6.3.</span> <span class="toc-text">3. 依赖嵌套的对象属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">4.7.</span> <span class="toc-text">小总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">4.8.</span> <span class="toc-text">Vue2响应式的弊端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.8.1.</span> <span class="toc-text">对于对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84"><span class="toc-number">4.8.2.</span> <span class="toc-text">对于数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">Vue2如何监测数组的变化？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">Vue3响应式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-Reflect-and-ES6-Proxy%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81"><span class="toc-number">5.1.</span> <span class="toc-text">ES6 Reflect and ES6 Proxy：数据劫持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BE%9D%E8%B5%96%E3%80%81%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0"><span class="toc-number">5.2.</span> <span class="toc-text">注册依赖、派发更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0ref"><span class="toc-number">5.3.</span> <span class="toc-text">实现ref</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0computed"><span class="toc-number">5.4.</span> <span class="toc-text">实现computed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy%E6%96%B9%E6%A1%88%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">5.5.</span> <span class="toc-text">Proxy方案的弊端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%A4%E9%9B%A8%E6%BA%AA%E9%87%87%E8%AE%BF%E8%AE%B0%E5%BD%95"><span class="toc-number">6.</span> <span class="toc-text">尤雨溪采访记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80"><span class="toc-number">6.1.</span> <span class="toc-text">问题一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C"><span class="toc-number">6.2.</span> <span class="toc-text">问题二</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89"><span class="toc-number">6.3.</span> <span class="toc-text">问题三</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9B%9B"><span class="toc-number">6.4.</span> <span class="toc-text">问题四</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%94"><span class="toc-number">6.5.</span> <span class="toc-text">问题五</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%85%AD"><span class="toc-number">6.6.</span> <span class="toc-text">问题六</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li class="active"><a href="/FrontEnd/Vue/FrontEnd/Vue/%E3%80%90Vue%E8%BF%9B%E9%98%B6%E3%80%91%E6%B5%85%E8%B0%88Vue2%E4%B8%8EVue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86" rel="bookmark" title="【Vue进阶】浅谈Vue2与Vue3响应式原理">【Vue进阶】浅谈Vue2与Vue3响应式原理</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Monkey-HH"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Monkey-HH</p>
  <div class="description" itemprop="description">Learn, share, make progress</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">54</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">18</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">23</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vbmtleS1ISA==" title="https:&#x2F;&#x2F;github.com&#x2F;monkey-HH"><i class="ic i-github"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOmhoanNjYXVAMTYzLmNvbQ==" title="mailto:hhjscau@163.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>Links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/FrontEnd/Babel/FrontEnd/Babel/Babel%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/FrontEnd/Package-Manager/FrontEnd/Package_Manager/pnpm%E7%9B%B8%E8%BE%83%E4%BA%8Enpm%E5%92%8Cyarn%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%A1%88" title="JavaScript中的异步编程方案">JavaScript中的异步编程方案</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/uncategorized/FrontEnd/Browser/%E3%80%90V8%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86%E7%AF%87%E3%80%91Event%20Loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6" title="Untitled">Untitled</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" title="JavaScript执行上下文">JavaScript执行上下文</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/CSS/" title="In CSS">CSS</a>
</div>

    <span><a href="/FrontEnd/CSS/FrontEnd/CSS/CSS3%E5%8A%A8%E7%94%BB%E5%85%A5%E9%97%A8" title="CSS3动画入门">CSS3动画入门</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E6%B5%8F%E8%A7%88%E5%99%A8Web%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2" title="浏览器Web安全攻防">浏览器Web安全攻防</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Operations/" title="In Operations">Operations</a>
</div>

    <span><a href="/Operations/Operations/%E3%80%90Git%E3%80%91Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%93%8D%E4%BD%9C" title="【Git】Git基本使用与操作">【Git】Git基本使用与操作</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81" title="【手撕JavaScript系列】JavaScript中的防抖与节流">【手撕JavaScript系列】JavaScript中的防抖与节流</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%88BOM%EF%BC%89" title="JavaScript中的浏览器对象模型（BOM）">JavaScript中的浏览器对象模型（BOM）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91this%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E3%80%81bind%E3%80%81apply" title="【手撕JavaScript系列】this原理以及模拟实现call、bind、apply">【手撕JavaScript系列】this原理以及模拟实现call、bind、apply</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/BackEnd/" title="In BackEnd">BackEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/BackEnd/Linux/" title="In Linux">Linux</a>
</div>

    <span><a href="/BackEnd/Linux/BackEnd/Linux/%E3%80%90Linux%E3%80%91Linux%E7%B3%BB%E7%BB%9F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A" title="【Linux】Linux基础知识">【Linux】Linux基础知识</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2021 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Monkey-HH @ Monkey's Blog</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="Symbols count total">773k words</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="Reading time total">11:43</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'FrontEnd/Vue/FrontEnd/Vue/【Vue进阶】浅谈Vue2与Vue3响应式原理',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
