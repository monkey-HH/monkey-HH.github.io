



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://monkeyhh.top/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://monkeyhh.top/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://monkeyhh.top/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="JavaScript" />


<link rel="canonical" href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B">



  <title>
JavaScript中的变量类型 - JavaScript - FrontEnd |
Monkey's Blog = </title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">JavaScript中的变量类型
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-05-04 09:28:32">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-05-04T09:28:32+08:00">2021-05-04</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>30k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>28 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Monkey's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202109201019726.png">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/" itemprop="item" rel="index" title="In FrontEnd"><span itemprop="name">FrontEnd</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/JavaScript/" itemprop="item" rel="index" title="In JavaScript"><span itemprop="name">JavaScript</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Monkey-HH">
    <meta itemprop="description" content=", Learn, share, make progress">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>变量和类型是学习<code>JavaScript</code>最先接触到的东西，但是往往看起来最简单的东西往往还隐藏着很多你不了解、或者容易犯错的知识，比如下面几个问题：</p>
<ul>
<li><code>JavaScript</code>中的变量在内存中的具体存储形式是什么？</li>
<li><code>0.1+0.2</code>为什么不等于<code>0.3</code>?发生小数计算错误的具体原因是什么？</li>
<li><code>Symbol</code>的特点，以及实际应用场景是什么？</li>
<li><code>[] == ![]</code>、<code>[undefined] == false</code>为什么等于<code>true</code>?代码中何时会发生隐式类型转换？转换的规则是什么？</li>
<li>如何精确的判断变量的类型？</li>
</ul>
<p>如果你还不能很好的解答上面的问题，那说明你还没有完全掌握这部分的知识，那么请好好阅读下面的文章吧。</p>
<p>本文从底层原理到实际应用详细介绍了<code>JavaScript</code>中的变量和类型相关知识。</p>
<h1 id="变量分类：原始值与引用值"><a href="#变量分类：原始值与引用值" class="headerlink" title="变量分类：原始值与引用值"></a>变量分类：原始值与引用值</h1><p>ECMAScript变量有两种不同类型的数据：<strong>原始值（Primitive Value）和引用值（Reference Value）。</strong></p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9QcmltaXRpdmU=">原始类型</span>：共七种，使用 typeof 运算符检查:<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS91bmRlZmluZWQ=">undefined</span>：<code>typeof instance === &quot;undefined&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Cb29sZWFu">Boolean</span>：<code>typeof instance === &quot;boolean&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdW1iZXI=">Number</span>：<code>typeof instance === &quot;number&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TdHJpbmc=">String</span>：<code>typeof instance === &quot;string</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TeW1ib2w=">Symbol</span> （ES7新特性）：<code>typeof instance === &quot;symbol&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9CaWdJbnQ=">BigInt</span> （ES11新特性）：<code>typeof instance === &quot;bigint&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdWxs">null</span>：<code>typeof instance === &quot;object&quot;</code></li>
</ul>
</li>
<li>引用值类型：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9PYmplY3Q=">Object</span>：<code>typeof instance === &quot;object&quot;</code>。引用值是保存在内存中的对象。在操作对象时，实际上操作的是对该对象的<strong>引用（reference）</strong>而非 实际的对象本身。<ul>
<li>原始值包装对象</li>
<li>普通对象-Object</li>
<li>数组对象-Array</li>
<li>正则对象-RegExp</li>
<li>日期对象-Date</li>
<li>数学函数-Math</li>
<li>函数对象-Function</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>原始值和引用值的区别是：</strong></p>
<ul>
<li><p>动态属性：原始值没有属性，引用值可以设置属性。</p>
</li>
<li><p>复制值：原始值存放于栈内存，而引用值在栈内存存一个“指针”，该指针指向堆内存空间，实际数据存放在堆内存。</p>
</li>
</ul>
<h1 id="原始值变量"><a href="#原始值变量" class="headerlink" title="原始值变量"></a>原始值变量</h1><p><strong>原始类型</strong>（基本数值、基本数据类型）为<code>primitive values</code>，是一种既非<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9PYmplY3Q=">对象</span>也无<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9NZXRob2Q=">方法</span>的数据。此处的非对象和无方法很重要。在 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9KYXZhU2NyaXB0">JavaScript</span> 中，共有7种基本类型：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TdHJpbmc=">string</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdW1iZXI=">number</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9CaWdJbnQ=">bigint</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Cb29sZWFu">boolean</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdWxs">null</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS91bmRlZmluZWQ=">undefined</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TeW1ib2w=">symbol</span> (<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9FQ01BU2NyaXB0">ECMAScript</span> 2016新增)。</p>
<p>多数情况下，基本类型直接代表了最底层的语言实现。</p>
<p>所有基本类型的值都是<strong>不可改变</strong>的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p>
<blockquote>
<p>那么原始数据类型的“不可改变”是什么意思？举个栗子</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字符串方法不会改变一个字符串</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">&quot;baz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar);               <span class="comment">// baz</span></span><br><span class="line">bar.toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(bar);               <span class="comment">// baz，没有变大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值行为可以给基本类型一个新值，而不是改变它</span></span><br><span class="line">bar = bar.toUpperCase();       <span class="comment">// BAZ</span></span><br></pre></td></tr></table></figure>

<p>例子二，说明传给函数的是形参：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个貌似可以改变基本类型值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">   num += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数，并传入基本类型值作为参数</span></span><br><span class="line">addTwo(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo);   <span class="comment">// 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你是否认为会得到<code>7</code>，而不是<code>5</code>？如果是，请看看代码是如何运行的：</p>
<ul>
<li><code>addTwo</code>函数调用时，JavaScript会检查标识符<code>foo</code>的值，从而准确无误的找到第一行实例化变量的声明语句。</li>
<li>找到以后，JavaScript将其作为参数传递给函数的形参。</li>
<li>在执行函数体内语句之前，<strong>JavaScript会将传递进来的参数（基本类型的值）复制一份</strong>，创建一个本地副本。这个副本只存在于该函数的作用域中，我们能够通过指定在函数中的标识符访问到它（<code>addTwo</code>中的<code>num</code>，<code>addTwo_v2</code>中的<code>foo</code>）。</li>
<li>接下来，函数体中的语句开始执行：<ul>
<li>第一个函数中，创建了本地<code>num</code>参数，<code>num</code>的值加2，但这个值并不是原来的<code>foo</code>的值。</li>
<li>第二个函数中，创建了本地参数<code>foo</code>，并将它的值加2，这个值不是外部foo的值。在这种情况下，外部的<code>foo</code>变量不能以<strong>任何</strong>方式被访问到。这是因为JavaScript的词法作用域（lexical scoping）所导致的变量覆盖，本地的变量<code>foo</code>覆盖了外部的变量<code>foo</code>。欲知详情，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9DbG9zdXJlcw==">闭包</span>。</li>
</ul>
</li>
<li>综上所述，函数中的任何操作都<strong>不会</strong>影响到最初的<code>foo</code>，我们操作的只不过是它的<strong>副本</strong>。</li>
</ul>
<p>这就是为什么说所有基本类型的值都是无法改变的。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h3 id="1-独一无二"><a href="#1-独一无二" class="headerlink" title="1.独一无二"></a><strong>1.独一无二</strong></h3><p>直接使用<code>Symbol()</code>创建新的<code>symbol</code>变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的<code>toString()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>();  <span class="comment">// Symbol() </span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym4 = <span class="built_in">Symbol</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;ConardLi&#x27;</span>&#125;); <span class="comment">// Symbol([object Object])</span></span><br><span class="line"><span class="built_in">console</span>.log(sym2 === sym3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们用两个相同的字符串创建两个<code>Symbol</code>变量，它们是不相等的，可见每个<code>Symbol</code>变量都是独一无二的。</p>
<p>如果我们想创造两个相等的<code>Symbol</code>变量，可以使用<code>Symbol.for(key)</code>。</p>
<blockquote>
<p>使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-原始类型"><a href="#2-原始类型" class="headerlink" title="2.原始类型"></a><strong>2.原始类型</strong></h3><p>注意是使用<code>Symbol()</code>函数创建<code>symbol</code>变量，并非使用构造函数，使用<code>new</code>操作符会直接报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>typeof</code>运算符判断一个<code>Symbol</code>类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>) === <span class="string">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-不可枚举"><a href="#3-不可枚举" class="headerlink" title="3.不可枚举"></a><strong>3.不可枚举</strong></h3><p>当使用<code>Symbol</code>作为对象属性时，可以保证对象不会出现重名属性，调用<code>for...in</code>不能将其枚举出来，另外调用<code>Object.getOwnPropertyNames、Object.keys()</code>也不能获取<code>Symbol</code>属性。</p>
<blockquote>
<p>可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name:&#x27;ConardLi&#x27;,</span><br><span class="line">  [Symbol(&#x27;name2&#x27;)]:&#x27;code秘密花园&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Object.getOwnPropertyNames(obj); // [&quot;name&quot;]</span><br><span class="line">Object.keys(obj); // [&quot;name&quot;]</span><br><span class="line">for (var i in obj) &#123;</span><br><span class="line">   console.log(i); // name</span><br><span class="line">&#125;</span><br><span class="line">Object.getOwnPropertySymbols(obj) // [Symbol(name)]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="4-Symbol的应用场景"><a href="#4-Symbol的应用场景" class="headerlink" title="4.Symbol的应用场景"></a>4.Symbol的应用场景</h3><p>下面是几个<code>Symbol</code>在程序中的应用场景。</p>
<p><strong>应用一：防止XSS</strong></p>
<p>在<code>React</code>的<code>ReactElement</code>对象中，有一个<code>?typeof</code>属性，它是一个<code>Symbol</code>类型的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> REACT_ELEMENT_TYPE =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.for &amp;&amp; <span class="built_in">Symbol</span>.for(<span class="string">&#x27;react.element&#x27;</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure>

<p><code>ReactElement.isValidElement</code>函数用来判断一个React组件是否是有效的，下面是它的具体实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">&#x27;object&#x27;</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.?<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见<code>React</code>渲染时会把没有<code>?typeof</code>标识，以及规则校验不通过的组件过滤掉。</p>
<p>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// JSON</span><br><span class="line">let expectedTextButGotJSON = &#123;</span><br><span class="line">  type: &#x27;div&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    dangerouslySetInnerHTML: &#123;</span><br><span class="line">      __html: &#x27;/* put your exploit here */&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let message = &#123; text: expectedTextButGotJSON &#125;;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &#123;message.text&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>而<code>JSON</code>中不能存储<code>Symbol</code>类型的变量，这就是防止<code>XSS</code>的一种手段。</p>
<p><strong>应用二：私有属性</strong></p>
<p>借助<code>Symbol</code>类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateField = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[privateField] = <span class="string">&#x27;ConardLi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getField</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[privateField];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setField</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[privateField] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用三：防止属性污染</strong></p>
<p>在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用<code>Symbol</code>作为对象属性可以保证永远不会出现同名属性。</p>
<p>例如下面的场景，我们模拟实现一个<code>call</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">&#125;</span><br><span class="line">	context = context || <span class="built_in">window</span>;</span><br><span class="line">	<span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">	context[fn] = <span class="built_in">this</span>;</span><br><span class="line">	<span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">	<span class="keyword">delete</span> context[fn];</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要在某个对象上临时调用一个方法，又不能造成属性污染，<code>Symbol</code>是一个很好的选择。</p>
<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>ES2020为JavaScript定义了一种新的数值类型BigInt。之所以增 加这个类型，主要是为了表示64位整数。</p>
<p>BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对<code>大整数</code>执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p>
<h3 id="为什么需要BigInt"><a href="#为什么需要BigInt" class="headerlink" title="为什么需要BigInt"></a>为什么需要BigInt</h3><p>在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？</p>
<p>这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示正负(2^53-1)，任何超出此范围的整数值都可能失去精度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">999999999999999</span>);  <span class="comment">//=&gt;10000000000000000</span></span><br></pre></td></tr></table></figure>

<p>同时也会有一定的安全性问题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740992</span> === <span class="number">9007199254740993</span>;    <span class="comment">// → true 居然是true!</span></span><br></pre></td></tr></table></figure>

<h3 id="如何创建并使用BigInt"><a href="#如何创建并使用BigInt" class="headerlink" title="如何创建并使用BigInt"></a>如何创建并使用BigInt</h3><p>要创建BigInt，只需要在数字末尾追加n即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">9007199254740995n</span> );    <span class="comment">// → 9007199254740995n	</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">9007199254740995</span> );     <span class="comment">// → 9007199254740996</span></span><br></pre></td></tr></table></figure>

<p>另一种创建BigInt的方法是用BigInt()构造函数、</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BigInt</span>(<span class="string">&quot;9007199254740995&quot;</span>);    <span class="comment">// → 9007199254740995n</span></span><br></pre></td></tr></table></figure>

<p>简单使用如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10n</span> + <span class="number">20n</span>;    <span class="comment">// → 30n	</span></span><br><span class="line"><span class="number">10n</span> - <span class="number">20n</span>;    <span class="comment">// → -10n	</span></span><br><span class="line">+<span class="number">10n</span>;         <span class="comment">// → TypeError: Cannot convert a BigInt value to a number	</span></span><br><span class="line">-<span class="number">10n</span>;         <span class="comment">// → -10n	</span></span><br><span class="line"><span class="number">10n</span> * <span class="number">20n</span>;    <span class="comment">// → 200n	</span></span><br><span class="line"><span class="number">20n</span> / <span class="number">10n</span>;    <span class="comment">// → 2n	</span></span><br><span class="line"><span class="number">23n</span> % <span class="number">10n</span>;    <span class="comment">// → 3n	</span></span><br><span class="line"><span class="number">10n</span> ** <span class="number">3n</span>;    <span class="comment">// → 1000n	</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10n</span>;	</span><br><span class="line">++x;          <span class="comment">// → 11n	</span></span><br><span class="line">--x;          <span class="comment">// → 9n</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);   <span class="comment">//&quot;bigint&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="值得警惕的点"><a href="#值得警惕的点" class="headerlink" title="值得警惕的点"></a>值得警惕的点</h3><ol>
<li>BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。</li>
<li>因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">10n</span>;    <span class="comment">// → TypeError</span></span><br></pre></td></tr></table></figure>

<ol>
<li>不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">2n</span>, <span class="number">4n</span>, <span class="number">6n</span>);    <span class="comment">// → TypeError</span></span><br></pre></td></tr></table></figure>

<ol>
<li>当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0n</span>)&#123;<span class="comment">//条件判断为false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">3n</span>)&#123;<span class="comment">//条件为true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>元素都为BigInt的数组可以进行sort。</li>
<li>BigInt可以正常地进行位运算，如|、&amp;、&lt;&lt;、&gt;&gt;和^</li>
</ol>
<h2 id="typeof-方法"><a href="#typeof-方法" class="headerlink" title="typeof 方法"></a>typeof 方法</h2><p><code>typeof</code>用来<strong>检测原始值</strong>类型的变量，不适合用于检测引用值变量。</p>
<p>下表总结了 <code>typeof</code> 可能的返回值。有关类型和原始值的更多信息，可查看 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9EYXRhX3N0cnVjdHVyZXM=">JavaScript 数据结构</span> 页面。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS91bmRlZmluZWQ=">Undefined</span></td>
<td align="left"><code>&quot;undefined&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Cb29sZWFu">Boolean</span></td>
<td align="left"><code>&quot;boolean&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdW1iZXI=">Number</span></td>
<td align="left"><code>&quot;number&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TdHJpbmc=">String</span></td>
<td align="left"><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TeW1ib2w=">Symbol</span> (ECMAScript 2015 新增)</td>
<td align="left"><code>&quot;symbol&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9CaWdJbnQ=">BigInt</span>(ECMAScript 2020 新增)</td>
<td align="left"><code>&quot;bigint&quot;</code></td>
</tr>
<tr>
<td align="left">⭐<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9GdW5jdGlvbg==">Function</span> 对象 (按照 ECMA-262 规范实现 [[Call]])</td>
<td align="left"><code>&quot;function&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdWxs">⭐Null</span></td>
<td align="left"><code>&quot;object&quot;</code> (见<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3R5cGVvZiNudWxs">下文</span>)</td>
</tr>
<tr>
<td align="left">宿主对象（由 JS 环境提供）</td>
<td align="left"><em>取决于具体实现</em></td>
</tr>
<tr>
<td align="left">其他任何对象</td>
<td align="left"><code>&quot;object&quot;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>Function是怎么回事？</p>
</blockquote>
<p>关于Function：严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。</p>
<blockquote>
<p>为什么typeof 判断 null  结果是返回object呢？</p>
</blockquote>
<p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code>。</p>
<p>下面是typeof的一些例子与结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">37</span> === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span> === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span>(<span class="number">42</span>) === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.LN2 === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// 尽管它是 &quot;Not-A-Number&quot; (非数值) 的缩写</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="number">1</span>) === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// Number 会尝试把参数解析成数值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span> === <span class="string">&#x27;bigint&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;&#x27;</span> === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;bla&#x27;</span> === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">`template literal`</span> === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// 注意内容为数字的字符串仍是字符串</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="keyword">typeof</span> <span class="number">1</span>) === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// typeof 总是返回一个字符串</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="number">1</span>) === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// String 将任意值转换为字符串，比 toString 更安全</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">&#x27;boolean&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> === <span class="string">&#x27;boolean&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="number">1</span>) === <span class="string">&#x27;boolean&#x27;</span>; <span class="comment">// Boolean() 会基于参数是真值还是虚值进行转换</span></span><br><span class="line"><span class="keyword">typeof</span> !!(<span class="number">1</span>) === <span class="string">&#x27;boolean&#x27;</span>; <span class="comment">// 两次调用 ! (逻辑非) 操作符相当于 Boolean()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbols</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> declaredButUndefinedVariable === <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> undeclaredVariable === <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Array.isArray 或者 Object.prototype.toString.call</span></span><br><span class="line"><span class="comment">// 区分数组和普通对象</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> /regex/ === <span class="string">&#x27;object&#x27;</span>; <span class="comment">// 历史结果请参阅正则表达式部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⭐此区域例子与下面区域代码区分开，没用到new，说明是基本数据类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="string">&#x27;boolean&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="number">1</span>) === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>) === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⭐下面的例子令人迷惑，非常危险，没有用处。避免使用它们，详情请看引用对象中的“基本数据包装对象”</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>) === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>) === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125; === <span class="string">&#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.sin === <span class="string">&#x27;function&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h1 id="引用值变量"><a href="#引用值变量" class="headerlink" title="引用值变量"></a>引用值变量</h1><p>JavaScript中除了基本数据类型外，基本全是引用对象（大多数基本数据类型也有对应的“包装对象”）。</p>
<p>引用值类型大致可以分为基本引用类型和集合引用类型。</p>
<p><strong>基本引用类型</strong>：</p>
<ul>
<li>Date </li>
<li>DegExp</li>
<li>原始值包装类型</li>
<li>单例内置对象：Global和Math</li>
</ul>
<p><strong>集合引用类型</strong>：</p>
<ul>
<li>Object</li>
<li>Array与定型数组</li>
<li>Map、WeakMap、Set、WeakSet类型</li>
<li>……</li>
</ul>
<p>查看更多的内置对象可以点击：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHM=">标准内置对象</span></p>
<h2 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h2><h3 id="原始值包装对象-使用-new-关键字"><a href="#原始值包装对象-使用-new-关键字" class="headerlink" title="原始值包装对象(使用 new 关键字)"></a>原始值包装对象(使用 new 关键字)</h3><p>除了 <code>null</code> 和 <code>undefined</code>之外，所有基本类型都有其对应的包装对象：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a> 为字符串基本类型。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a> 为数值基本类型。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a> 为大整数基本类型。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a> 为布尔基本类型。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a> 为字面量基本类型。</li>
</ul>
<p>这个包裹对象的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>valueOf()</code></a>方法返回基本类型值。</p>
<blockquote>
<p>为什么要有这个包装对象?</p>
<p>我们知道基本数据类型是非对象、无方法且不可改变的，为了保持这个特性</p>
</blockquote>
<p>从基本数据类型那个例子可以看到，当使用了new关键字给变量辅助的时候，会用到这个包装对象</p>
<p>我们来通过下面这个String包装类的例子，学习包装对象的使用，其他包装类型大同小异</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>); </span><br></pre></td></tr></table></figure>

<p>在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在 s1 上调用了 substring() 方法，并把结果保存在 s2 中。我们知道，<strong>原始值本身不是对象，因此逻辑上不应该有方法</strong>。而实际上 这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当 第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串 值的任何时候，后台都会执行以下 3 步：</p>
<p> (1) 创建一个 String 类型的实例； </p>
<p> (2) 调用实例上的特定方法；</p>
<p> (3) 销毁实例。 可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">s1 = <span class="literal">null</span>; <span class="comment">//这个新String就会被垃圾回收</span></span><br></pre></td></tr></table></figure>

<p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过 使用的是 Boolean 和 Number 包装类型而已。</p>
<p> 引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到 的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期 间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>; </span><br><span class="line">s1.color = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(s1.color); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure>

<p>这里的第二行代码尝试给字符串 s1 添加了一个 color 属性。可是，第三行代码访问 color 属性时， 它却不见了。原因就是第二行代码运行时会临时创建一个 String 对象，而当第三行代码执行时，这个对 象已经被销毁了。实际上，第三行代码在这里创建了自己的 String 对象，但这个对象没有 color 属性。</p>
<p>另外当要创建某个包装对象时候，可以通过new Object来创建不同的包装对象，Object 构造函数作为一个工厂方法，能够<u>根据传入值的类型返回相应原始值包装类型的实例</u>。比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&quot;some text&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>以下是自己对String对象的一些总结</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112181716670.png" alt="image-20211218171640622"></p>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112181715986.png" alt="image-20211218171526934"></p>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112181715594.png" alt="image-20211218171556542"></p>
<h2 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>大多数引用值的示例使用的是 Object 类型。</p>
<p>具体有什么方法可以参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0">Object</span></p>
<h4 id="创建Object实例形式"><a href="#创建Object实例形式" class="headerlink" title="创建Object实例形式"></a>创建Object实例形式</h4><p>（1）：使用 new 操作符和 Object 构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>

<p>弊端：创建同一个类型的Object的时候，要重复编写代码</p>
<p>（2）：对象字面量（object literal）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line">	<span class="attr">age</span>: <span class="number">29</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>弊端：创建同一个类型的Object的时候，要重复编写代码</p>
<p>（3）工厂模式</p>
<p>把上面的代码封装到一个函数中，然后该函数返回新生成的对象。如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">//返回一个对象的函数===&gt;工厂函数</span></span><br><span class="line">	<span class="keyword">var</span> obj = &#123;</span><br><span class="line">		<span class="attr">name</span>: name,</span><br><span class="line">		<span class="attr">age</span>: age,</span><br><span class="line">		<span class="attr">setName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.name = name</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弊端：没有解决对象标识问题（即新创建的对象是什么类型）</p>
<p>（4）构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>至于为什么this可以指向该实例对象，可以看我的this的文章。</p>
<blockquote>
<p>其实不会说一个函数就是构造函数，啥函数就是普通函数。用了new的时候就是构造函数，不用new调用就是普通函数。</p>
<p>直接Person(“Greg”,27);//添加到了window对象</p>
<p>window.sayName()//“Greg”</p>
</blockquote>
<p>弊端：每个对象的setName方法在构造函数中事实上每一次都开辟一个新的内存空间放，但功能一样的函数，没必要占多余空间，所以可以用下一种方法。</p>
<p>（5）构造函数+原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">//在构造函数中只初始化一般函数</span></span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提一提原型的知识：</p>
<p>①每定义一个函数，就会给该函数创建一个prototype属性（指向原型对象）。</p>
<p>②该原型对象也有一个constructor属性指回该函数。</p>
<p>③每对该函数进行构造调用，新实例都有一个__proto__指向其原型对象。</p>
<h4 id="Object构造方法"><a href="#Object构造方法" class="headerlink" title="Object构造方法"></a>Object构造方法</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/Object"><code>Object()</code></a> 创建一个新<code>Object</code>对象。它是给定值的包装器。</p>
<h4 id="Obeject属性描述符"><a href="#Obeject属性描述符" class="headerlink" title="Obeject属性描述符"></a>Obeject属性描述符</h4><p>ECMA-262 使用一些<code>内部特性</code>来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。</p>
<p>开发者不能在 JavaScript 中直接访问这些特性。</p>
<p>为了将某个特性标识为<code>内部特性</code>，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]。</p>
<p><strong>属性分两种：数据属性和访问器属性。</strong></p>
<p>这些属性可以在Object.defineProperty()的时候指定。</p>
<h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><ul>
<li>[[Configurable]]：默认为true。表示<strong>是否可以删除属性（delete操作符）、修改属性、修改属性的属性描述符</strong>。</li>
<li>[[Enumerable]]：默认为true。表示<strong>是否可以使用 for/in 语句或 Object.keys() 函数遍历访问</strong>。</li>
<li>[[Writable]]：默认为true。表示属性的值是否可以被修改。</li>
<li>[[Value]]：默认为undefined。包含属性实际的值。</li>
</ul>
<h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ul>
<li>[[Configurable]]：同上</li>
<li>[[Enumerable]]：同上</li>
<li>[[Get]]：获取函数，在读取属性时调用。默认值为 undefined。</li>
<li>[[Set]]：设置函数，在写入属性时调用。默认值为 undefined。</li>
</ul>
<h4 id="Object静态方法"><a href="#Object静态方法" class="headerlink" title="Object静态方法"></a>Object静态方法</h4><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><h6 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h6><blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign(target, ...sources)</code></a> ：通过复制一个或多个对象来创建一个新的对象。</p>
</blockquote>
<p>这个方法接收一个目标对象和一个或多个源对象作为参数，将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true） 和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。</p>
<ul>
<li>对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标 对象上的[[Set]]设置属性的值。</li>
<li>实际上对每个源对象执行的是<strong>浅复制</strong>。如果多个源对象都有相同的属性，则使用最后一个复制的值。</li>
<li>不能在两个对象间转移get函数和set函数。即从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。</li>
<li>如果赋值期间出错，则操作会中止并退出，不会<strong>回滚</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest = &#123;&#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123;<span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span>&#125;, &#123;<span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; a: foo, b: bar &#125;</span></span><br></pre></td></tr></table></figure>

<p>下面用一个例子看看第三点是什么意思</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dest = &#123; </span><br><span class="line">     <span class="keyword">set</span> <span class="title">a</span>(<span class="params">val</span>) &#123; </span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;; </span><br><span class="line">src = &#123; </span><br><span class="line">     <span class="keyword">get</span> <span class="title">a</span>() &#123; </span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;Invoked src getter&#x27;</span>); </span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src); </span><br><span class="line"><span class="comment">// 调用 src 的获取方法，打印“Invoked src getter”</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数&quot;foo&quot; 。打印“Invoked dest setter with param foo”</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; set a(val) &#123;...&#125; &#125; </span></span><br></pre></td></tr></table></figure>

<p>打印dest中发现，因为这里的设置函数不执行赋值操作，所以实际上并没有把值转移过来</p>
<p>再看看浅复制的意思：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dest = &#123;&#125;; </span><br><span class="line">src = &#123; <span class="attr">a</span>: &#123;&#125; &#125;; </span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src); </span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; a :&#123;&#125; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(dest.a === src.a); <span class="comment">// true </span></span><br></pre></td></tr></table></figure>



<h6 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create(proto [, propertiesObject])</code></a>：使用指定的原型对象和属性创建一个新对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">isHuman</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">printIntroduction</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="built_in">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(me)===person)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">me.name = <span class="string">&#x27;Matthew&#x27;</span>; <span class="comment">// &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; <span class="comment">// inherited properties can be overwritten</span></span><br><span class="line"></span><br><span class="line">me.printIntroduction();<span class="comment">//&quot;My name is Matthew. Am I human? true&quot;	</span></span><br></pre></td></tr></table></figure>

<p>可以实现原型链继承。</p>
<p>手撕代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = proto;</span><br><span class="line">    F.prototype.constructor = F;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h5><h6 id="Obejct-getPrototypeOf"><a href="#Obejct-getPrototypeOf" class="headerlink" title="Obejct.getPrototypeOf()"></a>Obejct.getPrototypeOf()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf(obj)</code></a> ： 返回某个对象的原型对象</li>
</ul>
<h6 id="Pbject-setPrototypeOf"><a href="#Pbject-setPrototypeOf" class="headerlink" title="Pbject.setPrototypeOf()"></a>Pbject.setPrototypeOf()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf(obj, prototype)</code></a> ： 更改某个对象的原型</li>
</ul>
<p>这个方法不建议用，因为会影响非常多的东西，可以通过 Object.create()来创 建一个新对象，同时为其指定原型。</p>
<h5 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h5><h6 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor"><code>Object.getOwnPropertyDescriptor(obj, prop)</code></a> ：取得指定属性的属性描述符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&#x27;year_&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">year_</span>: &#123;</span><br><span class="line">		<span class="attr">value</span>: <span class="number">2017</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// 2017 </span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>



<h6 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors"><code>Object.getOwnPropertyDescriptors(obj)</code></a> ：获取多个属性的属性描述符</li>
</ul>
<h6 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty(obj, prop, descriptor)</code></a>：为一个对象，定义一个新属性，且可加对应的属性描述符。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">	<span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">//没法删除，且没法通过defineProperty方法定相同属性</span></span><br><span class="line">	<span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值”Nicholas”。这个属性的值就 不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性 的值会抛出错误。</p>
<h6 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties"><code>Object.defineProperties(obj, props)</code></a> ：定义多个属性，用法和上面一样</li>
</ul>
<h5 id="获取对象属性"><a href="#获取对象属性" class="headerlink" title="获取对象属性"></a>获取对象属性</h5><h6 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys(obj)</code></a> ：获得对象上所有<strong>可遍历（[[Enumerable]]为true）</strong>的<strong>实例属性</strong>，</li>
</ul>
<p>注意两点：</p>
<ul>
<li>可枚举，即[Enumerable]]特性被设置为 true</li>
<li>实例属性，即<strong>原型上的属性都不算</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// &quot;name,age,job,sayName&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">&quot;Rob&quot;</span>;</span><br><span class="line">p1.age = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">let</span> p1keys = <span class="built_in">Object</span>.keys(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1keys); <span class="comment">// &quot;[name,age]&quot;</span></span><br></pre></td></tr></table></figure>



<h6 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h6><blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values"><code>Object.values(obj)</code></a> : 返回对象的<strong>可遍历（[[Enumerable]]为true）</strong>的属性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">	<span class="attr">baz</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">qux</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 1, &#123;&#125;] </span></span><br></pre></td></tr></table></figure>

<p>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">	<span class="attr">qux</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)[<span class="number">0</span>] === o.qux);</span><br><span class="line"><span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<p>Symbol属性会被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> o = &#123; </span><br><span class="line"> [sym]: <span class="string">&#x27;foo&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)); </span><br><span class="line"><span class="comment">// [] </span></span><br></pre></td></tr></table></figure>



<h6 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h6><blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries(Object.entries())</code></a> : 以key/value形式返回<strong>可遍历（[[Enumerable]]为true）</strong>的属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">	<span class="attr">baz</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">qux</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o)));</span><br><span class="line"><span class="comment">// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]]</span></span><br></pre></td></tr></table></figure>

<p>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">	<span class="attr">qux</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(o)[<span class="number">0</span>][<span class="number">1</span>] === o.qux);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Symbol属性会被忽略：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> o = &#123; </span><br><span class="line"> [sym]: <span class="string">&#x27;foo&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o))); </span><br><span class="line"><span class="comment">// [] </span></span><br></pre></td></tr></table></figure>





<h6 id="Obejct-getOwnPropertyNames"><a href="#Obejct-getOwnPropertyNames" class="headerlink" title="Obejct.getOwnPropertyNames()"></a>Obejct.getOwnPropertyNames()</h6><blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames"><code>Object.getOwnPropertyNames(obj)</code></a> ：和Object.keys()不同，获取所有实例属性，不管是否可以枚举。</p>
</blockquote>
<p>注意这个方法不会拿到Symbol的属性。</p>
<h6 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code>Object.getOwnPropertySymbols(obj)</code></a> ：针对Symbol的属性，遍历用Symbol定义的属性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">	k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	[k1]: <span class="string">&#x27;k1&#x27;</span>,</span><br><span class="line">	[k2]: <span class="string">&#x27;k2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));<span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));<span class="comment">//[]</span></span><br></pre></td></tr></table></figure>



<h5 id="对象属性的冻结"><a href="#对象属性的冻结" class="headerlink" title="对象属性的冻结"></a>对象属性的冻结</h5><h6 id="Object-preventExtensions-和Object-isExtensbile"><a href="#Object-preventExtensions-和Object-isExtensbile" class="headerlink" title="Object.preventExtensions()和Object.isExtensbile()"></a>Object.preventExtensions()和Object.isExtensbile()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions"><code>Object.preventExtensions()</code></a>方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible"><code>Object.isExtensible()</code></a>：判断对象是否可扩展。</li>
</ul>
<h6 id="Object-seal-和Object-isSealed"><a href="#Object-seal-和Object-isSealed" class="headerlink" title="Object.seal()和Object.isSealed()"></a>Object.seal()和Object.isSealed()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal"><code>Object.seal()</code></a>：防止其他代码删除对象的属性。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed"><code>Object.isSealed()</code></a>：判断对象是否已经密封。</li>
</ul>
<h6 id="Object-freeze-和Obejct-isFrozen"><a href="#Object-freeze-和Obejct-isFrozen" class="headerlink" title="Object.freeze()和Obejct.isFrozen()"></a>Object.freeze()和Obejct.isFrozen()</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><code>Object.freeze()</code></a> : 冻结对象。其他代码无法删除或更改其属性。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen"><code>Object.isFrozen()</code></a>：判断对象是否为冻结。</li>
</ul>
<h6 id="区别与对比"><a href="#区别与对比" class="headerlink" title="区别与对比"></a>区别与对比</h6><blockquote>
<p>Object.preventExtension、Object.seal、Object.freeze的区别：</p>
</blockquote>
<p><code>Object.preventExtension</code>：禁止对象添加新属性并保留已有属性;</p>
<p><code>Object.seal</code>：在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false;</p>
<p><code>Object.freeze</code>：在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false。</p>
<h5 id="相等性判断"><a href="#相等性判断" class="headerlink" title="相等性判断"></a>相等性判断</h5><h6 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h6><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is()</code></a> ： 判断两个值是否相等</li>
</ul>
<p>源码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="comment">//运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的</span></span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理</span></span><br><span class="line">    <span class="comment">//两个都是NaN的时候返回true</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>==\、===、Object.is（）有什么不同？ </p>
</blockquote>
<p>①等运算符 (===) 会检查它的两个操作数是否相等，并且返回一个布尔值结果。与相等运算符不同，全等运算符总是认为不同类型的操作数是不同的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> === <span class="number">1</span>);</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span> === <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> ===  <span class="number">1</span>);</span><br><span class="line"><span class="comment">// expected output: false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> === <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// expected output: false</span></span><br></pre></td></tr></table></figure>

<p>②Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。</p>
<p> === 运算符 (也包括 == 运算符) 将数字 -0 和 +0 视为相等 ，而将Number.NaN 与NaN视为不相等。</p>
<h4 id="Object-prototype的属性"><a href="#Object-prototype的属性" class="headerlink" title="Object.prototype的属性"></a>Object.prototype的属性</h4><ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a> ：指定创建对象原型的函数。</li>
</ol>
<p>constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.constructor === F;<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">F.prototype = &#123;</span><br><span class="line">	<span class="attr">_name</span>: <span class="string">&#x27;Eric&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.constructor === F; <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">F.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: F, </span><br><span class="line">   <span class="attr">_name</span>: <span class="string">&#x27;Eric&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.constructor === F; <span class="comment">// true </span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a> ：指向在实例化对象时用作原型的对象。</li>
</ol>
<h4 id="Object-prototype的方法"><a href="#Object-prototype的方法" class="headerlink" title="Object.prototype的方法"></a>Object.prototype的方法</h4><ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty(prop)</code></a> ： 某个属性在实例上则返回真，在原型上的也不算，毕竟是own</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> example = &#123;&#125;;</span><br><span class="line">example.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">example.prop = <span class="string">&#x27;exists&#x27;</span>;</span><br><span class="line">example.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// true - &#x27;prop&#x27; has been defined</span></span><br><span class="line"></span><br><span class="line">example.prop = <span class="literal">null</span>;</span><br><span class="line">example.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// true - own property exists with value of null</span></span><br><span class="line"></span><br><span class="line">example.prop = <span class="literal">undefined</span>;</span><br><span class="line">example.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// true - own property exists with value of undefined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里和in操作符区分一下</p>
<p>in：只要能通过对象访问到就行，无论是自己的属性还是原型上的属性</p>
<p>hasOwnProperty：只有自己的属性才为真</p>
</blockquote>
<ol start="2">
<li>Object.prototype.toString（）</li>
</ol>
<p>toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object,xxx],xxx是具体的数据类型，其中包括：String,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument,… 基本上所有对象的类型都可以通过这个方法获取到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object Window]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，必须通过Object.prototype.toString.call来获取，而不能直接 new Date().toString(), 从原型链的角度讲，所有对象的原型链最终都指向了Object, 按照JS变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用call来强制执行Object的toString方法。</p>
<h4 id="属性枚举以及顺序"><a href="#属性枚举以及顺序" class="headerlink" title="属性枚举以及顺序"></a>属性枚举以及顺序</h4><p>枚举一个Object对象属性的方法有如下几种：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">可枚举实例属性</th>
<th align="center">不可枚举实例属性</th>
<th align="center">Symbol属性（包括实例属性、原型属性）</th>
<th align="center">可枚举原型属性</th>
<th align="center">不可枚举原型属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">for-in</td>
<td align="center">✔</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✔</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">Object.keys()</td>
<td align="center">✔</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">Object.values()</td>
<td align="center">同上</td>
<td align="center">同上</td>
<td align="center">同上</td>
<td align="center">同上</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Object.entries()</td>
<td align="center">同上</td>
<td align="center">同上</td>
<td align="center">同上</td>
<td align="center">同上</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertyNames()</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">Object.getOwnPropertySymbols()</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✔</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>Symbol属性只有<code>Object.getOwnPropertySymbols()</code>能获取。</li>
<li>for-in：返回<strong>可枚举</strong>的<strong>所有</strong>属性。</li>
<li>Object.keys()、Object.values()、Object.entries()：返回<strong>可枚举</strong>的<strong>实例</strong>属性。</li>
<li>Object.getOwnPropertyNames()：返回所有<strong>实例</strong>属性。</li>
</ul>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> o = &#123; </span><br><span class="line"> [sym]: <span class="string">&#x27;foo&#x27;</span>,<span class="comment">// symbol属性</span></span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,<span class="comment">// 普通实例属性</span></span><br><span class="line">  <span class="attr">b</span>:<span class="string">&quot;b&quot;</span><span class="comment">// 不可枚举实例属性</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;b&quot;</span>,&#123;<span class="attr">enumerable</span>:<span class="literal">false</span>&#125;); <span class="comment">// 令o.b为不可枚举</span></span><br><span class="line"></span><br><span class="line">o.__proto__.testa=<span class="string">&quot;testa&quot;</span>;<span class="comment">// 原型属性</span></span><br><span class="line">o.__proto__.testb=<span class="string">&quot;testb&quot;</span>;<span class="comment">// 原型属性</span></span><br><span class="line">o.__proto__[sym]=<span class="string">&quot;testc&quot;</span>;<span class="comment">// 原型属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o.__proto__,<span class="string">&quot;testb&quot;</span>,&#123;<span class="attr">enumerable</span>:<span class="literal">false</span>&#125;); <span class="comment">// 令o.__proto__.testb为不可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ①：for-in</span></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> o)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果如下：</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">// &quot;testa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ②：Object.keys()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(o));</span><br><span class="line"><span class="comment">// 结果如下：</span></span><br><span class="line"><span class="comment">// [&#x27;a&#x27;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ③：Object.entries()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o))); </span><br><span class="line"><span class="comment">// 结果如下：</span></span><br><span class="line"><span class="comment">// [ [&quot;a&quot;, 1] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ④：Object.getOwnPropertyNames()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames((o))); </span><br><span class="line"><span class="comment">// 结果如下：</span></span><br><span class="line"><span class="comment">// Array [&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⑤：ObjectgetOwnPropertySymbols()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o))</span><br><span class="line"><span class="comment">// 结果如下：</span></span><br><span class="line"><span class="comment">// [Symbol()]</span></span><br></pre></td></tr></table></figure>



<p>以上的方式的枚举顺序是不确定的：</p>
<ul>
<li>for-in 循环和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。</li>
<li>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign() 的枚举顺序是确定性的。<ul>
<li>先以<strong>升序</strong>枚举“数值”的key</li>
<li>然后以<strong>插入顺序</strong>枚举“字符串、Symbol”的key。</li>
<li>在对象字面量中定义的键以它们逗号分隔的顺序插入。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">	k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	<span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">first</span>: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">	[k1]: <span class="string">&#x27;sym2&#x27;</span>,</span><br><span class="line">	<span class="attr">second</span>: <span class="string">&#x27;second&#x27;</span>,</span><br><span class="line">	<span class="number">0</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">o[k2] = <span class="string">&#x27;sym2&#x27;</span>;</span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">o.third = <span class="string">&#x27;third&#x27;</span>;</span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;] </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure>





<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXk=">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</span></p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112181715499.png" alt="image-20211218171503420"></p>
<p>最常见的例如数组的方法Map、Reduce、Filter，这些都是高阶函数（即参数为一个函数）。</p>
<img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202201130220986.png" alt="image-20220113022024743" style="zoom: 50%;" />



<h3 id="Map和WeakMap"><a href="#Map和WeakMap" class="headerlink" title="Map和WeakMap"></a>Map和WeakMap</h3><p>这两者的区别先概括一下：</p>
<ul>
<li>Map<ul>
<li>本质上是键值对的集合，类似集合</li>
<li>可以遍历，方法很多可以跟各种数据格式转换</li>
</ul>
</li>
<li>WeakMap<ul>
<li>只接受对象作为键名（null除外），不接受其他类型的值作为键名</li>
<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li>
<li>不能遍历，方法有get、set、has、delete</li>
</ul>
</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote>
<p>创建Map实例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;An&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;des&#x27;</span>, <span class="string">&#x27;JS&#x27;</span>]</span><br><span class="line">])</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Map实例属性</p>
</blockquote>
<ul>
<li>constructor：构造函数</li>
<li>size：返回字典中所包含的元素个数</li>
</ul>
<blockquote>
<p>Map操作方法</p>
</blockquote>
<ol>
<li>操作方法：<ul>
<li>set(key, value)：向字典中添加新元素</li>
<li>get(key)：通过键查找特定的数值并返回</li>
<li>has(key)：判断字典中是否存在键key</li>
<li>delete(key)：通过键 key 从字典中移除对应的数据</li>
<li>clear()：将这个字典中的所有元素删除</li>
</ul>
</li>
<li>遍历方法：<ul>
<li>Keys()：将字典中包含的所有键名以迭代器形式返回</li>
<li>values()：将字典中包含的所有数值以迭代器形式返回</li>
<li>entries()：返回所有成员的迭代器</li>
<li>forEach()：遍历字典的所有成员</li>
</ul>
</li>
</ol>
<blockquote>
<p>与其他数据结构互相转换</p>
</blockquote>
<ol>
<li><p>Map 转 Array</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="built_in">console</span>.log([...map])	<span class="comment">// [[1, 1], [2, 2], [3, 3]]</span></span><br></pre></td></tr></table></figure></li>
<li><p>Array 转 Map</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(map)	<span class="comment">// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Map 转 Object</p>
<p>因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToObj</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">        obj[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;An&#x27;</span>).set(<span class="string">&#x27;des&#x27;</span>, <span class="string">&#x27;JS&#x27;</span>)</span><br><span class="line">mapToObj(map)  <span class="comment">// &#123;name: &quot;An&quot;, des: &quot;JS&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Object 转 Map</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">        map.set(key, obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToMap(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;An&#x27;</span>, <span class="string">&#x27;des&#x27;</span>: <span class="string">&#x27;JS&#x27;</span>&#125;) <span class="comment">// Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Map 转 JSON</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;An&#x27;</span>).set(<span class="string">&#x27;des&#x27;</span>, <span class="string">&#x27;JS&#x27;</span>)</span><br><span class="line">mapToJson(map)	<span class="comment">// [[&quot;name&quot;,&quot;An&quot;],[&quot;des&quot;,&quot;JS&quot;]]</span></span><br></pre></td></tr></table></figure></li>
<li><p>JSON 转 Map</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objToMap(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(<span class="string">&#x27;&#123;&quot;name&quot;: &quot;An&quot;, &quot;des&quot;: &quot;JS&quot;&#125;&#x27;</span>) <span class="comment">// Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap 对象是一组键值对的集合，其中的<strong>key是弱引用对象，而value可以是任意</strong>。</p>
<p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p>
<p>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。</p>
<p>属性：</p>
<ul>
<li>constructor：构造函数</li>
</ul>
<p>方法：</p>
<ul>
<li>has(key)：判断是否有 key 关联对象</li>
<li>get(key)：返回key关联对象（没有则则返回 undefined）</li>
<li>set(key)：设置一组key关联对象</li>
<li>delete(key)：移除 key 的关联对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;logo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>







<h3 id="Set和WeakSet"><a href="#Set和WeakSet" class="headerlink" title="Set和WeakSet"></a>Set和WeakSet</h3><p>这两个的区别先概括一下：</p>
<ul>
<li>Set<ul>
<li>成员唯一、无序且不重复</li>
<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li>
<li>可以遍历，方法有：add、delete、has</li>
</ul>
</li>
<li>WeakSet<ul>
<li>成员都是对象</li>
<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</li>
<li>不能遍历，方法有add、delete、has</li>
</ul>
</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><blockquote>
<p>创建Set</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Set实例属性</p>
</blockquote>
<ul>
<li>constructor： 构造函数</li>
<li>size：元素数量</li>
</ul>
<blockquote>
<p>Set 实例方法</p>
</blockquote>
<ol>
<li>操作方法<ul>
<li>add(value)：新增，相当于 array里的push</li>
<li>delete(value)：存在即删除集合中value</li>
<li>has(value)：判断集合中是否存在 value</li>
<li>clear()：清空集合</li>
</ul>
</li>
<li>遍历方法（遍历顺序为插入顺序）<ul>
<li>keys()：返回一个包含集合中所有键的迭代器</li>
<li>values()：返回一个包含集合中所有值得迭代器</li>
<li>entries()：返回一个包含Set对象中所有元素得键值对迭代器</li>
<li>forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，<strong>没有返回值</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>转为数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(arr)]<span class="comment">//这样子还能去重</span></span><br></pre></td></tr></table></figure>



<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>WeakSet 与 Set 的主要区别：</p>
<ul>
<li>WeakSet <strong>只能储存对象引用</strong>，不能存放值，而 Set 对象都可以</li>
<li>WeakSet 对象中储存的<strong>对象值都是被弱引用</strong>的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中）。</li>
</ul>
<blockquote>
<p>创建WeakSet</p>
</blockquote>
<p>创建一个WeakSet的时候可以传入一个数组，但是是将数组的成员传入ws中，因此该数组的成员必须是引用类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(b);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure>

<p>WeakSet 结构有以下三个方法。</p>
<ul>
<li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li>
<li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li>
<li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>没有size属性，也没法用forEach遍历。</p>
<h2 id="instanceof方法判断引用类型"><a href="#instanceof方法判断引用类型" class="headerlink" title="instanceof方法判断引用类型"></a>instanceof方法判断引用类型</h2><p>在原始类型的介绍当中，我们可以看到，typeof只能去确定基本数据类型的数据，而对于所有引用对象返回的都是object，此时就需要一个新的方法instanceof来判断对象类型</p>
<p>当我们需要知道某个对象的具体类型时,可以用运算符 instanceof，instanceof操作符判断左操作数对象的原型链上是否有右边这个构造函数的prototype属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。 检测的我们用一段伪代码来模拟instanceof内部执行过程：</p>
<blockquote>
<p>A instanceof B  为true === “B的原型”在 “A的原型链”上</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//基本数据类型直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//查找到尽头，还没找到</span></span><br><span class="line">        <span class="keyword">if</span>(proto == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//找到相同的原型对象</span></span><br><span class="line">        <span class="keyword">if</span>(proto == right.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述过程可以看出，当 A 的 <strong>proto</strong> 指向 B 的 prototype 时，就认为A就是B的实例，我们再来看几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？ 我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出 [].<strong>proto</strong> 指向 Array.prototype， 而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，Object.prototype.<strong>proto</strong> 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210908001635092.png" alt="image-20210908001635092"></p>
<p>从原型链可以看出，[] 的 <strong>proto</strong>  直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。</p>
<p>注意:instanceof运算符只能用于对象，不适用原始类型的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>字符串、null和undefined不是对象，所以返回false。</p>
<h1 id="基本数据类型和引用对象类型存储原理"><a href="#基本数据类型和引用对象类型存储原理" class="headerlink" title="基本数据类型和引用对象类型存储原理"></a>基本数据类型和引用对象类型存储原理</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str += <span class="string">&#x27;6&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi6</span></span><br></pre></td></tr></table></figure>

<p>你会发现，<code>str</code>的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：</p>
<p>在<code>JavaScript</code>中，每一个变量在内存中都需要一个空间来存储。</p>
<p>内存空间又被分为两种，栈内存与堆内存。</p>
<p>栈内存：</p>
<ul>
<li>存储的值大小固定</li>
<li>空间较小</li>
<li>可以直接操作其保存的变量，运行效率高</li>
<li>由系统自动分配存储空间</li>
</ul>
<p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/16afa4daf89c565e~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。</p>
<p>在上面的代码中，我们执行了<code>str += &#39;6&#39;</code>的操作，实际上是在栈中又开辟了一块内存空间用于存储<code>&#39;ConardLi6&#39;</code>，然后将变量<code>str</code>指向这块空间，所以这并不违背<code>不可变性的</code>特点。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/16afa4dd38de23b8~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>堆内存：</p>
<ul>
<li>存储的值大小不定，可动态调整</li>
<li>空间较大，运行效率低</li>
<li>无法直接操作其内部存储，使用引用地址读取</li>
<li>通过代码进行分配空间</li>
</ul>
<p>相对于上面具有不可变性的原始类型，我习惯把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;name:&quot;ConardLi&quot;&#125;</span><br><span class="line">var obj2 = &#123;age:18&#125;</span><br><span class="line">var obj3 = function()&#123;...&#125;</span><br><span class="line">var obj4 = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/16afa4df7faa4630~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<blockquote>
<p>由于内存是有限的，这些变量不可能一直在内存中占用资源，这里推荐下这篇文章<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODMzMzg3MTU1NDY0">JavaScript中的垃圾回收和内存泄漏</span>，这里告诉你<code>JavaScript</code>是如何进行垃圾回收以及可能会发生内存泄漏的一些场景。</p>
</blockquote>
<p>当然，引用类型就不再具有<code>不可变性</code>了，我们可以轻易的改变它们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj1.name = <span class="string">&quot;ConardLi6&quot;</span>;</span><br><span class="line">obj2.age = <span class="number">19</span>;</span><br><span class="line">obj4.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name:&quot;ConardLi6&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age:19&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// []</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以数组为例，它的很多方法都可以改变它自身。</p>
<ul>
<li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li>
<li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li>
<li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li>
<li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li>
<li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li>
<li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li>
<li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li>
</ul>
<p>下面我们通过几个操作来对比一下原始类型和引用类型的区别：</p>
<p>复制：原始数据类型是开一块新堆内存，引用对象是复制地址</p>
<p>比较：原始数据类型是直接比较值，引用对象是比较地址</p>
<h1 id="一些面试题"><a href="#一些面试题" class="headerlink" title="一些面试题"></a>一些面试题</h1><h2 id="为什么0-1-0-2-0-3"><a href="#为什么0-1-0-2-0-3" class="headerlink" title="为什么0.1+0.2!=0.3"></a>为什么0.1+0.2!=0.3</h2><blockquote>
<p>简单版本：0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>
</blockquote>
<p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202109192310285.png" alt="image-20210919231013374"></p>
<p>js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。</p>
<p>在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p>
<p>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</p>
<p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON</p>
<h2 id="结果是什么？为什么？"><a href="#结果是什么？为什么？" class="headerlink" title="[] == ![]结果是什么？为什么？"></a>[] == ![]结果是什么？为什么？</h2><p>解析:</p>
<p>== 中，左右两边都需要转换为数字然后进行比较。</p>
<p>[]转换为数字为0。</p>
<p>![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,</p>
<p>因此![]为false，进而在转换成数字，变为0。</p>
<p>0 == 0 ， 结果为true</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li>《JavaScript高级程序设计》</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODU0ODgyOTQ3MDgw">【JS 进阶】你真的掌握变量和类型了吗</span></li>
<li> <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNjIzMjMxNTM3MTU5">JS数据类型分类和判断</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zYW55dWFuMDcwNC50b3AvYmxvZ3MvamF2YXNjcmlwdC9qcy1iYXNlLzAwNy5odG1sIyVFNCVCQiU4MCVFNCVCOSU4OCVFNiU5OCVBRmJpZ2ludA==">谈谈你对BigInt的理解。</span></li>
</ul>

      <div class="tags">
          <a href="/tags/JavaScript/" rel="tag"><i class="ic i-tag"></i> JavaScript</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-02-17 16:07:25" itemprop="dateModified" datetime="2022-02-17T16:07:25+08:00">2022-02-17</time>
  </span>
  <span id="FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript中的变量类型" class="item leancloud_visitors" data-flag-title="JavaScript中的变量类型" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>Monkey-HH <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B" title="JavaScript中的变量类型">https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript中的变量类型</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202109201019726.png" title="JavaScript作用域与闭包">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> JavaScript</span>
  <h3>JavaScript作用域与闭包</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%88BOM%EF%BC%89" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202109201019726.png" title="JavaScript中的浏览器对象模型（BOM）">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> JavaScript</span>
  <h3>JavaScript中的浏览器对象模型（BOM）</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB%EF%BC%9A%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">变量分类：原始值与引用值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">原始值变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-number">3.1.</span> <span class="toc-text">Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.独一无二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.原始类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.不可枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Symbol%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.4.</span> <span class="toc-text">4.Symbol的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInt"><span class="toc-number">3.2.</span> <span class="toc-text">BigInt</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81BigInt"><span class="toc-number">3.2.1.</span> <span class="toc-text">为什么需要BigInt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8BigInt"><span class="toc-number">3.2.2.</span> <span class="toc-text">如何创建并使用BigInt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E5%BE%97%E8%AD%A6%E6%83%95%E7%9A%84%E7%82%B9"><span class="toc-number">3.2.3.</span> <span class="toc-text">值得警惕的点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">typeof 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%80%BC%E5%8F%98%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">引用值变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">基本引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1-%E4%BD%BF%E7%94%A8-new-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.1.1.</span> <span class="toc-text">原始值包装对象(使用 new 关键字)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-number">4.1.2.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">4.1.3.</span> <span class="toc-text">Math</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">集合引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object"><span class="toc-number">4.2.1.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAObject%E5%AE%9E%E4%BE%8B%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">创建Object实例形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">Object构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Obeject%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">Obeject属性描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.1.3.1.</span> <span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.1.3.2.</span> <span class="toc-text">访问器属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">Object静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.2.1.4.1.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-assign"><span class="toc-number">4.2.1.4.1.1.</span> <span class="toc-text">Object.assign()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-create"><span class="toc-number">4.2.1.4.1.2.</span> <span class="toc-text">Object.create()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.2.1.4.2.</span> <span class="toc-text">对象原型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Obejct-getPrototypeOf"><span class="toc-number">4.2.1.4.2.1.</span> <span class="toc-text">Obejct.getPrototypeOf()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Pbject-setPrototypeOf"><span class="toc-number">4.2.1.4.2.2.</span> <span class="toc-text">Pbject.setPrototypeOf()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.2.1.4.3.</span> <span class="toc-text">属性描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-getOwnPropertyDescriptor"><span class="toc-number">4.2.1.4.3.1.</span> <span class="toc-text">Object.getOwnPropertyDescriptor()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-getOwnPropertyDescriptors"><span class="toc-number">4.2.1.4.3.2.</span> <span class="toc-text">Object.getOwnPropertyDescriptors()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-defineProperty"><span class="toc-number">4.2.1.4.3.3.</span> <span class="toc-text">Object.defineProperty()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-defineProperties"><span class="toc-number">4.2.1.4.3.4.</span> <span class="toc-text">Object.defineProperties()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.1.4.4.</span> <span class="toc-text">获取对象属性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-keys"><span class="toc-number">4.2.1.4.4.1.</span> <span class="toc-text">Object.keys()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-values"><span class="toc-number">4.2.1.4.4.2.</span> <span class="toc-text">Object.values()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-entries"><span class="toc-number">4.2.1.4.4.3.</span> <span class="toc-text">Object.entries()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Obejct-getOwnPropertyNames"><span class="toc-number">4.2.1.4.4.4.</span> <span class="toc-text">Obejct.getOwnPropertyNames()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-getOwnPropertySymbols"><span class="toc-number">4.2.1.4.4.5.</span> <span class="toc-text">Object.getOwnPropertySymbols()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%BB%E7%BB%93"><span class="toc-number">4.2.1.4.5.</span> <span class="toc-text">对象属性的冻结</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-preventExtensions-%E5%92%8CObject-isExtensbile"><span class="toc-number">4.2.1.4.5.1.</span> <span class="toc-text">Object.preventExtensions()和Object.isExtensbile()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-seal-%E5%92%8CObject-isSealed"><span class="toc-number">4.2.1.4.5.2.</span> <span class="toc-text">Object.seal()和Object.isSealed()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-freeze-%E5%92%8CObejct-isFrozen"><span class="toc-number">4.2.1.4.5.3.</span> <span class="toc-text">Object.freeze()和Obejct.isFrozen()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.1.4.5.4.</span> <span class="toc-text">区别与对比</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E6%80%A7%E5%88%A4%E6%96%AD"><span class="toc-number">4.2.1.4.6.</span> <span class="toc-text">相等性判断</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Object-is"><span class="toc-number">4.2.1.4.6.1.</span> <span class="toc-text">Object.is</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.1.5.</span> <span class="toc-text">Object.prototype的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.6.</span> <span class="toc-text">Object.prototype的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%9E%9A%E4%B8%BE%E4%BB%A5%E5%8F%8A%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.2.1.7.</span> <span class="toc-text">属性枚举以及顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array"><span class="toc-number">4.2.2.</span> <span class="toc-text">Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E5%92%8CWeakMap"><span class="toc-number">4.2.3.</span> <span class="toc-text">Map和WeakMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakMap"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">WeakMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E5%92%8CWeakSet"><span class="toc-number">4.2.4.</span> <span class="toc-text">Set和WeakSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakSet"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">WeakSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">instanceof方法判断引用类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">基本数据类型和引用对象类型存储原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">一些面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2-0-3"><span class="toc-number">6.1.</span> <span class="toc-text">为什么0.1+0.2!&#x3D;0.3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">[] &#x3D;&#x3D; ![]结果是什么？为什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">7.</span> <span class="toc-text">参考链接</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/jQuery%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8" rel="bookmark" title="jQuery基础知识入门">jQuery基础知识入门</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85" rel="bookmark" title="JavaScript作用域与闭包">JavaScript作用域与闭包</a></li><li class="active"><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B" rel="bookmark" title="JavaScript中的变量类型">JavaScript中的变量类型</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%88BOM%EF%BC%89" rel="bookmark" title="JavaScript中的浏览器对象模型（BOM）">JavaScript中的浏览器对象模型（BOM）</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="bookmark" title="JavaScript原型与原型链">JavaScript原型与原型链</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6" rel="bookmark" title="JavaScript事件">JavaScript事件</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%ADDOM%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93" rel="bookmark" title="JavaScript中DOM操作总结">JavaScript中DOM操作总结</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" rel="bookmark" title="JavaScript中的前端模块化">JavaScript中的前端模块化</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" rel="bookmark" title="JavaScript执行上下文">JavaScript执行上下文</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88" rel="bookmark" title="JavaScript常用继承方案">JavaScript常用继承方案</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91JavaScript%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="bookmark" title="【手撕JavaScript系列】JavaScript中的浅拷贝和深拷贝">【手撕JavaScript系列】JavaScript中的浅拷贝和深拷贝</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/axios%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%A5%E9%97%A8" rel="bookmark" title="axios基础知识点入门">axios基础知识点入门</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91this%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E3%80%81bind%E3%80%81apply" rel="bookmark" title="【手撕JavaScript系列】this原理以及模拟实现call、bind、apply">【手撕JavaScript系列】this原理以及模拟实现call、bind、apply</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91Promise%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise" rel="bookmark" title="【手撕JavaScript系列】Promise介绍以及实现一个Promise">【手撕JavaScript系列】Promise介绍以及实现一个Promise</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81" rel="bookmark" title="【手撕JavaScript系列】JavaScript中的防抖与节流">【手撕JavaScript系列】JavaScript中的防抖与节流</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%A1%88" rel="bookmark" title="JavaScript中的异步编程方案">JavaScript中的异步编程方案</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Monkey-HH"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Monkey-HH</p>
  <div class="description" itemprop="description">Learn, share, make progress</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">53</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">18</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">23</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vbmtleS1ISA==" title="https:&#x2F;&#x2F;github.com&#x2F;monkey-HH"><i class="ic i-github"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOmhoanNjYXVAMTYzLmNvbQ==" title="mailto:hhjscau@163.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>Links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%88BOM%EF%BC%89" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E3%80%90V8%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86%E7%AF%87%E3%80%91JavaScript%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E8%A7%A3%E6%9E%90" title="【V8引擎原理篇】JavaScript代码解释执行解析">【V8引擎原理篇】JavaScript代码解释执行解析</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" title="JavaScript中的前端模块化">JavaScript中的前端模块化</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/ComputerBasics/" title="In ComputerBasics">ComputerBasics</a>
<i class="ic i-angle-right"></i>
<a href="/categories/ComputerBasics/Computer-Networking/" title="In Computer_Networking">Computer_Networking</a>
</div>

    <span><a href="/ComputerBasics/Computer-Networking/ComputerBasics/Computer_Networking/%E3%80%90%E8%AE%A1%E7%BD%91%E3%80%91HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" title="【计网】HTTP基础知识点">【计网】HTTP基础知识点</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/TypeScript/" title="In TypeScript">TypeScript</a>
</div>

    <span><a href="/FrontEnd/TypeScript/FrontEnd/TypeScript/TypeScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" title="TypeScript基础知识">TypeScript基础知识</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/React/" title="In React">React</a>
</div>

    <span><a href="/FrontEnd/React/FrontEnd/React/%E3%80%90React%E5%9F%BA%E7%A1%80%E3%80%91React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E4%BB%8B%E7%BB%8D" title="【React基础】React合成事件介绍">【React基础】React合成事件介绍</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8" title="客户端存储">客户端存储</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Vue/" title="In Vue">Vue</a>
</div>

    <span><a href="/FrontEnd/Vue/FrontEnd/Vue/%E3%80%90Vue%E8%BF%9B%E9%98%B6%E3%80%91%E6%B5%85%E8%B0%88Vue2%E4%B8%8EVue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86" title="【Vue进阶】浅谈Vue2与Vue3响应式原理">【Vue进阶】浅谈Vue2与Vue3响应式原理</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B" title="JavaScript中的变量类型">JavaScript中的变量类型</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Module-Bundler/" title="In Module_Bundler">Module_Bundler</a>
</div>

    <span><a href="/FrontEnd/Module-Bundler/FrontEnd/Module_Bundler/Webpack5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%A5%E9%97%A8" title="Webpack5基础知识点入门">Webpack5基础知识点入门</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/axios%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%A5%E9%97%A8" title="axios基础知识点入门">axios基础知识点入门</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2021 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Monkey-HH @ Monkey's Blog</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="Symbols count total">760k words</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="Reading time total">11:31</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript中的变量类型',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
