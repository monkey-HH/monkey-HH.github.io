



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://monkeyhh.top/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://monkeyhh.top/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://monkeyhh.top/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="JavaScript" />


<link rel="canonical" href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">



  <title>
JavaScript数据类型 - JavaScript - FrontEnd |
Monkey's Blog = </title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">JavaScript数据类型
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-04-02 09:28:32">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-04-02T09:28:32+08:00">2021-04-02</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>22k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>20 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Monkey's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202109201019726.png">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/" itemprop="item" rel="index" title="In FrontEnd"><span itemprop="name">FrontEnd</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/JavaScript/" itemprop="item" rel="index" title="In JavaScript"><span itemprop="name">JavaScript</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Monkey-HH">
    <meta itemprop="description" content=", Learn, share, make progress">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>变量和类型是学习<code>JavaScript</code>最先接触到的东西，但是往往看起来最简单的东西往往还隐藏着很多你不了解、或者容易犯错的知识，比如下面几个问题：</p>
<ul>
<li><code>JavaScript</code>中的变量在内存中的具体存储形式是什么？</li>
<li><code>0.1+0.2</code>为什么不等于<code>0.3</code>?发生小数计算错误的具体原因是什么？</li>
<li><code>Symbol</code>的特点，以及实际应用场景是什么？</li>
<li><code>[] == ![]</code>、<code>[undefined] == false</code>为什么等于<code>true</code>?代码中何时会发生隐式类型转换？转换的规则是什么？</li>
<li>如何精确的判断变量的类型？</li>
</ul>
<p>如果你还不能很好的解答上面的问题，那说明你还没有完全掌握这部分的知识，那么请好好阅读下面的文章吧。</p>
<p>本文从底层原理到实际应用详细介绍了<code>JavaScript</code>中的变量和类型相关知识。</p>
<h1 id="JavaScript中的数据类型"><a href="#JavaScript中的数据类型" class="headerlink" title="JavaScript中的数据类型"></a>JavaScript中的数据类型</h1><p>ECMAScript变量有两种不同类型的数据：原始值和引用值。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9QcmltaXRpdmU=">原始类型</span>：共七种，使用 typeof 运算符检查:<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS91bmRlZmluZWQ=">undefined</span>：<code>typeof instance === &quot;undefined&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Cb29sZWFu">Boolean</span>：<code>typeof instance === &quot;boolean&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdW1iZXI=">Number</span>：<code>typeof instance === &quot;number&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TdHJpbmc=">String</span>：<code>typeof instance === &quot;string</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TeW1ib2w=">Symbol</span> （ES7新特性）：<code>typeof instance === &quot;symbol&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9CaWdJbnQ=">BigInt</span> （ES11新特性）：<code>typeof instance === &quot;bigint&quot;</code></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdWxs">null</span>：<code>typeof instance === &quot;object&quot;</code></li>
</ul>
</li>
<li>引用值类型：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9PYmplY3Q=">Object</span>：<code>typeof instance === &quot;object&quot;</code>。引用值是保存在内存中的对象。在操作对象时，实际上操作的是对该对象的<strong>引用（reference）</strong>而非 实际的对象本身。</li>
</ul>
<p>记住 <code>typeof</code> 操作符的唯一目的就是检查数据类型，如果我们希望检查任何从 Object 派生出来的结构类型，使用 <code>typeof</code> 是不起作用的，因为总是会得到 <code>&quot;object&quot;</code>。检查 Object 种类的合适方式是使用 instanceof 关键字。但即使这样也存在误差。</p>
<h2 id="原始值和引用值的区别"><a href="#原始值和引用值的区别" class="headerlink" title="原始值和引用值的区别"></a>原始值和引用值的区别</h2><ul>
<li>动态属性：原始值没有属性，引用值可以设置属性。</li>
<li>复制值：原始值是直接开一个新的栈内存，而引用值开一个新的栈内存却指向同一个堆内存的对象。</li>
</ul>
<h1 id="原始值类型Primitive-Value"><a href="#原始值类型Primitive-Value" class="headerlink" title="原始值类型Primitive Value"></a>原始值类型Primitive Value</h1><p><strong>原始类型</strong>（基本数值、基本数据类型）为<code>primitive values</code>，是一种既非<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9PYmplY3Q=">对象</span>也无<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9NZXRob2Q=">方法</span>的数据。此处的非对象和无方法很重要。在 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9KYXZhU2NyaXB0">JavaScript</span> 中，共有7种基本类型：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TdHJpbmc=">string</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdW1iZXI=">number</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9CaWdJbnQ=">bigint</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Cb29sZWFu">boolean</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdWxs">null</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS91bmRlZmluZWQ=">undefined</span>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TeW1ib2w=">symbol</span> (<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9FQ01BU2NyaXB0">ECMAScript</span> 2016新增)。</p>
<p>多数情况下，基本类型直接代表了最底层的语言实现。</p>
<p>所有基本类型的值都是<strong>不可改变</strong>的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p>
<blockquote>
<p>那么原始数据类型的“不可改变”是什么意思？举个栗子</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字符串方法不会改变一个字符串</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">&quot;baz&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar);               <span class="comment">// baz</span></span><br><span class="line">bar.toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(bar);               <span class="comment">// baz，没有变大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值行为可以给基本类型一个新值，而不是改变它</span></span><br><span class="line">bar = bar.toUpperCase();       <span class="comment">// BAZ</span></span><br></pre></td></tr></table></figure>

<p>例子二，说明传给函数的是形参：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个貌似可以改变基本类型值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">   num += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数，并传入基本类型值作为参数</span></span><br><span class="line">addTwo(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo);   <span class="comment">// 5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你是否认为会得到<code>7</code>，而不是<code>5</code>？如果是，请看看代码是如何运行的：</p>
<ul>
<li><code>addTwo</code>函数调用时，JavaScript会检查标识符<code>foo</code>的值，从而准确无误的找到第一行实例化变量的声明语句。</li>
<li>找到以后，JavaScript将其作为参数传递给函数的形参。</li>
<li>在执行函数体内语句之前，<strong>JavaScript会将传递进来的参数（基本类型的值）复制一份</strong>，创建一个本地副本。这个副本只存在于该函数的作用域中，我们能够通过指定在函数中的标识符访问到它（<code>addTwo</code>中的<code>num</code>，<code>addTwo_v2</code>中的<code>foo</code>）。</li>
<li>接下来，函数体中的语句开始执行：<ul>
<li>第一个函数中，创建了本地<code>num</code>参数，<code>num</code>的值加2，但这个值并不是原来的<code>foo</code>的值。</li>
<li>第二个函数中，创建了本地参数<code>foo</code>，并将它的值加2，这个值不是外部foo的值。在这种情况下，外部的<code>foo</code>变量不能以<strong>任何</strong>方式被访问到。这是因为JavaScript的词法作用域（lexical scoping）所导致的变量覆盖，本地的变量<code>foo</code>覆盖了外部的变量<code>foo</code>。欲知详情，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9DbG9zdXJlcw==">闭包</span>。</li>
</ul>
</li>
<li>综上所述，函数中的任何操作都<strong>不会</strong>影响到最初的<code>foo</code>，我们操作的只不过是它的<strong>副本</strong>。</li>
</ul>
<p>这就是为什么说所有基本类型的值都是无法改变的。</p>
<h2 id="typeof-方法"><a href="#typeof-方法" class="headerlink" title="typeof 方法"></a>typeof 方法</h2><p>用来检测基本数据的类型</p>
<p>下表总结了 <code>typeof</code> 可能的返回值。有关类型和原始值的更多信息，可查看 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9EYXRhX3N0cnVjdHVyZXM=">JavaScript 数据结构</span> 页面。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS91bmRlZmluZWQ=">Undefined</span></td>
<td align="left"><code>&quot;undefined&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Cb29sZWFu">Boolean</span></td>
<td align="left"><code>&quot;boolean&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdW1iZXI=">Number</span></td>
<td align="left"><code>&quot;number&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TdHJpbmc=">String</span></td>
<td align="left"><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TeW1ib2w=">Symbol</span> (ECMAScript 2015 新增)</td>
<td align="left"><code>&quot;symbol&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9CaWdJbnQ=">BigInt</span>(ECMAScript 2020 新增)</td>
<td align="left"><code>&quot;bigint&quot;</code></td>
</tr>
<tr>
<td align="left">⭐<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9GdW5jdGlvbg==">Function</span> 对象 (按照 ECMA-262 规范实现 [[Call]])</td>
<td align="left"><code>&quot;function&quot;</code></td>
</tr>
<tr>
<td align="left"><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9OdWxs">⭐Null</span></td>
<td align="left"><code>&quot;object&quot;</code> (见<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3R5cGVvZiNudWxs">下文</span>)</td>
</tr>
<tr>
<td align="left">宿主对象（由 JS 环境提供）</td>
<td align="left"><em>取决于具体实现</em></td>
</tr>
<tr>
<td align="left">其他任何对象</td>
<td align="left"><code>&quot;object&quot;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>关于function：严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是， 函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。</p>
</blockquote>
<blockquote>
<p>那么null为什么返回object呢？</p>
<p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code>。</p>
</blockquote>
<blockquote>
<p>严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏 览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象 不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">37</span> === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span> === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span>(<span class="number">42</span>) === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.LN2 === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// 尽管它是 &quot;Not-A-Number&quot; (非数值) 的缩写</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="number">1</span>) === <span class="string">&#x27;number&#x27;</span>; <span class="comment">// Number 会尝试把参数解析成数值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span> === <span class="string">&#x27;bigint&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;&#x27;</span> === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;bla&#x27;</span> === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">`template literal`</span> === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// 注意内容为数字的字符串仍是字符串</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="keyword">typeof</span> <span class="number">1</span>) === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// typeof 总是返回一个字符串</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="number">1</span>) === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// String 将任意值转换为字符串，比 toString 更安全</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">&#x27;boolean&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> === <span class="string">&#x27;boolean&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="number">1</span>) === <span class="string">&#x27;boolean&#x27;</span>; <span class="comment">// Boolean() 会基于参数是真值还是虚值进行转换</span></span><br><span class="line"><span class="keyword">typeof</span> !!(<span class="number">1</span>) === <span class="string">&#x27;boolean&#x27;</span>; <span class="comment">// 两次调用 ! (逻辑非) 操作符相当于 Boolean()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbols</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">&#x27;symbol&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> declaredButUndefinedVariable === <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> undeclaredVariable === <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Array.isArray 或者 Object.prototype.toString.call</span></span><br><span class="line"><span class="comment">// 区分数组和普通对象</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> /regex/ === <span class="string">&#x27;object&#x27;</span>; <span class="comment">// 历史结果请参阅正则表达式部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⭐此区域例子与下面区域代码区分开，没用到new，说明是基本数据类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="string">&#x27;boolean&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="number">1</span>) === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>) === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⭐下面的例子令人迷惑，非常危险，没有用处。避免使用它们，详情请看引用对象中的“基本数据包装对象”</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>) === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>) === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125; === <span class="string">&#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.sin === <span class="string">&#x27;function&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h3 id="1-独一无二"><a href="#1-独一无二" class="headerlink" title="1.独一无二"></a><strong>1.独一无二</strong></h3><p>直接使用<code>Symbol()</code>创建新的<code>symbol</code>变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的<code>toString()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>();  <span class="comment">// Symbol() </span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>);  <span class="comment">// Symbol(ConardLi)</span></span><br><span class="line"><span class="keyword">var</span> sym4 = <span class="built_in">Symbol</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;ConardLi&#x27;</span>&#125;); <span class="comment">// Symbol([object Object])</span></span><br><span class="line"><span class="built_in">console</span>.log(sym2 === sym3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们用两个相同的字符串创建两个<code>Symbol</code>变量，它们是不相等的，可见每个<code>Symbol</code>变量都是独一无二的。</p>
<p>如果我们想创造两个相等的<code>Symbol</code>变量，可以使用<code>Symbol.for(key)</code>。</p>
<blockquote>
<p>使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;ConardLi&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym1 === sym2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-原始类型"><a href="#2-原始类型" class="headerlink" title="2.原始类型"></a><strong>2.原始类型</strong></h3><p>注意是使用<code>Symbol()</code>函数创建<code>symbol</code>变量，并非使用构造函数，使用<code>new</code>操作符会直接报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// Uncaught TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>typeof</code>运算符判断一个<code>Symbol</code>类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">&#x27;ConardLi&#x27;</span>) === <span class="string">&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-不可枚举"><a href="#3-不可枚举" class="headerlink" title="3.不可枚举"></a><strong>3.不可枚举</strong></h3><p>当使用<code>Symbol</code>作为对象属性时，可以保证对象不会出现重名属性，调用<code>for...in</code>不能将其枚举出来，另外调用<code>Object.getOwnPropertyNames、Object.keys()</code>也不能获取<code>Symbol</code>属性。</p>
<blockquote>
<p>可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name:&#x27;ConardLi&#x27;,</span><br><span class="line">  [Symbol(&#x27;name2&#x27;)]:&#x27;code秘密花园&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Object.getOwnPropertyNames(obj); // [&quot;name&quot;]</span><br><span class="line">Object.keys(obj); // [&quot;name&quot;]</span><br><span class="line">for (var i in obj) &#123;</span><br><span class="line">   console.log(i); // name</span><br><span class="line">&#125;</span><br><span class="line">Object.getOwnPropertySymbols(obj) // [Symbol(name)]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="4-Symbol的应用场景"><a href="#4-Symbol的应用场景" class="headerlink" title="4.Symbol的应用场景"></a>4.Symbol的应用场景</h3><p>下面是几个<code>Symbol</code>在程序中的应用场景。</p>
<p><strong>应用一：防止XSS</strong></p>
<p>在<code>React</code>的<code>ReactElement</code>对象中，有一个<code>?typeof</code>属性，它是一个<code>Symbol</code>类型的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> REACT_ELEMENT_TYPE =</span><br><span class="line">  (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.for &amp;&amp; <span class="built_in">Symbol</span>.for(<span class="string">&#x27;react.element&#x27;</span>)) ||</span><br><span class="line">  <span class="number">0xeac7</span>;</span><br></pre></td></tr></table></figure>

<p><code>ReactElement.isValidElement</code>函数用来判断一个React组件是否是有效的，下面是它的具体实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">&#x27;object&#x27;</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.?<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见<code>React</code>渲染时会把没有<code>?typeof</code>标识，以及规则校验不通过的组件过滤掉。</p>
<p>如果你的服务器有一个漏洞，允许用户存储任意<code>JSON</code>对象， 而客户端代码需要一个字符串，这可能会成为一个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// JSON</span><br><span class="line">let expectedTextButGotJSON = &#123;</span><br><span class="line">  type: &#x27;div&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    dangerouslySetInnerHTML: &#123;</span><br><span class="line">      __html: &#x27;/* put your exploit here */&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">let message = &#123; text: expectedTextButGotJSON &#125;;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &#123;message.text&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>而<code>JSON</code>中不能存储<code>Symbol</code>类型的变量，这就是防止<code>XSS</code>的一种手段。</p>
<p><strong>应用二：私有属性</strong></p>
<p>借助<code>Symbol</code>类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateField = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[privateField] = <span class="string">&#x27;ConardLi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getField</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[privateField];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setField</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[privateField] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用三：防止属性污染</strong></p>
<p>在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用<code>Symbol</code>作为对象属性可以保证永远不会出现同名属性。</p>
<p>例如下面的场景，我们模拟实现一个<code>call</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.myCall() 直接调用</span></span><br><span class="line">&#125;</span><br><span class="line">	context = context || <span class="built_in">window</span>;</span><br><span class="line">	<span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">	context[fn] = <span class="built_in">this</span>;</span><br><span class="line">	<span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">	<span class="keyword">delete</span> context[fn];</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要在某个对象上临时调用一个方法，又不能造成属性污染，<code>Symbol</code>是一个很好的选择。</p>
<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>ES2020为JavaScript定义了一种新的数值类型BigInt。之所以增 加这个类型，主要是为了表示64位整数。</p>
<p>这对于兼容很多其他语言 和API是必需的。但BigInt值可能有数千甚至数百万个数字，可以满 足对大数的需求（不过，BigInt的实现并不适合加密，因为它们没 有考虑防止时序攻击）。</p>
<h1 id="引用值类型Reference-Value"><a href="#引用值类型Reference-Value" class="headerlink" title="引用值类型Reference Value"></a>引用值类型Reference Value</h1><p>JavaScript中除了基本数据类型外，基本全是引用对象（大多数基本数据类型也有对应的“包装对象”）。</p>
<p>引用值类型大致可以分为基本引用类型和集合引用类型。</p>
<p><strong>基本引用类型</strong>：</p>
<ul>
<li>Date </li>
<li>DegExp</li>
<li>原始值包装类型</li>
<li>单例内置对象：Global和Math</li>
</ul>
<p><strong>集合引用类型</strong>：</p>
<ul>
<li>Object</li>
<li>Array与定型数组</li>
<li>Map、WeakMap、Set、WeakSet类型</li>
<li>……</li>
</ul>
<p>具体有哪些引用类型可以看看<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHM=">标准内置对象</span></p>
<h2 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h2><h3 id="基本数据类型包装对象-使用-new-关键字"><a href="#基本数据类型包装对象-使用-new-关键字" class="headerlink" title="基本数据类型包装对象(使用 new 关键字)"></a>基本数据类型包装对象(使用 new 关键字)</h3><p>除了 <code>null</code> 和 <code>undefined</code>之外，所有基本类型都有其对应的包装对象：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a> 为字符串基本类型。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a> 为数值基本类型。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a> 为大整数基本类型。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a> 为布尔基本类型。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a> 为字面量基本类型。</li>
</ul>
<p>这个包裹对象的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>valueOf()</code></a>方法返回基本类型值。</p>
<blockquote>
<p>为什么要有这个包装对象?</p>
<p>我们知道基本数据类型是非对象、无方法且不可改变的，为了保持这个特性</p>
</blockquote>
<p>从基本数据类型那个例子可以看到，当使用了new关键字给变量辅助的时候，会用到这个包装对象</p>
<p>我们来通过下面这个String包装类的例子，学习包装对象的使用，其他包装类型大同小异</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>); </span><br></pre></td></tr></table></figure>

<p>在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在 s1 上调用了 substring() 方法，并把结果保存在 s2 中。我们知道，<strong>原始值本身不是对象，因此逻辑上不应该有方法</strong>。而实际上 这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当 第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串 值的任何时候，后台都会执行以下 3 步：</p>
<p> (1) 创建一个 String 类型的实例； </p>
<p> (2) 调用实例上的特定方法；</p>
<p> (3) 销毁实例。 可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">s1 = <span class="literal">null</span>; <span class="comment">//这个新String就会被垃圾回收</span></span><br></pre></td></tr></table></figure>

<p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过 使用的是 Boolean 和 Number 包装类型而已。</p>
<p> 引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到 的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期 间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>; </span><br><span class="line">s1.color = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(s1.color); <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure>

<p>这里的第二行代码尝试给字符串 s1 添加了一个 color 属性。可是，第三行代码访问 color 属性时， 它却不见了。原因就是第二行代码运行时会临时创建一个 String 对象，而当第三行代码执行时，这个对 象已经被销毁了。实际上，第三行代码在这里创建了自己的 String 对象，但这个对象没有 color 属性。</p>
<p>另外当要创建某个包装对象时候，可以通过new Object来创建不同的包装对象，Object 构造函数作为一个工厂方法，能够<u>根据传入值的类型返回相应原始值包装类型的实例</u>。比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">&quot;some text&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>大多数引用值的示例使用的是 Object 类型。</p>
<p>具体有什么方法可以参考<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0">Object</span></p>
<h4 id="创建Object实例形式"><a href="#创建Object实例形式" class="headerlink" title="创建Object实例形式"></a>创建Object实例形式</h4><p>（1）：使用 new 操作符和 Object 构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>

<p>弊端：创建同一个类型的Object的时候，要重复编写代码</p>
<p>（2）：对象字面量（object literal）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line">	<span class="attr">age</span>: <span class="number">29</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>弊端：创建同一个类型的Object的时候，要重复编写代码</p>
<p>（3）工厂模式</p>
<p>把上面的代码封装到一个函数中，然后该函数返回新生成的对象。如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">//返回一个对象的函数===&gt;工厂函数</span></span><br><span class="line">	<span class="keyword">var</span> obj = &#123;</span><br><span class="line">		<span class="attr">name</span>: name,</span><br><span class="line">		<span class="attr">age</span>: age,</span><br><span class="line">		<span class="attr">setName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.name = name</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弊端：没有解决对象标识问题（即新创建的对象是什么类型）</p>
<p>（4）构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>至于为什么this可以指向该实例对象，可以看我的this的文章。</p>
<blockquote>
<p>其实不会说一个函数就是构造函数，啥函数就是普通函数。用了new的时候就是构造函数，不用new调用就是普通函数。</p>
<p>直接Person(“Greg”,27);//添加到了window对象</p>
<p>window.sayName()//“Greg”</p>
</blockquote>
<p>弊端：每个对象的setName方法在构造函数中事实上每一次都开辟一个新的内存空间放，但功能一样的函数，没必要占多余空间，所以可以用下一种方法。</p>
<p>（5）构造函数+原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">//在构造函数中只初始化一般函数</span></span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提一提原型的知识：</p>
<p>①每定义一个函数，就会给该函数创建一个prototype属性（指向原型对象）。</p>
<p>②该原型对象也有一个constructor属性指回该函数。</p>
<p>③每对该函数进行构造调用，新实例都有一个__proto__指向其原型对象。</p>
<h4 id="Object构造方法"><a href="#Object构造方法" class="headerlink" title="Object构造方法"></a>Object构造方法</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/Object"><code>Object()</code></a> 创建一个新<code>Object</code>对象。它是给定值的包装器。</p>
<h4 id="Obeject属性"><a href="#Obeject属性" class="headerlink" title="Obeject属性"></a>Obeject属性</h4><p>ECMA-262 使用一些<code>内部特性</code>来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。</p>
<p>开发者不能在 JavaScript 中直接访问这些特性。</p>
<p>为了将某个特性标识为<code>内部特性</code>，规范会用两个中括号把特性的名称括起来，比如[[Enumerable]]。</p>
<p><strong>属性分两种：数据属性和访问器属性。</strong></p>
<p>这些属性可以在Object.defineProperty()的时候指定。</p>
<h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><ul>
<li>[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特 性，以及是否可以把它改为访问器属性。所有直接定义在对象上的属性，该值默认为true。</li>
<li>[[Enumerable]]：表示属性是否可以通过 for-in 循环返回。所有直接定义在对象上的属性，该值默认为true。</li>
<li>[[Writable]]：表示属性的值是否可以被修改。所有直接定义在对象上的属性，该值默认为true。</li>
<li>[[Value]]：包含属性实际的值。默认值为 undefined。</li>
</ul>
<h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ul>
<li>[[Configurable]]：同上</li>
<li>[[Enumerable]]：同上</li>
<li>[[Get]]：获取函数，在读取属性时调用。默认值为 undefined。</li>
<li>[[Set]]：设置函数，在写入属性时调用。默认值为 undefined。</li>
</ul>
<h4 id="Object静态方法"><a href="#Object静态方法" class="headerlink" title="Object静态方法"></a>Object静态方法</h4><ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create(proto [, propertiesObject])</code></a>：创建具有指定”原型对象“和属性的新对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">isHuman</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">printIntroduction</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="built_in">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">&#x27;Matthew&#x27;</span>; <span class="comment">// &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; <span class="comment">// inherited properties can be overwritten</span></span><br><span class="line"></span><br><span class="line">me.printIntroduction();<span class="comment">//&quot;My name is Matthew. Am I human? true&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以实现原型链继承。</p>
<ol start="2">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty(obj, prop, descriptor)</code></a>：定义一个新属性，且可加对应的属性描述符。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">	<span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">//没法删除，且没法通过defineProperty方法定相同属性</span></span><br><span class="line">	<span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot; </span></span><br><span class="line">person.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值”Nicholas”。这个属性的值就 不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性 的值会抛出错误。</p>
<ol start="3">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties"><code>Object.defineProperties(obj, props)</code></a> ：定义多个属性，用法和上面一样</li>
</ol>
<ol start="4">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor"><code>Object.getOwnPropertyDescriptor(obj, prop)</code></a> ：取得指定属性的属性描述符</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&#x27;year_&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">year_</span>: &#123;</span><br><span class="line">		<span class="attr">value</span>: <span class="number">2017</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value); <span class="comment">// 2017 </span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> descriptor.get); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>



<ol start="5">
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors"><code>Object.getOwnPropertyDescriptors(obj)</code></a> ：获取多个属性的属性描述符</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign(target, ...sources)</code></a> ：合并对象</p>
</li>
</ol>
<ul>
<li>这个方法接收一个目标对象和一个 或多个源对象作为参数</li>
<li>然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true） 和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。</li>
<li>对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标 对象上的[[Set]]设置属性的值。</li>
<li>实际上对每个源对象执行的是<strong>浅复制</strong>。如果多个源对象都有相同的属性，则使用最后一个复制的值。</li>
<li>不能在两个对象间转移get函数和set函数。即从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。</li>
<li>如果赋值期间出错，则操作会中止并退出，不会<strong>回滚</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest = &#123;&#125;;</span><br><span class="line">result = <span class="built_in">Object</span>.assign(dest, &#123;<span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span>&#125;, &#123;<span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123; a: foo, b: bar &#125;</span></span><br></pre></td></tr></table></figure>

<p>下面用一个例子看看第三点是什么意思</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dest = &#123; </span><br><span class="line">     <span class="keyword">set</span> <span class="title">a</span>(<span class="params">val</span>) &#123; </span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;; </span><br><span class="line">src = &#123; </span><br><span class="line">     <span class="keyword">get</span> <span class="title">a</span>() &#123; </span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;Invoked src getter&#x27;</span>); </span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src); </span><br><span class="line"><span class="comment">// 调用 src 的获取方法，打印“Invoked src getter”</span></span><br><span class="line"><span class="comment">// 调用 dest 的设置方法并传入参数&quot;foo&quot; 。打印“Invoked dest setter with param foo”</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; set a(val) &#123;...&#125; &#125; </span></span><br></pre></td></tr></table></figure>

<p>打印dest中发现，因为这里的设置函数不执行赋值操作，所以实际上并没有把值转移过来</p>
<p>再看看浅复制的意思：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dest = &#123;&#125;; </span><br><span class="line">src = &#123; <span class="attr">a</span>: &#123;&#125; &#125;; </span><br><span class="line"><span class="built_in">Object</span>.assign(dest, src); </span><br><span class="line"><span class="comment">// 浅复制意味着只会复制对象的引用</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123; a :&#123;&#125; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(dest.a === src.a); <span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is()</code></a> ： 判断两个值是否相等</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf(obj)</code></a> ： 返回某个对象的原型对象</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf(obj, prototype)</code></a> ： 更改某个对象的原型</li>
</ol>
<p>这个方法不建议用，因为会影响非常多的东西，可以通过 Object.create()来创 建一个新对象，同时为其指定原型。</p>
<ol start="10">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys(obj)</code></a> ：获得对象上所有“可枚举“的“实例属性”</li>
</ol>
<p>注意两点：</p>
<ul>
<li>可枚举，即[Enumerable]]特性被设置为 true</li>
<li>实例属性，即原型上的都不算</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// &quot;name,age,job,sayName&quot; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">&quot;Rob&quot;</span>;</span><br><span class="line">p1.age = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">let</span> p1keys = <span class="built_in">Object</span>.keys(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p1keys); <span class="comment">// &quot;[name,age]&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>for-in循环中用到in操作符时，可以通过对象访问且可以被枚举的属性（[[Enumerable]]特性被设置为 true）都会返回，包括实例属性和原型属性。</p>
</blockquote>
<ol start="11">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames"><code>Object.getOwnPropertyNames()</code></a> ：和10不同，获取所有实例属性，不管是否可以枚举。</li>
</ol>
<p>注意这个方法不会拿到Symbol的属性。</p>
<ol start="12">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code>Object.getOwnPropertySymbols(obj)</code></a> ：和11不同，针对Symbol的属性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">	k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	[k1]: <span class="string">&#x27;k1&#x27;</span>,</span><br><span class="line">	[k2]: <span class="string">&#x27;k2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));<span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));<span class="comment">//[]</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>属性枚举顺序：</p>
<p>for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及 Object.assign()在属性枚举顺序方面有很大区别。</p>
<ul>
<li>for-in 循环和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。</li>
<li> Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign() 的枚举顺序是确定性的。</li>
<li>先以升序枚举数值键</li>
<li>然后以插入顺序枚举字符串和符号键。</li>
<li>在对象字面量中定义的键以它们逗号分隔的顺序插入。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>),</span><br><span class="line">	k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	<span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">first</span>: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">	[k1]: <span class="string">&#x27;sym2&#x27;</span>,</span><br><span class="line">	<span class="attr">second</span>: <span class="string">&#x27;second&#x27;</span>,</span><br><span class="line">	<span class="number">0</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">o[k2] = <span class="string">&#x27;sym2&#x27;</span>;</span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">o.third = <span class="string">&#x27;third&#x27;</span>;</span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(o));</span><br><span class="line"><span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;] </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(o));</span><br><span class="line"><span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure>


</blockquote>
<ol start="13">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values"><code>Object.values(obj)</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries(Object.entries())</code></a> : 前者返回对象key的数组，后者 key/value对的数组。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">	<span class="attr">baz</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">qux</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o));</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 1, &#123;&#125;] </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o)));</span><br><span class="line"><span class="comment">// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]]</span></span><br></pre></td></tr></table></figure>

<p>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">	<span class="attr">qux</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)[<span class="number">0</span>] === o.qux);</span><br><span class="line"><span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(o)[<span class="number">0</span>][<span class="number">1</span>] === o.qux);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>符号属性会被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> o = &#123; </span><br><span class="line"> [sym]: <span class="string">&#x27;foo&#x27;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o)); </span><br><span class="line"><span class="comment">// [] </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries((o))); </span><br><span class="line"><span class="comment">// [] </span></span><br></pre></td></tr></table></figure>

<ol start="14">
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><code>Object.freeze()</code></a> : 冻结对象。其他代码无法删除或更改其属性。</li>
</ol>
<p>当然可以用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen"><code>Object.isFrozen()</code></a> 确定对象是否被冻结。</p>
<h4 id="Object实例属性"><a href="#Object实例属性" class="headerlink" title="Object实例属性"></a>Object实例属性</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a> ：指定创建对象原型的函数。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a> ：指向在实例化对象时用作原型的对象。</p>
<h4 id="Object实例方法-Object原型的方法"><a href="#Object实例方法-Object原型的方法" class="headerlink" title="Object实例方法/Object原型的方法"></a>Object实例方法/Object原型的方法</h4><ol>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty(prop)</code></a> ： 某个属性在实例上则返回真，在原型上的也不算，毕竟是own</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> example = &#123;&#125;;</span><br><span class="line">example.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">example.prop = <span class="string">&#x27;exists&#x27;</span>;</span><br><span class="line">example.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// true - &#x27;prop&#x27; has been defined</span></span><br><span class="line"></span><br><span class="line">example.prop = <span class="literal">null</span>;</span><br><span class="line">example.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// true - own property exists with value of null</span></span><br><span class="line"></span><br><span class="line">example.prop = <span class="literal">undefined</span>;</span><br><span class="line">example.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);   <span class="comment">// true - own property exists with value of undefined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里和in操作符区分一下</p>
<p>in：只要能通过对象访问到就行，无论是自己的属性还是原型上的属性</p>
<p>hasOwnProperty：只有自己的属性才为真</p>
</blockquote>
<ol start="2">
<li></li>
</ol>
<h2 id="instanceof方法判断对象类型"><a href="#instanceof方法判断对象类型" class="headerlink" title="instanceof方法判断对象类型"></a>instanceof方法判断对象类型</h2><p>在原始类型的介绍当中，我们可以看到，typeof只能去确定基本数据类型的数据，而对于所有引用对象返回的都是object，此时就需要一个新的方法instanceof来判断对象类型</p>
<p>当我们需要知道某个对象的具体类型时,可以用运算符 instanceof，instanceof操作符判断左操作数对象的原型链上是否有右边这个构造函数的prototype属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。 检测的我们用一段伪代码来模拟instanceof内部执行过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">instanceof</span> (A,B) = &#123;</span><br><span class="line">    <span class="keyword">var</span> L = A.__proto__;</span><br><span class="line">    <span class="keyword">var</span> R = B.prototype;</span><br><span class="line">    <span class="keyword">if</span>(L === R) &#123;</span><br><span class="line">        <span class="comment">//A的内部属性__proto__指向B的原型对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>从上述过程可以看出，当 A 的 <strong>proto</strong> 指向 B 的 prototype 时，就认为A就是B的实例，我们再来看几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person;<span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？ 我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出 [].<strong>proto</strong> 指向 Array.prototype， 而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，Object.prototype.<strong>proto</strong> 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链：</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210908001635092.png" alt="image-20210908001635092"></p>
<p>从原型链可以看出，[] 的 <strong>proto</strong>  直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。</p>
<p>注意:instanceof运算符只能用于对象，不适用原始类型的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>字符串、null和undefined不是对象，所以返回false。</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.constructor === F;<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">F.prototype = &#123;</span><br><span class="line">	<span class="attr">_name</span>: <span class="string">&#x27;Eric&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.constructor === F; <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">F.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: F, </span><br><span class="line">   <span class="attr">_name</span>: <span class="string">&#x27;Eric&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.constructor === F; <span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h2><p>toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object,xxx],xxx是具体的数据类型，其中包括：String,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument,… 基本上所有对象的类型都可以通过这个方法获取到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ; <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) ; <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object Window]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，必须通过Object.prototype.toString.call来获取，而不能直接 new Date().toString(), 从原型链的角度讲，所有对象的原型链最终都指向了Object, 按照JS变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用call来强制执行Object的toString方法。</p>
<h1 id="基本数据类型和引用对象类型存储原理"><a href="#基本数据类型和引用对象类型存储原理" class="headerlink" title="基本数据类型和引用对象类型存储原理"></a>基本数据类型和引用对象类型存储原理</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str += <span class="string">&#x27;6&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// ConardLi6</span></span><br></pre></td></tr></table></figure>

<p>你会发现，<code>str</code>的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：</p>
<p>在<code>JavaScript</code>中，每一个变量在内存中都需要一个空间来存储。</p>
<p>内存空间又被分为两种，栈内存与堆内存。</p>
<p>栈内存：</p>
<ul>
<li>存储的值大小固定</li>
<li>空间较小</li>
<li>可以直接操作其保存的变量，运行效率高</li>
<li>由系统自动分配存储空间</li>
</ul>
<p><code>JavaScript</code>中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/16afa4daf89c565e~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。</p>
<p>在上面的代码中，我们执行了<code>str += &#39;6&#39;</code>的操作，实际上是在栈中又开辟了一块内存空间用于存储<code>&#39;ConardLi6&#39;</code>，然后将变量<code>str</code>指向这块空间，所以这并不违背<code>不可变性的</code>特点。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/16afa4dd38de23b8~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>堆内存：</p>
<ul>
<li>存储的值大小不定，可动态调整</li>
<li>空间较大，运行效率低</li>
<li>无法直接操作其内部存储，使用引用地址读取</li>
<li>通过代码进行分配空间</li>
</ul>
<p>相对于上面具有不可变性的原始类型，我习惯把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;name:&quot;ConardLi&quot;&#125;</span><br><span class="line">var obj2 = &#123;age:18&#125;</span><br><span class="line">var obj3 = function()&#123;...&#125;</span><br><span class="line">var obj4 = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/16afa4df7faa4630~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<blockquote>
<p>由于内存是有限的，这些变量不可能一直在内存中占用资源，这里推荐下这篇文章<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODMzMzg3MTU1NDY0">JavaScript中的垃圾回收和内存泄漏</span>，这里告诉你<code>JavaScript</code>是如何进行垃圾回收以及可能会发生内存泄漏的一些场景。</p>
</blockquote>
<p>当然，引用类型就不再具有<code>不可变性</code>了，我们可以轻易的改变它们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj1.name = <span class="string">&quot;ConardLi6&quot;</span>;</span><br><span class="line">obj2.age = <span class="number">19</span>;</span><br><span class="line">obj4.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name:&quot;ConardLi6&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age:19&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// []</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以数组为例，它的很多方法都可以改变它自身。</p>
<ul>
<li><code>pop()</code> 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素</li>
<li><code>push()</code>向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度</li>
<li><code>shift()</code>把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值</li>
<li><code>unshift()</code>向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度</li>
<li><code>reverse()</code>颠倒数组中元素的顺序，改变原数组，返回该数组</li>
<li><code>sort()</code>对数组元素进行排序，改变原数组，返回该数组</li>
<li><code>splice()</code>从数组中添加/删除项目，改变原数组，返回被删除的元素</li>
</ul>
<p>下面我们通过几个操作来对比一下原始类型和引用类型的区别：</p>
<p>复制：原始数据类型是开一块新堆内存，引用对象是复制地址</p>
<p>比较：原始数据类型是直接比较值，引用对象是比较地址</p>
<h1 id="一些面试题"><a href="#一些面试题" class="headerlink" title="一些面试题"></a>一些面试题</h1><h2 id="为什么0-1-0-2-0-3"><a href="#为什么0-1-0-2-0-3" class="headerlink" title="为什么0.1+0.2!=0.3"></a>为什么0.1+0.2!=0.3</h2><p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202109192310285.png" alt="image-20210919231013374"></p>
<p>js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p>
<p>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</p>
<p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><p>《JavaScript高级程序设计》</p>
</li>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
<li></li>
</ul>

      <div class="tags">
          <a href="/tags/JavaScript/" rel="tag"><i class="ic i-tag"></i> JavaScript</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-10-25 18:38:45" itemprop="dateModified" datetime="2021-10-25T18:38:45+08:00">2021-10-25</time>
  </span>
  <span id="FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript数据类型" class="item leancloud_visitors" data-flag-title="JavaScript数据类型" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>Monkey-HH <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" title="JavaScript数据类型">https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript数据类型</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/HelloWorld/hello-world" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeu7txpzj20zk0m81kx.jpg" title="hello-world">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> HelloWorld</span>
  <h3>hello-world</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202109201019726.png" title="JavaScript原型和原型链">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> JavaScript</span>
  <h3>JavaScript原型和原型链</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB"><span class="toc-number">1.</span> <span class="toc-text">导读</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">JavaScript中的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">原始值和引用值的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%B1%BB%E5%9E%8BPrimitive-Value"><span class="toc-number">3.</span> <span class="toc-text">原始值类型Primitive Value</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">typeof 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-number">3.2.</span> <span class="toc-text">Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.独一无二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.原始类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.不可枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Symbol%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.4.</span> <span class="toc-text">4.Symbol的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInt"><span class="toc-number">3.3.</span> <span class="toc-text">BigInt</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%80%BC%E7%B1%BB%E5%9E%8BReference-Value"><span class="toc-number">4.</span> <span class="toc-text">引用值类型Reference Value</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">基本引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1-%E4%BD%BF%E7%94%A8-new-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本数据类型包装对象(使用 new 关键字)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">集合引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object"><span class="toc-number">4.2.1.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAObject%E5%AE%9E%E4%BE%8B%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">创建Object实例形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">Object构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Obeject%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">Obeject属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.1.3.1.</span> <span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.1.3.2.</span> <span class="toc-text">访问器属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">Object静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.1.5.</span> <span class="toc-text">Object实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-Object%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.6.</span> <span class="toc-text">Object实例方法&#x2F;Object原型的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">instanceof方法判断对象类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">4.4.</span> <span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype-toString"><span class="toc-number">4.5.</span> <span class="toc-text">Object.prototype.toString</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">基本数据类型和引用对象类型存储原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">一些面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2-0-3"><span class="toc-number">6.1.</span> <span class="toc-text">为什么0.1+0.2!&#x3D;0.3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">7.</span> <span class="toc-text">参考链接</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li class="active"><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="bookmark" title="JavaScript数据类型">JavaScript数据类型</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="bookmark" title="JavaScript原型和原型链">JavaScript原型和原型链</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" rel="bookmark" title="JavaScript执行上下文">JavaScript执行上下文</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84this" rel="bookmark" title="JavaScript中的this">JavaScript中的this</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85" rel="bookmark" title="JavaScript作用域与闭包">JavaScript作用域与闭包</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88" rel="bookmark" title="JavaScript常用继承方案">JavaScript常用继承方案</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" rel="bookmark" title="JavaScript事件循环">JavaScript事件循环</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" rel="bookmark" title="JavaScript中的前端模块化">JavaScript中的前端模块化</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Monkey-HH"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Monkey-HH</p>
  <div class="description" itemprop="description">Learn, share, make progress</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">17</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">6</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">8</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vbmtleS1ISA==" title="https:&#x2F;&#x2F;github.com&#x2F;monkey-HH"><i class="ic i-github"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOmhoanNjYXVAMTYzLmNvbQ==" title="mailto:hhjscau@163.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>Links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/HelloWorld/hello-world" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" title="JavaScript事件循环">JavaScript事件循环</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88" title="JavaScript常用继承方案">JavaScript常用继承方案</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/CSS/" title="In CSS">CSS</a>
</div>

    <span><a href="/FrontEnd/CSS/FrontEnd/CSS/CSS%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93" title="CSS布局总结">CSS布局总结</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/CSS/" title="In CSS">CSS</a>
</div>

    <span><a href="/FrontEnd/CSS/FrontEnd/CSS/CSS%E9%80%89%E6%8B%A9%E5%99%A8" title="CSS选择器">CSS选择器</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" title="JavaScript原型和原型链">JavaScript原型和原型链</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" title="JavaScript中的前端模块化">JavaScript中的前端模块化</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" title="浏览器原理介绍">浏览器原理介绍</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Computer-Networking/" title="In Computer-Networking">Computer-Networking</a>
</div>

    <span><a href="/Computer-Networking/Computer%20Networking/TCP%E5%92%8CUDP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" title="TCP和UDP基础知识点">TCP和UDP基础知识点</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98" title="解决跨域问题">解决跨域问题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84this" title="JavaScript中的this">JavaScript中的this</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Monkey-HH @ Monkey's Blog</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="Symbols count total">187k words</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="Reading time total">2:50</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript数据类型',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
