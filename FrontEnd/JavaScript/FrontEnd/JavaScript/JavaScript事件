



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://monkeyhh.top/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://monkeyhh.top/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://monkeyhh.top/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="JavaScript" />


<link rel="canonical" href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6">



  <title>
JavaScript事件 - JavaScript - FrontEnd |
Monkey's Blog = </title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">JavaScript事件
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-05-15 09:28:32">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-05-15T09:28:32+08:00">2021-05-15</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>47k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>42 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Monkey's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202109201018875.jpg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/" itemprop="item" rel="index" title="In FrontEnd"><span itemprop="name">FrontEnd</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/JavaScript/" itemprop="item" rel="index" title="In JavaScript"><span itemprop="name">JavaScript</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Monkey-HH">
    <meta itemprop="description" content=", Learn, share, make progress">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>众所周知，JavaScript是一个基于事件驱动的语言，因此我们学习JavaScript一定离不开JavaScript事件的学习，也是很重要的基础。</p>
<h1 id="一、DOM事件级别"><a href="#一、DOM事件级别" class="headerlink" title="一、DOM事件级别"></a>一、DOM事件级别</h1><p>在 Web 端，我们常见的就是 DOM 事件：</p>
<ul>
<li>DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。</li>
<li>DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件</li>
<li>DOM3级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件</li>
</ul>
<h2 id="DOM-0级事件"><a href="#DOM-0级事件" class="headerlink" title="DOM 0级事件"></a>DOM 0级事件</h2><p>0级事件只会在冒泡阶段触发</p>
<h3 id="HTML的on-属性"><a href="#HTML的on-属性" class="headerlink" title="HTML的on-属性"></a>HTML的on-属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;触发事件&#x27;)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething()&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript定义"><a href="#JavaScript定义" class="headerlink" title="JavaScript定义"></a>JavaScript定义</h3><p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = doSomething <span class="comment">//没有（）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"> btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     alert(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">el.setAttribute(<span class="string">&#x27;onclick&#x27;</span>, <span class="string">&#x27;doSomething()&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// &lt;Element onclick=&quot;doSomething()&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>若想解除事件的话，则重新指定<code>on-event</code>为<code>null</code>即可：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>同一个元素的同一种事件只能绑定一个函数，否则后面的函数会覆盖之前的函数</li>
<li>不存在兼容性问题</li>
<li>0级事件违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</li>
</ol>
<h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><p>监听函数内部的<code>this</code>指向触发事件的那个元素节点⭐</p>
<h2 id="DOM-2级事件"><a href="#DOM-2级事件" class="headerlink" title="DOM 2级事件"></a>DOM 2级事件</h2><h3 id="EventTarget-addEventListener-：绑定事件的监听函数"><a href="#EventTarget-addEventListener-：绑定事件的监听函数" class="headerlink" title="EventTarget.addEventListener()：绑定事件的监听函数"></a>EventTarget.<code>addEventListener()</code>：绑定事件的监听函数</h3><p><code>EventTarget.addEventListener()</code>用于在当前节点或对象上（即部署了 EventTarget 接口的对象），定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数。</p>
<ul>
<li><code>type</code>：事件名称，大小写敏感。</li>
<li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li>
<li><code>useCapture</code>：布尔值，如果设为<code>true</code>，表示监听函数将在捕获阶段（capture）触发。该参数可选，默认值为<code>false</code>（监听函数只在冒泡阶段被触发）。</li>
</ul>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>注意：同一个元素的同种事件可以绑定<strong>多个</strong>函数，按照绑定顺序执行</p>
<h3 id="EventTarget-removeEventListener-：移除事件的监听函数"><a href="#EventTarget-removeEventListener-：移除事件的监听函数" class="headerlink" title="EventTarget.removeEventListener()：移除事件的监听函数"></a>EventTarget.<code>removeEventListener()</code>：移除事件的监听函数</h3><p><code>removeEventListener()</code>方法的参数，与<code>addEventListener()</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.removeEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>注意，<code>removeEventListener()</code>方法移除的监听函数，必须是<code>addEventListener()</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener()</code>方法无效，因为监听函数不是同一个匿名函数。</p>
<h3 id="EventTarget-dispatchEvent-：触发事件"><a href="#EventTarget-dispatchEvent-：触发事件" class="headerlink" title="EventTarget.dispatchEvent()：触发事件"></a><code>EventTarget.dispatchEvent()</code>：触发事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.dispatchEvent(event)</span><br></pre></td></tr></table></figure>

<p><code>EventTarget.dispatchEvent()</code>方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">para.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">para.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>下面代码根据<code>dispatchEvent()</code>方法的返回值，判断事件是否被取消了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canceled = !cb.dispatchEvent(event);</span><br><span class="line"><span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;事件取消&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;事件未取消&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DOM-3级事件"><a href="#DOM-3级事件" class="headerlink" title="DOM 3级事件"></a>DOM 3级事件</h2><p>DOM3级事件在<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPURPTTIlRTclQkElQTclRTQlQkElOEIlRTQlQkIlQjYmc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9zb3VyY2U9RW50aXR5Jmh5YnJpZF9zZWFyY2hfZXh0cmE9JTdCJTIyc291cmNlVHlwZSUyMjolMjJhcnRpY2xlJTIyLCUyMnNvdXJjZUlkJTIyOjczMDkxNzA2JTdE">DOM2级事件</span>的基础上添加了更多的事件类型，增加的类型如下：</p>
<ul>
<li>UI事件，当用户与页面上的元素交互时触发，如：load、scroll</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFNyU4NCVBNiVFNyU4MiVCOSVFNCVCQSU4QiVFNCVCQiVCNiZzZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyOiUyMmFydGljbGUlMjIsJTIyc291cmNlSWQlMjI6NzMwOTE3MDYlN0Q=">焦点事件</span>，当元素获得或失去焦点时触发，如：blur、focus</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFOSVCQyVBMCVFNiVBMCU4NyVFNCVCQSU4QiVFNCVCQiVCNiZzZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyOiUyMmFydGljbGUlMjIsJTIyc291cmNlSWQlMjI6NzMwOTE3MDYlN0Q=">鼠标事件</span>，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFNiVCQiU5QSVFOCVCRCVBRSVFNCVCQSU4QiVFNCVCQiVCNiZzZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyOiUyMmFydGljbGUlMjIsJTIyc291cmNlSWQlMjI6NzMwOTE3MDYlN0Q=">滚轮事件</span>，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFNiU5NiU4NyVFNiU5QyVBQyVFNCVCQSU4QiVFNCVCQiVCNiZzZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyOiUyMmFydGljbGUlMjIsJTIyc291cmNlSWQlMjI6NzMwOTE3MDYlN0Q=">文本事件</span>，当在文档中输入文本时触发，如：textInput</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3NlYXJjaD9xPSVFOSU5NCVBRSVFNyU5QiU5OCVFNCVCQSU4QiVFNCVCQiVCNiZzZWFyY2hfc291cmNlPUVudGl0eSZoeWJyaWRfc2VhcmNoX3NvdXJjZT1FbnRpdHkmaHlicmlkX3NlYXJjaF9leHRyYT0lN0IlMjJzb3VyY2VUeXBlJTIyOiUyMmFydGljbGUlMjIsJTIyc291cmNlSWQlMjI6NzMwOTE3MDYlN0Q=">键盘事件</span>，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li>
<li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</li>
<li>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</li>
<li>同时DOM3级事件也允许使用者自定义一些事件。</li>
</ul>
<h1 id="二、DOM事件流"><a href="#二、DOM事件流" class="headerlink" title="二、DOM事件流"></a>二、DOM事件流</h1><p>事件流(Event Flow)指的就是「<strong>网页元素接收事件的顺序</strong>」。事件流可以分成两种机制：</p>
<ul>
<li>事件捕获(Event Capturing)</li>
<li>事件冒泡(Event Bubbling)</li>
</ul>
<p>当一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段：</p>
<ul>
<li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li>
<li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）。</li>
<li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li>
</ul>
<p>接着就来分别介绍事件捕获和事件冒泡这两种机制。</p>
<h2 id="事件捕获-Event-Capturing"><a href="#事件捕获-Event-Capturing" class="headerlink" title="事件捕获(Event Capturing)"></a>事件捕获(Event Capturing)</h2><p>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;div&gt;</code>节点之中有一个<code>&lt;p&gt;</code>节点。</p>
<p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和冒泡阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code>&lt;p&gt;</code>点击，<code>click</code>事件会触发四次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phases = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;capture&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">&#x27;bubble&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">true</span>);</span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">true</span>);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>);</span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.currentTarget.tagName;</span><br><span class="line">  <span class="keyword">var</span> phase = phases[event.eventPhase];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Tag: &#x27;&quot;</span> + tag + <span class="string">&quot;&#x27;. EventPhase: &#x27;&quot;</span> + phase + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击以后的结果</span></span><br><span class="line"><span class="comment">// Tag: &#x27;DIV&#x27;. EventPhase: &#x27;capture&#x27;</span></span><br><span class="line"><span class="comment">// Tag: &#x27;P&#x27;. EventPhase: &#x27;target&#x27;</span></span><br><span class="line"><span class="comment">// Tag: &#x27;P&#x27;. EventPhase: &#x27;target&#x27;</span></span><br><span class="line"><span class="comment">// Tag: &#x27;DIV&#x27;. EventPhase: &#x27;bubble&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>click</code>事件被触发了四次：<code>&lt;div&gt;</code>节点的捕获阶段和冒泡阶段各1次，<code>&lt;p&gt;</code>节点的目标阶段触发了2次。</p>
<ol>
<li>捕获阶段：事件从<code>&lt;div&gt;</code>向<code>&lt;p&gt;</code>传播时，触发<code>&lt;div&gt;</code>的<code>click</code>事件；</li>
<li>目标阶段：事件从<code>&lt;div&gt;</code>到达<code>&lt;p&gt;</code>时，触发<code>&lt;p&gt;</code>的<code>click</code>事件；</li>
<li>冒泡阶段：事件从<code>&lt;p&gt;</code>传回<code>&lt;div&gt;</code>时，再次触发<code>&lt;div&gt;</code>的<code>click</code>事件。</li>
</ol>
<p>其中，<code>&lt;p&gt;</code>节点有两个监听函数（<code>addEventListener</code>方法第三个参数的不同，会导致绑定两个监听函数），因此它们都会因为<code>click</code>事件触发一次。所以，<code>&lt;p&gt;</code>会在<code>target</code>阶段有两次输出。</p>
<p>注意，浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点（本例是<code>&lt;div&gt;</code>节点里面的<code>&lt;p&gt;</code>节点）。所以，<code>&lt;p&gt;</code>节点的捕获阶段和冒泡阶段，都会显示为<code>target</code>阶段。</p>
<p>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</p>
<h2 id="事件冒泡-Event-Bubbling"><a href="#事件冒泡-Event-Bubbling" class="headerlink" title="事件冒泡(Event Bubbling)"></a>事件冒泡(Event Bubbling)</h2><p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112052253243.png" alt="img"></p>
<p>刚刚说过「事件捕获」机制是由上往下来传递，那么「事件冒泡」(Event Bubbling) 机制则正好相反。</p>
<p>假设HTML 同样如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>米淇淋是个大帅哥<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设我们点击(click)了<code>&lt;div&gt;点我&lt;/div&gt;</code>元素，那么在「事件冒泡」的机制下，触发事件的顺序会是：</p>
<ol>
<li><code>&lt;div&gt;点我&lt;/div&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>document</code></li>
</ol>
<p>像这样<code>click</code>事件逐层向上依序被触发，就是「事件冒泡」机制。</p>
<p>既然事件传递顺序有这两种机制，那<strong>我怎么知道事件是依据哪种机制</strong>执行的呢？</p>
<p>答案是：两种都会执行。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112052253936.jpeg" alt="img"></p>
<p>假设现在的事件是点击上图中蓝色的<code>&lt;td&gt;</code>。</p>
<p>那么当td的<code>click</code>事件发生时，会先走红色的「capture phase」：</p>
<ol>
<li><code>Document</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;table&gt;</code></li>
<li><code>&lt;tbody&gt;</code></li>
<li><code>&lt;tr&gt;</code></li>
<li><code>&lt;td&gt;</code> (实际被点击的元素)</li>
</ol>
<p>由上而下依序触发它们的<code>click</code>事件。</p>
<p>然后到达「Target phase」后再继续执行绿色的「bubble phase」，反方向由<code>&lt;td&gt;</code>一路往上传至<code>Document</code>，整个事件流到此结束。</p>
<p>要检验事件流，我们可以通过<code>addEventListener()</code>方法来绑定<code>click</code>事件：</p>
<p>假设HTML 如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    父元素</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span>子元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;parent&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;child&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 addEventListener 指定事件的绑定</span></span><br><span class="line"><span class="comment">// 第三个参数 true / false 分別代表 捕获/ 冒泡 机制</span></span><br><span class="line"></span><br><span class="line">parent.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Parent Capturing&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">parent.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Parent Bubbling&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Child Capturing&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Child Bubbling&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>当我点击的是「子元素」的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Parent Capturing&quot;</span></span><br><span class="line"><span class="string">&quot;Child Capturing&quot;</span></span><br><span class="line"><span class="string">&quot;Child Bubbling&quot;</span></span><br><span class="line"><span class="string">&quot;Parent Bubbling&quot;</span></span><br></pre></td></tr></table></figure>

<p>而如果直接点击「父元素」，则出现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Parent Capturing&quot;</span></span><br><span class="line"><span class="string">&quot;Parent Bubbling&quot;</span></span><br></pre></td></tr></table></figure>

<p>由此可知，点击子元素的时候，父层的<code>Capturing</code>会先被触发，然后再到子层内部的<code>Capturing</code>或<code>Bubbling</code>事件。最后才又回到父层的<code>Bubbling</code>结束。点击父元素的时候，不会经过子元素，子层的<code>Capturing</code>和<code>Bubbling</code>都不会触发。</p>
<p>那么，子层中的<code>Capturing</code>或<code>Bubbling</code>谁先谁后呢？要看你代码的顺序而定：</p>
<p>若是<code>Capturing</code>在<code>Bubbling</code>前面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">child.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Child Capturing&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Child Bubbling&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>则会得到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Child Capturing&quot;</span></span><br><span class="line"><span class="string">&quot;Child Bubbling&quot;</span></span><br></pre></td></tr></table></figure>

<p>若是将两段代码段顺序反过来的话，就会是这样了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">child.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Child Bubbling&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Child Capturing&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>则会得到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Child Bubbling&quot;</span></span><br><span class="line"><span class="string">&quot;Child Capturing&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="通过DOM-2级事件进行事件监听"><a href="#通过DOM-2级事件进行事件监听" class="headerlink" title="通过DOM 2级事件进行事件监听"></a>通过DOM 2级事件进行事件监听</h2><p><code>addEventListener()</code>基本上有三个参数，分别是「事件名称」、「事件的处理程序」(事件触发时执行的<code>function</code>)，以及一个「Boolean」值，由这个Boolean决定事件是以「<strong>true</strong>捕获」还是「<strong>false</strong>冒泡」机制执行，若不指定则预设为「冒泡」。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// JavaScript</span><br><span class="line">var btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function()&#123;</span><br><span class="line">  console.log(&#x27;HI&#x27;);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>使用这种方式来注册事件的好处是：同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;HELLO&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>点击后<code>console</code>出现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;HI&quot;</span></span><br><span class="line"><span class="string">&quot;HELLO&quot;</span></span><br></pre></td></tr></table></figure>

<p>若要解除事件的监听，则是通过<code>removeEventListener()</code>来取消。</p>
<p><code>removeEventListener()</code>的三个参数与<code>addEventListener()</code>一样，分别是「事件名称」、「事件的处理程序」以及代表「捕获」或「冒泡」机制的「Boolean」值。</p>
<p>但是需要注意的是，由于<code>addEventListener()</code>可以同时针对某个事件绑定多个函数，所以通过<code>removeEventListener()</code>解除事件的时候，第二个参数的函数必须要与先前在<code>addEventListener()</code>绑定的函数是同一个「实体」。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件，但是没用</span></span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>像上面这样，即使执行了<code>removeEventListener</code>来移除事件，但<code>click</code>时仍会出现’HI’。因为<code>addEventListener</code>与<code>removeEventListener</code>所移除的函数实际上是两个不同实体的function对象。</p>
<p>不知道为什么这两个function是两个不同实体的朋友请参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MzExNDY2NQ==">《JavaScript系列之内存空间》</span>。简单理解就是两个function指向不同的内存地址，代表来自于不同实体。</p>
<p>稍加改进后就能如愿移除了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 event 函数程序拉出來</span></span><br><span class="line"><span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;HI&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, clickHandler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除 clickHandler， ok!</span></span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, clickHandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h1 id="三、Event-接口：所有事件的祖先"><a href="#三、Event-接口：所有事件的祖先" class="headerlink" title="三、Event 接口：所有事件的祖先"></a>三、Event 接口：所有事件的祖先</h1><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，<strong>⭐所有的事件都是这个对象的实例</strong>，或者说继承了<code>Event.prototype</code>对象。</p>
<p>意思就是其他事件都继承了这个接口，其他事件的实例都会继承Event的属性。</p>
<h2 id="Event-接口构造函数"><a href="#Event-接口构造函数" class="headerlink" title="Event 接口构造函数"></a>Event 接口构造函数</h2><p><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event = <span class="keyword">new</span> Event(type, options);</span><br></pre></td></tr></table></figure>

<p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p>
<ul>
<li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</li>
<li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = <span class="keyword">new</span> Event(</span><br><span class="line">  <span class="string">&#x27;look&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(ev);</span><br></pre></td></tr></table></figure>

<p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p>
<p>注意，如果不是显式指定<code>bubbles</code>属性为<code>true</code>，生成的事件就只能在“捕获阶段”触发监听函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.currentTarget.tagName;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Tag: &#x27;</span> + tag); <span class="comment">// 没有任何输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, callback, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> click = <span class="keyword">new</span> Event(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">p.dispatchEvent(click);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。</p>
<p>另一方面，如果这个事件在<code>div</code>元素上触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.dispatchEvent(click);</span><br></pre></td></tr></table></figure>

<p>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</p>
<h2 id="Event-接口实例属性"><a href="#Event-接口实例属性" class="headerlink" title="Event 接口实例属性"></a>Event 接口实例属性</h2><ul>
<li><p><code>Event.bubbles</code>：返回一个布尔值,表明当前事件是否会向DOM树上层元素冒泡。</p>
</li>
<li><p><code>Event.eventPhase</code>：返回一个整数常量，表示事件目前所处的阶段。该属性只读。</p>
<ul>
<li>0，事件目前没有发生。</li>
<li>1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li>
<li>2，事件到达目标节点，即<code>Event.target</code>属性指向的那个节点。</li>
<li>3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li>
</ul>
</li>
<li><p><code>Event.cancelable</code>：返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p>
<ul>
<li>大多数浏览器的原生事件是可以取消的。比如，取消<code>click</code>事件，点击链接将无效。但是除非显式声明，<code>Event</code>构造函数生成的事件，默认是不可以取消的。</li>
<li>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</li>
</ul>
</li>
<li><p><code>Event.cancelBubble</code>（🚮废弃）：一个布尔值， <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation"><code>Event.stopPropagation()</code></a>的一个曾用名，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以阻止事件的传播。</p>
</li>
<li><p><code>Event.defaultPrevented</code>：返回一个布尔值，表示该事件是否调用过<code>Event.preventDefault</code>方法。该属性只读。</p>
</li>
<li><p><code>Event.currentTarget</code>：返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。<strong>随着事件的传播，这个属性的值会变</strong>。</p>
</li>
<li><p><code>⭐Event.target</code> ：返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</p>
</li>
<li><p><code>Event.type</code>：返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。</p>
<ul>
<li>```js<br>var evt = new Event(‘foo’);<br>evt.type // “foo”<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `Event.timeStamp`：返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    //计算鼠标移动速度的例子，显示每秒移动的像素数量。</span><br><span class="line">    var previousX;</span><br><span class="line">    var previousY;</span><br><span class="line">    var previousT;</span><br><span class="line">    </span><br><span class="line">    window.addEventListener(&#x27;mousemove&#x27;, function(event) &#123;</span><br><span class="line">      if (</span><br><span class="line">        previousX !== undefined &amp;&amp;</span><br><span class="line">        previousY !== undefined &amp;&amp;</span><br><span class="line">        previousT !== undefined</span><br><span class="line">      ) &#123;</span><br><span class="line">        var deltaX = event.screenX - previousX;</span><br><span class="line">        var deltaY = event.screenY - previousY;</span><br><span class="line">        var deltaD = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));</span><br><span class="line">    </span><br><span class="line">        var deltaT = event.timeStamp - previousT;</span><br><span class="line">        console.log(deltaD / deltaT * 1000);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      previousX = event.screenX;</span><br><span class="line">      previousY = event.screenY;</span><br><span class="line">      previousT = event.timeStamp;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>Event.isTrusted</code>：返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p>
<ul>
<li>```js<br>var evt = new Event(‘foo’);<br>evt.isTrusted // false<br>//上面代码中，evt对象是脚本产生的，所以isTrusted属性返回false<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `Event.detail`：返回一个数值，表示事件的某种信息。具体含义与事件类型相关。例如</span><br><span class="line"></span><br><span class="line">  - 对于`click`和`dblclick`事件，`Event.detail`是鼠标按下的次数（`1`表示单击，`2`表示双击，`3`表示三击）</span><br><span class="line">  - 对于鼠标滚轮事件，`Event.detail`是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</span><br><span class="line"></span><br><span class="line">## Event 接口实例方法</span><br><span class="line"></span><br><span class="line">- Event.preventDefault方法：取消浏览器对当前事件的默认行为。该方法生效的前提是，事件对象的`cancelable`属性为`true`，如果为`false`，调用该方法没有任何效果。</span><br><span class="line"></span><br><span class="line">- `Event.stopPropagation`方法：阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</span><br><span class="line"></span><br><span class="line">- `Event.stopImmediatePropagation`方法：阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比`Event.stopPropagation()`更彻底。</span><br><span class="line"></span><br><span class="line">- `Event.composedPath()`方法：返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  // HTML 代码如下</span><br><span class="line">  // &lt;div&gt;</span><br><span class="line">  //   &lt;p&gt;Hello&lt;/p&gt;</span><br><span class="line">  // &lt;/div&gt;</span><br><span class="line">  var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">  var p = document.querySelector(&#x27;p&#x27;);</span><br><span class="line">  </span><br><span class="line">  div.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    console.log(e.composedPath());</span><br><span class="line">  &#125;, false);</span><br><span class="line">  // [p, div, body, html, document, Window]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="四、UIEvent-接口：很多事件的父亲"><a href="#四、UIEvent-接口：很多事件的父亲" class="headerlink" title="四、UIEvent 接口：很多事件的父亲"></a>四、UIEvent 接口：很多事件的父亲</h1><p> <code>UIEvent</code> 接口表示简单的用户界面事件。</p>
<p>尽管 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/initUIEvent"><code>UIEvent.initUIEvent()</code> (en-US)</a> 方法为了向后兼容而一直保留着，但是你应该使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/UIEvent/UIEvent"><code>UIEvent()</code></a> 构造器来创建 <code>UIEvent</code> 对象。</p>
<p><strong><code>UIEvent </code>接口继承了<code>Event</code>接口，所以拥有<code>Event</code>的所有属性和方法，并且还提供UIEvent 独有的属性和方法</strong>。</p>
<p>某些接口是这个的直接或间接后代⭐：</p>
<ul>
<li>鼠标事件和鼠标滚轮事件：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent"><code>MouseEvent</code></a> 、 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/WheelEvent"><code>WheelEvent</code></a></li>
<li>键盘事件： <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent"><code>KeyboardEvent</code></a>  </li>
<li>表单事件： <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/InputEvent"><code>InputEvent</code></a></li>
<li>触摸事件： <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/TouchEvent"><code>TouchEvent</code></a></li>
<li>焦点事件： <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/FocusEvent"><code>FocusEvent</code></a></li>
<li>用户间接输入文本（如使用输入法）时发生的事件：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/CompositionEvent"><code>CompositionEvent</code></a></li>
</ul>
<h2 id="UIEvent-构造函数"><a href="#UIEvent-构造函数" class="headerlink" title="UIEvent 构造函数"></a>UIEvent 构造函数</h2><p>详细查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/UIEvent"><code>UIEvent</code></a> </p>
<h2 id="UIEvent-实例属性"><a href="#UIEvent-实例属性" class="headerlink" title="UIEvent 实例属性"></a>UIEvent 实例属性</h2><p>详细查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/UIEvent"><code>UIEvent</code></a> </p>
<h2 id="UIEvent-实例方法"><a href="#UIEvent-实例方法" class="headerlink" title="UIEvent 实例方法"></a>UIEvent 实例方法</h2><p>详细查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/UIEvent"><code>UIEvent</code></a> </p>
<h1 id="五、GlobalEventHandlers-接口：DOM0级事件来源"><a href="#五、GlobalEventHandlers-接口：DOM0级事件来源" class="headerlink" title="五、GlobalEventHandlers 接口：DOM0级事件来源"></a>五、GlobalEventHandlers 接口：DOM0级事件来源</h1><p>指定事件的回调函数，推荐使用的方法是元素的<code>addEventListener</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, clickHandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>除了之外，还有一种方法可以直接指定事件的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.onclick = clickHandler;</span><br></pre></td></tr></table></figure>

<p><strong>这个接口是由<code>GlobalEventHandlers</code>接口提供的。</strong>也就是说一个DOM元素会<em>继承自父接口</em><em><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element"><code>Element</code></a>和</em> *<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers"><code>GlobalEventHandlers</code></a><em><em>的属性</em> ，该DOM元素的onxxx方法都是由GlobalEventHandlers 接口提供的，即</em>*DOM0级事件由该接口实现**。</p>
<p>它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。</p>
<p><code>HTMLElement</code>、<code>Document</code>和<code>Window</code>都继承了这个接口，也就是说，各种 HTML 元素、<code>document</code>对象、<code>window</code>对象上面都可以使用<code>GlobalEventHandlers</code>接口提供的属性。</p>
<p>详细更多可以查看<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0dsb2JhbEV2ZW50SGFuZGxlcnM=">MDN——GlobalEventHandlers</span></p>
<h1 id="六、鼠标事件"><a href="#六、鼠标事件" class="headerlink" title="六、鼠标事件"></a>六、鼠标事件</h1><h2 id="MouseEvent接口"><a href="#MouseEvent接口" class="headerlink" title="MouseEvent接口"></a>MouseEvent接口</h2><p><code>MouseEvent</code>接口代表了鼠标相关的事件，单击（click）、双击（dblclick）、松开鼠标键（mouseup）、按下鼠标键（mousedown）等动作，所产生的事件对象都是<code>MouseEvent</code>实例。此外，滚轮事件和拖拉事件也是<code>MouseEvent</code>实例。</p>
<p><strong><code>MouseEvent</code>接口继承了<code>Event</code>接口，所以拥有<code>Event</code>的所有属性和方法，并且还提供鼠标独有的属性和方法</strong>。</p>
<h3 id="MouseEvent构造函数"><a href="#MouseEvent构造函数" class="headerlink" title="MouseEvent构造函数"></a>MouseEvent构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(type, options);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simulateClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(<span class="string">&#x27;click&#x27;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> cb = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;checkbox&#x27;</span>);</span><br><span class="line">  cb.dispatchEvent(event);<span class="comment">// 给cb派发、触发一个事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MouseEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件名称；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口的实例配置属性，该对象可以配置以下属性，所有属性都是可选的。</p>
<ul>
<li><code>screenX</code>：数值，鼠标相对于屏幕的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>screenY</code>：数值，鼠标相对于屏幕的垂直位置（单位像素），其他与<code>screenX</code>相同。</li>
<li><code>clientX</code>：数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</li>
<li><code>clientY</code>：数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与<code>clientX</code>相同。</li>
<li><code>ctrlKey</code>：布尔值，是否同时按下了 Ctrl 键，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否同时按下了 Shift 键，默认值为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否同时按下 Alt 键，默认值为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否同时按下 Meta 键，默认值为<code>false</code>。</li>
<li><code>button</code>：数值，表示按下了哪一个鼠标按键，默认值为<code>0</code>，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；<code>1</code>表示按下辅助键（通常是鼠标的中间键），<code>2</code>表示按下次要键（通常是鼠标的右键）。</li>
<li><code>buttons</code>：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为<code>0</code>（没有按下任何键）。<code>1</code>（二进制<code>001</code>）表示按下主键（通常是左键），<code>2</code>（二进制<code>010</code>）表示按下次要键（通常是右键），<code>4</code>（二进制<code>100</code>）表示按下辅助键（通常是中间键）。因此，如果返回<code>3</code>（二进制<code>011</code>）就表示同时按下了左键和右键。</li>
<li><code>relatedTarget</code>：节点对象，表示事件的相关节点，默认为<code>null</code>。<code>mouseenter</code>和<code>mouseover</code>事件时，表示鼠标刚刚离开的那个元素节点；<code>mouseout</code>和<code>mouseleave</code>事件时，表示鼠标正在进入的那个元素节点。</li>
</ul>
<h3 id="MouseEvent实例属性"><a href="#MouseEvent实例属性" class="headerlink" title="MouseEvent实例属性"></a>MouseEvent实例属性</h3><ul>
<li><p><code>MouseEvent.altKey，MouseEvent.ctrlKey，MouseEvent.metaKey，MouseEvent.shiftKey</code>：返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。</p>
<ul>
<li><code>altKey</code>属性：Alt 键</li>
<li><code>ctrlKey</code>属性：Ctrl 键</li>
<li><code>metaKey</code>属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）</li>
<li><code>shiftKey</code>属性：Shift 键</li>
</ul>
</li>
<li><p><code>MouseEvent.button</code>：返回一个数值，表示<strong>事件发生时按下了鼠标的哪个键</strong>。该属性只读。</p>
<ul>
<li>0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如<code>mousemove</code>事件）。</li>
<li>1：按下辅助键（通常是中键或者滚轮键）。</li>
<li>2：按下次键（通常是右键）。</li>
</ul>
</li>
<li><p><code>MouseEvent.buttons</code>：返回一个三个比特位的值，表示同时按下了哪些键。</p>
<ul>
<li>1：二进制为<code>001</code>（十进制的1），表示按下左键。</li>
<li>2：二进制为<code>010</code>（十进制的2），表示按下右键。</li>
<li>4：二进制为<code>100</code>（十进制的4），表示按下中键或滚轮键。</li>
</ul>
</li>
<li><p><code>MouseEvent.clientX，MouseEvent.clientY</code>：前者返回鼠标位置<strong>相对于浏览器窗口左上角</strong>的水平坐标（单位像素），<code>MouseEvent.clientY</code>属性返回垂直坐标。这两个属性都是只读属性。</p>
</li>
<li><p><code>MouseEvent.movementX</code>：返回当前位置与上一个<code>mousemove</code>事件之间的水平距离（单位像素）</p>
<ul>
<li>```js<br>currentEvent.movementX = currentEvent.screenX - previousEvent.screenX<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `MouseEvent.movementX`：返回当前位置与上一个`mousemove`事件之间的垂直距离（单位像素）</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    currentEvent.movementY = currentEvent.screenY - previousEvent.screenY。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>MouseEvent.screenX，MouseEvent.screenY</code>：前者返回鼠标位置<strong>相对于屏幕左上角</strong>的水平坐标（单位像素），后者返回垂直坐标。这两个属性都是只读属性。</p>
</li>
<li><p><code>MouseEvent.offsetX，MouseEvent.offsetY</code>：<code>MouseEvent.offsetX</code>属性返回鼠标位置<strong>与目标节点左侧的<code>padding</code>边缘</strong>的水平距离（单位像素），<code>MouseEvent.offsetY</code>属性返回<strong>与目标节点上方的<code>padding</code>边缘</strong>的垂直距离。这两个属性都是只读属性。</p>
</li>
<li><p><code>MouseEvent.pageX，MouseEvent.pageY</code>：<code>MouseEvent.pageX</code>属性返回鼠标位置<strong>与文档左侧边缘</strong>的距离（单位像素），<code>MouseEvent.pageY</code>属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。这两个属性都是只读。</p>
</li>
<li><p><code>MouseEvent.relatedTarget</code>：返回事件的相关节点。对于那些没有相关节点的事件，该属性返回<code>null</code>。该属性只读。</p>
</li>
</ul>
<h3 id="MouseEvent实例方法"><a href="#MouseEvent实例方法" class="headerlink" title="MouseEvent实例方法"></a>MouseEvent实例方法</h3><p><code>MouseEvent.getModifierState</code>方法返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQvZ2V0TW9kaWZpZXJTdGF0ZSNNb2RpZmllcl9rZXlzX29uX0dlY2tv">功能键</span>的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.getModifierState(<span class="string">&#x27;CapsLock&#x27;</span>));</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面的代码可以了解用户是否按下了大写键。</p>
<h2 id="鼠标事件的种类"><a href="#鼠标事件的种类" class="headerlink" title="鼠标事件的种类"></a>鼠标事件的种类</h2><p>鼠标事件主要有下面这些，<strong>所有事件都继承了<code>MouseEvent</code>接口</strong>。</p>
<h3 id="（1）点击事件"><a href="#（1）点击事件" class="headerlink" title="（1）点击事件"></a>（1）点击事件</h3><p>鼠标点击相关的有四个事件。</p>
<ul>
<li><code>click</code>：按下鼠标（通常是按下主按钮）时触发。</li>
<li><code>dblclick</code>：在同一个元素上双击鼠标时触发。</li>
<li><code>mousedown</code>：按下鼠标键时触发。</li>
<li><code>mouseup</code>：释放按下的鼠标键时触发。</li>
</ul>
<p><code>click</code>事件可以看成是两个事件组成的：用户在同一个位置先触发<code>mousedown</code>，再触发<code>mouseup</code>。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p>
<p>双击时，<code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p>
<h3 id="（2）移动事件"><a href="#（2）移动事件" class="headerlink" title="（2）移动事件"></a>（2）移动事件</h3><p>鼠标移动相关的有五个事件。</p>
<ul>
<li><code>mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li>
<li><code>mouseenter</code>：鼠标进入一个节点时触发，进入<strong>子节点不会触发</strong>这个事件（详见后文）。</li>
<li><code>mouseover</code>：鼠标进入一个节点时触发，进入<strong>子节点会再一次触发</strong>这个事件（详见后文）。</li>
<li><code>mouseout</code>：鼠标离开一个节点时触发，<strong>离开父节点也会触发</strong>这个事件（详见后文）。</li>
<li><code>mouseleave</code>：鼠标离开一个节点时触发，<strong>离开父节点不会触发</strong>这个事件（详见后文）。</li>
</ul>
<p>注意⭐：<code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，mouseenter 事件只会触发一次</span></span><br><span class="line"><span class="comment">// 以后只要鼠标在节点内移动，都不会再触发这个事件</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 ul 节点以后，只要在子节点上移动，mouseover 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，在父节点内部进入子节点，不会触发<code>mouseenter</code>事件，但是会触发<code>mouseover</code>事件。</p>
<p><code>mouseout</code>事件和<code>mouseleave</code>事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，<code>mouseleave</code>事件不会触发，而<code>mouseout</code>事件会触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">   &lt;li&gt;item 3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，不会触发 mouseleave 事件</span></span><br><span class="line"><span class="comment">// 只有离开 ul 节点时，触发一次 mouseleave</span></span><br><span class="line"><span class="comment">// event.target 是 ul 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseleave&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进入 ul 节点，然后在节点内部移动，mouseout 事件会触发多次</span></span><br><span class="line"><span class="comment">// event.target 是 li 节点</span></span><br><span class="line">ul.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.color = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.target.style.color = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，在父节点内部离开子节点，不会触发<code>mouseleave</code>事件，但是会触发<code>mouseout</code>事件。</p>
<h3 id="（3）其他事件"><a href="#（3）其他事件" class="headerlink" title="（3）其他事件"></a>（3）其他事件</h3><ul>
<li><code>contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文”菜单键时触发。</li>
<li><code>wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。</li>
</ul>
<h2 id="WheelEvent接口"><a href="#WheelEvent接口" class="headerlink" title="WheelEvent接口"></a>WheelEvent接口</h2><p><strong>该接口继承了<code>Event</code>接口、<code>UIEvent</code>接口和<code>MouseEvent</code>接口，所以拥有<code>Event</code>、<code>UIEvent</code>和<code>MouseEvent</code>的所有属性和方法，并且还提供自己独有的属性和方法</strong>。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202112171718231.png" alt="image-20211217171824128"></p>
<p>WheelEvent 接口代表鼠标滚轮事件的实例对象。目前，鼠标滚轮相关的事件只有一个<code>wheel</code>事件，用户滚动鼠标的滚轮，就生成这个事件的实例。</p>
<blockquote>
<p><strong>不要混淆 <code>wheel</code> 事件和 <code>scroll (en-US)</code> 事件：</strong><code>wheel (en-US)</code> 事件的默认动作取决于浏览器实现。因此 <code>wheel</code> 事件不一定会触发 <code>scroll (en-US)</code> 事件。即便滚轮事件引发了文档内容的滚动行为，也不表示 <code>wheel</code> 事件中的 <code>delta*</code> 值恰好反映文档内容的滚动方向。因此，不要依赖 <code>delta*</code> 属性获知文档内容的滚动方向。可在文档内容滚动事件（<code>scroll (en-US)</code>）中监视target的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollLeft"><code>scrollLeft</code></a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop"><code>scrollTop</code></a>的变化以推断滚动方向。</p>
</blockquote>
<h3 id="WheelEvent构造函数"><a href="#WheelEvent构造函数" class="headerlink" title="WheelEvent构造函数"></a>WheelEvent构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wheelEvent = <span class="keyword">new</span> WheelEvent(type, options);</span><br></pre></td></tr></table></figure>

<ul>
<li>type：表示事件类型，对于滚轮事件来说，这个值目前只能是<code>wheel</code></li>
<li>options：事件的配置对象。该对象的属性除了<code>Event</code>、<code>UIEvent</code>的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。<ul>
<li><code>deltaX</code>：数值，表示滚轮的水平滚动量，默认值是 0.0。</li>
<li><code>deltaY</code>：数值，表示滚轮的垂直滚动量，默认值是 0.0。</li>
<li><code>deltaZ</code>：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。</li>
<li><code>deltaMode</code>：数值，表示相关的滚动事件的单位，适用于上面三个属性。<code>0</code>表示滚动单位为像素，<code>1</code>表示单位为行，<code>2</code>表示单位为页，默认为<code>0</code>。</li>
</ul>
</li>
</ul>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p><code>WheelEvent</code>事件实例除了具有<code>Event</code>和<code>MouseEvent</code>的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</p>
<p>下面的属性都是只读属性。</p>
<ul>
<li><code>WheelEvent.deltaX</code>：数值，表示滚轮的水平滚动量。</li>
<li><code>WheelEvent.deltaY</code>：数值，表示滚轮的垂直滚动量。</li>
<li><code>WheelEvent.deltaZ</code>：数值，表示滚轮的 Z 轴滚动量。</li>
<li><code>WheelEvent.deltaMode</code>：数值，表示上面三个属性的单位，<code>0</code>是像素，<code>1</code>是行，<code>2</code>是页。</li>
</ul>
<h1 id="七、键盘事件"><a href="#七、键盘事件" class="headerlink" title="七、键盘事件"></a>七、键盘事件</h1><h2 id="KeyboardEvent-接口"><a href="#KeyboardEvent-接口" class="headerlink" title="KeyboardEvent 接口"></a>KeyboardEvent 接口</h2><p><strong><code>KeyboardEvent </code>接口继承了<code>Event</code>接口，所以拥有<code>Event</code>的所有属性和方法，并且还提供自己独有的属性和方法</strong>。</p>
<p><code>KeyboardEvent</code>接口用来描述用户与键盘的互动。</p>
<h3 id="KeyboardEvent-接口的构造函数"><a href="#KeyboardEvent-接口的构造函数" class="headerlink" title="KeyboardEvent 接口的构造函数"></a>KeyboardEvent 接口的构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> KeyboardEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>KeyboardEvent</code>构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了<code>Event</code>接口提供的属性，还可以配置以下字段，它们都是可选。</p>
<ul>
<li><code>key</code>：字符串，当前按下的键，默认为空字符串。</li>
<li><code>code</code>：字符串，表示当前按下的键的字符串形式，默认为空字符串。</li>
<li><code>location</code>：整数，当前按下的键的位置，默认为<code>0</code>。</li>
<li><code>ctrlKey</code>：布尔值，是否按下 Ctrl 键，默认为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，是否按下 Shift 键，默认为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，是否按下 Alt 键，默认为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，是否按下 Meta 键，默认为<code>false</code>。</li>
<li><code>repeat</code>：布尔值，是否重复按键，默认为<code>false</code>。</li>
</ul>
<h3 id="KeyboardEvent-接口的实例属性"><a href="#KeyboardEvent-接口的实例属性" class="headerlink" title="KeyboardEvent 接口的实例属性"></a>KeyboardEvent 接口的实例属性</h3><ul>
<li><code>KeyboardEvent.altKey，KeyboardEvent.ctrlKey，KeyboardEvent.metaKey，KeyboardEvent.shiftKey</code>：返回一个布尔值，表示是否按下对应的键，其中 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）。</li>
<li><code>KeyboardEvent.code</code>属性：返回一个字符串，表示当前按下的键的字符串形式。该属性只读。下面是一些常用键的字符串形式，其他键请查<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQvY29kZS9jb2RlX3ZhbHVlcw==">文档</span><ul>
<li>数字键0 - 9：返回<code>digit0</code> - <code>digit9</code></li>
<li>字母键A - z：返回<code>KeyA</code> - <code>KeyZ</code></li>
<li>功能键F1 - F12：返回 <code>F1</code> - <code>F12</code></li>
<li>方向键：返回<code>ArrowDown</code>、<code>ArrowUp</code>、<code>ArrowLeft</code>、<code>ArrowRight</code></li>
<li>Alt 键：返回<code>AltLeft</code>或<code>AltRight</code></li>
<li>Shift 键：返回<code>ShiftLeft</code>或<code>ShiftRight</code></li>
<li>Ctrl 键：返回<code>ControlLeft</code>或<code>ControlRight</code></li>
</ul>
</li>
<li><code>KeyboardEvent.key</code>属性：返回一个字符串，表示按下的键名。</li>
<li><code>KeyboardEvent.location</code>属性：返回一个整数，表示按下的键处在键盘的哪一个区域。它可能取以下值。<ul>
<li>0：处在键盘的主区域，或者无法判断处于哪一个区域。</li>
<li>1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</li>
<li>2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</li>
<li>3：处在数字小键盘。</li>
</ul>
</li>
<li><code>KeyboardEvent.repeat</code>属性：</li>
</ul>
<h3 id="KeyboardEvent-接口的实例方法"><a href="#KeyboardEvent-接口的实例方法" class="headerlink" title="KeyboardEvent 接口的实例方法"></a>KeyboardEvent 接口的实例方法</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState"><code>KeyboardEvent.getModifierState()</code> (en-US)</a></p>
<p>Returns a <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a> indicating if a modifier key such as Alt, Shift, Ctrl, or Meta, was pressed when the event was created.</p>
<h2 id="键盘事件的种类"><a href="#键盘事件的种类" class="headerlink" title="键盘事件的种类"></a>键盘事件的种类</h2><p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p>
<ul>
<li><code>keydown</code>：按下键盘时触发。</li>
<li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code>keydown</code>事件，再触发这个事件。</li>
<li><code>keyup</code>：松开键盘时触发该事件。</li>
</ul>
<p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p>
<ol>
<li>keydown</li>
<li>keypress</li>
<li>keydown</li>
<li>keypress</li>
<li>…（重复以上过程）</li>
<li>keyup</li>
</ol>
<h1 id="八、进度事件"><a href="#八、进度事件" class="headerlink" title="八、进度事件"></a>八、进度事件</h1><h2 id="ProgressEvent-接口"><a href="#ProgressEvent-接口" class="headerlink" title="ProgressEvent 接口"></a>ProgressEvent 接口</h2><p><strong>该接口继承了<code>Event</code>接口，所以拥有<code>Event</code>的所有属性和方法，并且还提供自己独有的属性和方法</strong>。</p>
<h3 id="ProgressEvent-构造函数"><a href="#ProgressEvent-构造函数" class="headerlink" title="ProgressEvent  构造函数"></a>ProgressEvent  构造函数</h3><p>浏览器原生提供了<code>ProgressEvent()</code>构造函数，用来生成事件实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ProgressEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>ProgressEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的类型，这个参数是必须的。第二个参数是一个配置对象，表示事件的属性，该参数可选。配置对象除了可以使用<code>Event</code>接口的配置属性，还可以使用下面的属性，所有这些属性都是可选的。</p>
<ul>
<li><code>lengthComputable</code>：布尔值，表示加载的总量是否可以计算，默认是<code>false</code>。</li>
<li><code>loaded</code>：整数，表示已经加载的量，默认是<code>0</code>。</li>
<li><code>total</code>：整数，表示需要加载的总量，默认是<code>0</code>。</li>
</ul>
<p><code>ProgressEvent</code>具有对应的实例属性。</p>
<ul>
<li><code>ProgressEvent.lengthComputable</code></li>
<li><code>ProgressEvent.loaded</code></li>
<li><code>ProgressEvent.total</code></li>
</ul>
<p>如果<code>ProgressEvent.lengthComputable</code>为<code>false</code>，<code>ProgressEvent.total</code>实际上是没有意义的。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> ProgressEvent(<span class="string">&#x27;load&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">lengthComputable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">loaded</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">total</span>: <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;已经加载：&#x27;</span> + (e.loaded / e.total) * <span class="number">100</span> + <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.dispatchEvent(p);</span><br><span class="line"><span class="comment">// 已经加载：30%</span></span><br></pre></td></tr></table></figure>

<p>上面代码先构造一个<code>load</code>事件，抛出后被监听函数捕捉到。</p>
<p>下面是一个实际的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;progress&#x27;</span>, updateProgress, <span class="literal">false</span>);</span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;load&#x27;</span>, transferComplete, <span class="literal">false</span>);</span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;error&#x27;</span>, transferFailed, <span class="literal">false</span>);</span><br><span class="line">xhr.addEventListener(<span class="string">&#x27;abort&#x27;</span>, transferCanceled, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.lengthComputable) &#123;</span><br><span class="line">    <span class="keyword">var</span> percentComplete = e.loaded / e.total;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;不能计算进度&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferComplete</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;传输结束&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferFailed</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;传输过程中发生错误&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transferCanceled</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;用户取消了传输&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是下载过程的进度事件，还存在上传过程的进度事件。这时所有监听函数都要放在<code>XMLHttpRequest.upload</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;progress&#x27;</span>, updateProgress, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;load&#x27;</span>, transferComplete, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;error&#x27;</span>, transferFailed, <span class="literal">false</span>);</span><br><span class="line">xhr.upload.addEventListener(<span class="string">&#x27;abort&#x27;</span>, transferCanceled, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br></pre></td></tr></table></figure>

<h3 id="ProgressEvent-实例属性"><a href="#ProgressEvent-实例属性" class="headerlink" title="ProgressEvent 实例属性"></a>ProgressEvent 实例属性</h3><p><em>同时继承它的父元素 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a> 的属性。</em></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/ProgressEvent/lengthComputable"><code>ProgressEvent.lengthComputable</code></a> 只读</p>
<p>是一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code> (en-US)</a> 标志，表示底层流程将需要完成的总工作量和已经完成的工作量是否可以计算。换句话说，它告诉我们进度是否可以被测量。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent/loaded"><code>ProgressEvent.loaded</code> (en-US)</a> 只读</p>
<p>是一个 <code>unsigned long long</code> 类型数据，表示底层流程已经执行的工作总量。可以用这个属性和 <code>ProgressEvent.total</code> 计算工作完成比例。当使用 HTTP 下载资源，它只表示内容本身的部分，不包括首部和其它开销。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent/total"><code>ProgressEvent.total</code> (en-US)</a> 只读</p>
<p>是一个 <code>unsigned long long</code> 类型数据，表示正在执行的底层流程的工作总量。当使用 HTTP 下载资源，它只表示内容本身的部分，不包括首部和其它开销。</p>
</li>
</ul>
<h3 id="ProgressEvent-实例方法"><a href="#ProgressEvent-实例方法" class="headerlink" title="ProgressEvent 实例方法"></a>ProgressEvent 实例方法</h3><p><em>同时继承它的父元素 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a> 的方法。</em></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent/initProgressEvent"><code>ProgressEvent.initProgressEvent()</code> (en-US)</a> </p>
<p>使用被弃用的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createEvent"><code>Document.createEvent(&quot;ProgressEvent&quot;)</code></a> 方法，来初始化一个已经创建好的 <code>ProgressEvent</code>。</p>
</li>
</ul>
<h2 id="进度事件的种类"><a href="#进度事件的种类" class="headerlink" title="进度事件的种类"></a>进度事件的种类</h2><p>进度事件主要用来描述外部资源加载的进度，比如 XMLHttpRequest、<code>&lt;img&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>等外部资源加载。继承了<code>ProgressEvent</code>接口。它主要包含以下几种事件。</p>
<ul>
<li><code>abort</code>：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。</li>
<li><code>error</code>：由于错误导致外部资源无法加载时触发。</li>
<li><code>load</code>：外部资源加载成功时触发。</li>
<li><code>loadstart</code>：外部资源开始加载时触发。</li>
<li><code>loadend</code>：外部资源停止加载时触发，发生顺序排在<code>error</code>、<code>abort</code>、<code>load</code>等事件的后面。</li>
<li><code>progress</code>：外部资源加载过程中不断触发。</li>
<li><code>timeout</code>：加载超时时触发。</li>
</ul>
<p>注意，除了资源下载，文件上传也存在这些事件。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  image.classList.add(<span class="string">&#x27;finished&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">image.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  image.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码在图片元素加载完成后，为图片元素添加一个<code>finished</code>的 Class。如果加载失败，就把图片元素的样式设置为不显示。</p>
<p>有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能<code>load</code>和<code>error</code>事件的监听函数根本不会执行。所以，比较可靠的方式，是用<code>complete</code>属性先判断一下是否加载完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image.complete) &#123;</span><br><span class="line">  loaded();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  image.addEventListener(<span class="string">&#x27;load&#x27;</span>, loaded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 DOM 的元素节点没有提供是否加载错误的属性，所以<code>error</code>事件的监听函数最好放在<code>&lt;img&gt;</code>元素的 HTML 代码中，这样才能保证发生加载错误时百分之百会执行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/wrong/url&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;this.style.display=&#x27;none&#x27;;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>loadend</code>事件的监听函数，可以用来取代<code>abort</code>事件、<code>load</code>事件、<code>error</code>事件的监听函数，因为它总是在这些事件之后发生。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.addEventListener(<span class="string">&#x27;loadend&#x27;</span>, loadEnd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadEnd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;传输结束，成功失败未知&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>loadend</code>事件本身不提供关于进度结束的原因，但可以用它来做所有加载结束场景都需要做的一些操作。</p>
<p>另外，<code>error</code>事件有一个特殊的性质，就是不会冒泡。所以，子元素的<code>error</code>事件，不会触发父元素的<code>error</code>事件监听函数。</p>
<h1 id="九、表单事件"><a href="#九、表单事件" class="headerlink" title="九、表单事件"></a>九、表单事件</h1><h2 id="InputEvent接口"><a href="#InputEvent接口" class="headerlink" title="InputEvent接口"></a>InputEvent接口</h2><p><code>InputEvent</code>接口主要用来描述<code>input</code>事件的实例。</p>
<p><strong><code>InputEvent </code>接口继承了<code>Event</code>接口，所以拥有<code>Event</code>的所有属性和方法，并且还提供自己独有的属性和方法</strong>。</p>
<h3 id="InputEvent-构造函数"><a href="#InputEvent-构造函数" class="headerlink" title="InputEvent 构造函数"></a>InputEvent 构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> InputEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>InputEvent</code>构造函数可以接受两个参数。第一个参数是字符串，表示事件名称，该参数是必需的。</p>
<p>第二个参数是一个配置对象，用来设置事件实例的属性，该参数是可选的。配置对象的字段除了<code>Event</code>构造函数的配置属性，还可以设置下面的字段，这些字段都是可选的。</p>
<ul>
<li><code>inputType</code>（可选），指定可编辑内容更改类型的字符串，表示字符串发生变更的类型。对于常见情况，Chrome浏览器的返回值如下，完整列表可以参考<span class="exturl" data-url="aHR0cHM6Ly93M2MuZ2l0aHViLmlvL2lucHV0LWV2ZW50cy9pbmRleC5odG1sI2RvbS1pbnB1dGV2ZW50LWlucHV0dHlwZQ==">文档</span>。<ul>
<li>手动插入文本：<code>insertText</code></li>
<li>粘贴插入文本：<code>insertFromPaste</code></li>
<li>向后删除：<code>deleteContentBackward</code></li>
<li>向前删除：<code>deleteContentForward</code></li>
</ul>
</li>
<li><code>data</code>（可选），字符串，表示<strong>插入</strong>的字符串。如果没有插入的字符串（比如删除操作），则返回<code>null</code>或空字符串。</li>
<li><code>dataTransfer</code>（可选），一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer"><code>DataTransfer</code></a> 对象，其中包含有关添加到可编辑内容，或从可编辑内容中删除的富文本或纯文本数据的信息。<u>该属性只在文本框接受粘贴内容（insertFromPaste）或拖拽内容（<code>insertFromDrop</code>）时才有效。</u></li>
<li><code>isComposing</code>（可选），一个布尔值，指示事件是组合会话的一部分，这意味着它在 <code>compositionstart (en-US)</code> 事件之后，但在 <code>compositionend (en-US)</code> 事件之前。默认值为 <code>false</code>。</li>
<li><code>ranges</code>（可选），一个静态 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range"><code>Range</code></a> 数组，如果输入事件没有被取消，它将受到对DOM的更改的影响。</li>
</ul>
<h3 id="InputEvent-实例属性"><a href="#InputEvent-实例属性" class="headerlink" title="InputEvent 实例属性"></a>InputEvent 实例属性</h3><p>除继承自 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/UIEvent"><code>UIEvent</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a> 接口的属性外，还有以下属性：</p>
<ul>
<li><code>InputEvent.data</code>：返回当前输入的字符串，如果是删除操作，则该值为空字符串。</li>
<li><code>InputEvent.isComposing</code>：返回一个布尔值，表明该事件是在触发 <code>compositionstart (en-US)</code> 事件之后且触发 <code>compositionend (en-US)</code> 事件之前触发的，也就是表明当前输入的字符是输入法的中途输入。</li>
</ul>
<h3 id="InputEvent-实例方法"><a href="#InputEvent-实例方法" class="headerlink" title="InputEvent 实例方法"></a>InputEvent 实例方法</h3><p>除继承自 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/UIEvent"><code>UIEvent</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a> 接口的方法外，没有其它自身方法。</p>
<h2 id="表单事件的种类"><a href="#表单事件的种类" class="headerlink" title="表单事件的种类"></a>表单事件的种类</h2><h3 id="1-input事件"><a href="#1-input事件" class="headerlink" title="1.input事件"></a>1.input事件</h3><p><code>input</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。对于复选框（<code>&lt;input type=checkbox&gt;</code>）或单选框（<code>&lt;input type=radio&gt;</code>），用户改变选项时，也会触发这个事件。另外，对于打开<code>contenteditable</code>属性的元素，只要值发生变化，也会触发<code>input</code>事件。</p>
<p><code>input</code>事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次<code>input</code>事件。</p>
<p><code>input</code>事件对象继承了<code>InputEvent</code>接口。</p>
<p>该事件跟<code>change</code>事件很像，不同之处在于<code>input</code>事件在元素的值发生变化后立即发生，而<code>change</code>在元素失去焦点时发生，而内容此时可能已经变化多次。也就是说，如果有连续变化，<code>input</code>事件会触发多次，而<code>change</code>事件只在失去焦点时触发一次。</p>
<p>下面是<code>&lt;select&gt;</code>元素的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">&lt;select id=&quot;mySelect&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;</span></span><br><span class="line"><span class="comment">  &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;</span></span><br><span class="line"><span class="comment">&lt;/select&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inputHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mySelect = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#mySelect&#x27;</span>);</span><br><span class="line">mySelect.addEventListener(<span class="string">&#x27;input&#x27;</span>, inputHandler);</span><br></pre></td></tr></table></figure>

<p>上面代码中，改变下拉框选项时，会触发<code>input</code>事件，从而执行回调函数<code>inputHandler</code>。</p>
<h3 id="2-select事件"><a href="#2-select事件" class="headerlink" title="2. select事件"></a>2. select事件</h3><p><code>select</code>事件当在<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>里面选中文本时触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;input id=&quot;test&quot; type=&quot;text&quot; value=&quot;Select me!&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">elem.addEventListener(<span class="string">&#x27;select&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.type); <span class="comment">// &quot;select&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>选中的文本可以通过<code>event.target</code>元素的<code>selectionDirection</code>、<code>selectionEnd</code>、<code>selectionStart</code>和<code>value</code>属性拿到。</p>
<h3 id="3-change事件"><a href="#3-change事件" class="headerlink" title="3.change事件"></a>3.change事件</h3><p><code>change</code>事件当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code>的值发生变化时触发。它与<code>input</code>事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面<code>input</code>事件必然伴随<code>change</code>事件。具体来说，分成以下几种情况。</p>
<ul>
<li>激活单选框（radio）或复选框（checkbox）时触发。</li>
<li>用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</li>
<li>当文本框或<code>&lt;textarea&gt;</code>元素的值发生改变，并且丧失焦点时触发。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;select size=&quot;1&quot; onchange=&quot;changeEventHandler(event);&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;chocolate&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;strawberry&lt;/option&gt;</span></span><br><span class="line"><span class="comment">//   &lt;option&gt;vanilla&lt;/option&gt;</span></span><br><span class="line"><span class="comment">// &lt;/select&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeEventHandler</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果比较一下上面<code>input</code>事件的例子，你会发现对于<code>&lt;select&gt;</code>元素来说，<code>input</code>和<code>change</code>事件基本是等价的。</p>
<h3 id="4-invalid事件"><a href="#4-invalid事件" class="headerlink" title="4.invalid事件"></a>4.invalid事件</h3><p>用户提交表单时，如果表单元素的值不满足校验条件，就会触发<code>invalid</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span> <span class="attr">oninvalid</span>=<span class="string">&quot;console.log(&#x27;invalid input&#x27;)&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，输入框是必填的。如果不填，用户点击按钮提交时，就会触发输入框的<code>invalid</code>事件，导致提交被取消。</p>
<h3 id="5-reset事件、submit事件"><a href="#5-reset事件、submit事件" class="headerlink" title="5.reset事件、submit事件"></a>5.reset事件、submit事件</h3><p>这两个事件发生在表单对象<code>&lt;form&gt;</code>上，而不是发生在表单的成员上。</p>
<p><code>reset</code>事件当表单重置（所有表单成员变回默认值）时触发。</p>
<p><code>submit</code>事件当表单数据向服务器提交时触发。注意，<code>submit</code>事件的发生对象是<code>&lt;form&gt;</code>元素，而不是<code>&lt;button&gt;</code>元素，因为提交的是表单，而不是按钮。</p>
<h1 id="十、触摸事件（通常用于移动端）"><a href="#十、触摸事件（通常用于移动端）" class="headerlink" title="十、触摸事件（通常用于移动端）"></a>十、触摸事件（通常用于移动端）</h1><h2 id="触摸操作概述"><a href="#触摸操作概述" class="headerlink" title="触摸操作概述"></a>触摸操作概述</h2><p>浏览器的触摸 API 由三个部分组成。</p>
<ul>
<li>Touch：一个触摸点</li>
<li>TouchList：多个触摸点的集合</li>
<li>TouchEvent：触摸引发的事件实例</li>
</ul>
<p><code>Touch</code>接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p>
<p>很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，<strong>可以用<code>event.preventDefault</code>方法阻止发出鼠标事件</strong>。</p>
<h2 id="Touch接口"><a href="#Touch接口" class="headerlink" title="Touch接口"></a>Touch接口</h2><p>Touch 接口代表单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。</p>
<h3 id="Touch-接口构造函数"><a href="#Touch-接口构造函数" class="headerlink" title="Touch 接口构造函数"></a>Touch 接口构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> touch = <span class="keyword">new</span> Touch(touchOptions);</span><br></pre></td></tr></table></figure>

<p><code>Touch</code>构造函数接受一个配置对象作为参数，它有以下属性。</p>
<ul>
<li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li>
<li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li>
<li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li>
<li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li>
<li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li>
<li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li>
<li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li>
<li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li>
<li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li>
<li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li>
<li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li>
<li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li>
</ul>
<h3 id="Touch接口的实例属性"><a href="#Touch接口的实例属性" class="headerlink" title="Touch接口的实例属性"></a>Touch接口的实例属性</h3><p>基础属性：</p>
<ul>
<li><p><code>Touch.identifier</code>：返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">someElement.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; e.changedTouches.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.changedTouches[i].identifier);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><code>Touch.screenX</code>属性和<code>Touch.screenY</code>属性：表示触摸点相对于<strong>屏幕左上角</strong>的横坐标和纵坐标，与页面是否滚动无关。</p>
</li>
<li><p><code>Touch.clientX</code>属性和<code>Touch.clientY</code>属性：表示触摸点相对于<strong>浏览器视口左上角</strong>的横坐标和纵坐标，与页面是否滚动无关。</p>
</li>
<li><p><code>Touch.pageX</code>属性和<code>Touch.pageY</code>属性：表示触摸点相对于<strong>当前页面左上角</strong>的横坐标和纵坐标，包含了页面滚动带来的位移。</p>
</li>
</ul>
<p>触摸区域：</p>
<ul>
<li><code>Touch.radiusX</code>属性和<code>Touch.radiusY</code>属性：返回触摸点周围受到影响的<strong>椭圆范围</strong>的 X 轴<strong>半径</strong>和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度。</li>
<li><code>Touch.rotationAngle</code>：表示触摸区域的椭圆的旋转角度，单位为度数，在<code>0</code>到<code>90</code>度之间。</li>
</ul>
<p>上面这三个属性共同定义了用户与屏幕接触的区域，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。</p>
<p>下面是一个示例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, rotate);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, rotate);</span><br><span class="line">div.addEventListener(<span class="string">&#x27;touchend&#x27;</span>, rotate);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> touch = e.changedTouches.item(<span class="number">0</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  src.style.width = touch.radiusX * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  src.style.height = touch.radiusY * <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  src.style.transform = <span class="string">&#x27;rotate(&#x27;</span> + touch.rotationAngle + <span class="string">&#x27;deg)&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Touch.force</code>属性：返回一个<code>0</code>到<code>1</code>之间的数值，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力。</li>
<li><code>Touch.target</code>：返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</li>
</ul>
<h3 id="Touch接口的实例方法"><a href="#Touch接口的实例方法" class="headerlink" title="Touch接口的实例方法"></a>Touch接口的实例方法</h3><p>这个接口没有方法，也没有父类，不继承任何方法。</p>
<h2 id="TouchList接口"><a href="#TouchList接口" class="headerlink" title="TouchList接口"></a>TouchList接口</h2><p><code>TouchList</code>接口表示一组触摸点的集合。它的实例是一个类似数组的对象，成员是<code>Touch</code>的实例对象，表示所有触摸点。用户用三根手指触摸，产生的<code>TouchList</code>实例就会包含三个成员，每根手指的触摸点对应一个<code>Touch</code>实例对象。</p>
<p>它的实例主要通过触摸事件的<code>TouchEvent.touches</code>、<code>TouchEvent.changedTouches</code>、<code>TouchEvent.targetTouches</code>这几个属性获取。</p>
<p>它的实例属性和实例方法只有两个。</p>
<ul>
<li><code>TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li>
<li><code>TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li>
</ul>
<h2 id="TouchEvent接口"><a href="#TouchEvent接口" class="headerlink" title="TouchEvent接口"></a>TouchEvent接口</h2><p><strong>该接口继承了<code>Event</code>接口和<code>UIEvent</code>接口，所以拥有<code>Event</code>和<code>UIEvent</code>的所有属性和方法，并且还提供自己独有的属性和方法</strong>。</p>
<h3 id="TouchEvent构造函数"><a href="#TouchEvent构造函数" class="headerlink" title="TouchEvent构造函数"></a>TouchEvent构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> TouchEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>TouchEvent()</code>构造函数可以接受两个参数，第一个参数是字符串，表示事件类型；第二个参数是事件的配置对象，该参数是可选的，对象的所有属性也是可选的。除了<code>Event</code>接口的配置属性，该接口还有一些自己的配置属性。</p>
<ul>
<li><code>touches</code>：<code>TouchList</code>实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>targetTouches</code>：<code>TouchList</code>实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>changedTouches</code>：<code>TouchList</code>实例，代表本次触摸事件的相关触摸点，默认值是一个空数组<code>[]</code>。</li>
<li><code>ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为<code>false</code>。</li>
<li><code>metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为<code>false</code>。</li>
</ul>
<h3 id="TouchEvent实例属性"><a href="#TouchEvent实例属性" class="headerlink" title="TouchEvent实例属性"></a>TouchEvent实例属性</h3><ul>
<li><p><code>TouchEvent.altKey，TouchEvent.ctrlKey，TouchEvent.shiftKey，TouchEvent.metaKey</code>：表示触摸时是否安装下了对应的按键，Meta键在windows系统下是windows键。</p>
</li>
<li><p><code>TouchEvent.changedTouches</code>属性：</p>
</li>
<li><p>返回一个<code>TouchList</code>实例，成员是一组<code>Touch</code>实例对象，表示本次触摸事件的相关触摸点。</p>
<p>对于不同的时间，该属性的含义有所不同。</p>
<ul>
<li><code>touchstart</code>事件：被激活的触摸点</li>
<li><code>touchmove</code>事件：发生变化的触摸点</li>
<li><code>touchend</code>事件：消失的触摸点（即不再被触碰的点）</li>
</ul>
</li>
<li><p><code>TouchEvent.touches</code>属性：返回一个<code>TouchList</code>实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点，可以用来<u>判断用户同时几个手指按屏幕</u>。</p>
</li>
<li><p><code>TouchEvent.targetTouches</code>属性：返回一个<code>TouchList</code>实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否所有触摸点都在目标元素内。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">touches_in_target</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (ev.touches.length === ev.targetTouches.length ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="TouchEvent实例方法"><a href="#TouchEvent实例方法" class="headerlink" title="TouchEvent实例方法"></a>TouchEvent实例方法</h3><p>无</p>
<h2 id="触摸事件的种类"><a href="#触摸事件的种类" class="headerlink" title="触摸事件的种类"></a>触摸事件的种类</h2><p>触摸引发的事件，有以下几种。可以通过<code>TouchEvent.type</code>属性，查看到底发生的是哪一种事件。</p>
<ul>
<li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。</li>
<li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。</li>
<li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</li>
<li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;canvas&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">el.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, handleStart, <span class="literal">false</span>);</span><br><span class="line">el.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, handleMove, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStart</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.changedTouches;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(touches[i].pageX, touches[i].pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMove</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  evt.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> touches = evt.changedTouches;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> touch = touches[i];</span><br><span class="line">    <span class="built_in">console</span>.log(touch.pageX, touch.pageY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="十一、拖拉事件"><a href="#十一、拖拉事件" class="headerlink" title="十一、拖拉事件"></a>十一、拖拉事件</h1><p>拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。</p>
<h2 id="DragEvent-接口"><a href="#DragEvent-接口" class="headerlink" title="DragEvent 接口"></a>DragEvent 接口</h2><p><strong>这个接口继承 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent"><code>MouseEvent</code></a> 和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event"><code>Event</code></a>属性</strong></p>
<h3 id="DragEvent-接口的构造函数"><a href="#DragEvent-接口的构造函数" class="headerlink" title="DragEvent 接口的构造函数"></a>DragEvent 接口的构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> DragEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>DragEvent()</code>构造函数接受两个参数，第一个参数是字符串，表示事件的类型，该参数必须；第二个参数是事件的配置对象，用来设置事件的属性，该参数可选。配置对象除了接受<code>MouseEvent</code>接口和<code>Event</code>接口的配置属性，还可以设置<code>dataTransfer</code>属性要么是<code>null</code>，要么是一个<code>DataTransfer</code>接口的实例。</p>
<p><code>DataTransfer</code>的实例对象用来读写拖拉事件中传输的数据，详见下文《DataTransfer 接口》的部分。</p>
<h3 id="DragEvent-接口的实例属性"><a href="#DragEvent-接口的实例属性" class="headerlink" title="DragEvent 接口的实例属性"></a>DragEvent 接口的实例属性</h3><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DragEvent/dataTransfer"><code>DragEvent.dataTransfer</code></a> 只读，在拖放交互期间传输的数据，用来读写需要传递的数据。</li>
</ul>
<h3 id="DragEvent-接口的实例方法"><a href="#DragEvent-接口的实例方法" class="headerlink" title="DragEvent 接口的实例方法"></a>DragEvent 接口的实例方法</h3><p>详细查看<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0RyYWdFdmVudCMlRTUlODUlQTglRTUlQjElODAlRTQlQkElOEIlRTQlQkIlQjYlRTUlQTQlODQlRTclOTAlODY=">全局事件处理</span></p>
<h2 id="DataTransfer-接口"><a href="#DataTransfer-接口" class="headerlink" title="DataTransfer 接口"></a>DataTransfer 接口</h2><p>上面已经讲到了，通过DragEvent.dataTransfer可以访问到该接口的实例。</p>
<h3 id="DataTransfer-接口的构造函数"><a href="#DataTransfer-接口的构造函数" class="headerlink" title="DataTransfer 接口的构造函数"></a>DataTransfer 接口的构造函数</h3><p><code>DataTransfer()</code>构造函数不接受参数。</p>
<p>拖拉的数据分成两方面：数据的种类（又称格式）和数据的值。数据的种类是一个 MIME 字符串（比如<code>text/plain</code>、<code>image/jpeg</code>），数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的 URL。</p>
<p>拖拉事件开始时，开发者可以提供数据类型和数据值。拖拉过程中，开发者通过<code>dragenter</code>和<code>dragover</code>事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为<code>text/uri-list</code>。</p>
<p>发生<code>drop</code>事件时，监听函数取出拖拉的数据，对其进行处理。</p>
<h3 id="DataTransfer-接口的实例属性"><a href="#DataTransfer-接口的实例属性" class="headerlink" title="DataTransfer 接口的实例属性"></a>DataTransfer 接口的实例属性</h3><p><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L2V2ZW50cy9kcmFnLmh0bWwjZGF0YXRyYW5zZmVyLSVFNyU5QSU4NCVFNSVBRSU5RSVFNCVCRSU4QiVFNSVCMSU5RSVFNiU4MCVBNw==">详细查看</span></p>
<h3 id="DataTransfer-接口的实例方法"><a href="#DataTransfer-接口的实例方法" class="headerlink" title="DataTransfer 接口的实例方法"></a>DataTransfer 接口的实例方法</h3><p><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L2V2ZW50cy9kcmFnLmh0bWwjZGF0YXRyYW5zZmVyLSVFNyU5QSU4NCVFNSVBRSU5RSVFNCVCRSU4QiVFNiU5NiVCOSVFNiVCMyU5NQ==">详细查看</span></p>
<h2 id="拖拉事件的种类"><a href="#拖拉事件的种类" class="headerlink" title="拖拉事件的种类"></a>拖拉事件的种类</h2><p>拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都可以直接拖拉。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  此区域可拖拉</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>div</code>区块，在网页中可以直接用鼠标拖动。松开鼠标键时，拖动效果就会消失，该区块依然在原来的位置。</p>
<p><code>draggable</code>属性可用于任何元素节点，但是图片（<code>&lt;img&gt;</code>）和链接（<code>&lt;a&gt;</code>）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为<code>false</code>，防止拖拉这两种元素。</p>
<p>注意，一旦某个元素节点的<code>draggable</code>属性设为<code>true</code>，就无法再用鼠标选中该节点内部的文字或子节点了。</p>
<p>当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。</p>
<ul>
<li><code>drag</code>：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</li>
<li><code>dragstart</code>：用户开始拖拉时，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li>
<li><code>dragend</code>：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li>
<li><code>dragenter</code>：拖拉进入当前节点时，在当前节点上触发一次，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li>
<li><code>dragover</code>：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</li>
<li><code>dragleave</code>：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</li>
<li><code>drop</code>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li>
</ul>
<p>下面的例子展示，如何动态改变被拖动节点的背景色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">&#x27;dragend&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.style.backgroundColor = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>div</code>节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。</p>
<p>下面是一个例子，展示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;</span></span><br><span class="line"><span class="comment">   &lt;div id=&quot;draggable&quot; draggable=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">     该节点可拖拉</span></span><br><span class="line"><span class="comment">   &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment"> &lt;div class=&quot;dropzone&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被拖拉节点</span></span><br><span class="line"><span class="keyword">var</span> dragged;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存被拖拉节点</span></span><br><span class="line">  dragged = event.target;</span><br><span class="line">  <span class="comment">// 被拖拉节点的背景色变透明</span></span><br><span class="line">  event.target.style.opacity = <span class="number">0.5</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragend&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 被拖拉节点的背景色恢复正常</span></span><br><span class="line">  event.target.style.opacity = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragover&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止拖拉效果被重置，允许被拖拉的节点放入目标节点</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragenter&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 目标节点的背景色变紫色</span></span><br><span class="line">  <span class="comment">// 由于该事件会冒泡，所以要过滤节点</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.className === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    event.target.style.background = <span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;dragleave&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 目标节点的背景色恢复原样</span></span><br><span class="line">  <span class="keyword">if</span> (event.target.className === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    event.target.style.background = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;drop&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> event </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止事件默认行为（比如某些元素节点上可以打开链接），</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (event.target.className === <span class="string">&#x27;dropzone&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 恢复目标节点背景色</span></span><br><span class="line">    event.target.style.background = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 将被拖拉节点插入目标节点</span></span><br><span class="line">    dragged.parentNode.removeChild(dragged);</span><br><span class="line">    event.target.appendChild( dragged );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>关于拖拉事件，有以下几个注意点。</p>
<ul>
<li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</li>
<li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li>
<li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ondragover</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ondragover</span>=<span class="string">&quot;event.preventDefault()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不取消拖拉事件或者阻止默认行为，就不能在<code>div</code>节点上放下被拖拉的节点。</p>
<h1 id="十二、焦点事件"><a href="#十二、焦点事件" class="headerlink" title="十二、焦点事件"></a>十二、焦点事件</h1><h3 id="FocusEvent接口"><a href="#FocusEvent接口" class="headerlink" title="FocusEvent接口"></a>FocusEvent接口</h3><p>这四个事件的事件对象都继承了<code>FocusEvent</code>接口。<code>FocusEvent</code>实例具有以下属性。</p>
<ul>
<li><code>FocusEvent.target</code>：事件的目标节点。</li>
<li><code>FocusEvent.relatedTarget</code>：对于<code>focusin</code>事件，返回失去焦点的节点；对于<code>focusout</code>事件，返回将要接受焦点的节点；对于<code>focus</code>和<code>blur</code>事件，返回<code>null</code>。</li>
</ul>
<p>由于<code>focus</code>和<code>blur</code>事件不会冒泡，只能在捕获阶段触发，所以<code>addEventListener</code>方法的第三个参数需要设为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">form.addEventListener(<span class="string">&#x27;focus&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.background = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">form.addEventListener(<span class="string">&#x27;blur&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.target.style.background = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码针对表单的文本输入框，接受焦点时设置背景色，失去焦点时去除背景色。</p>
<h3 id="焦点事件的种类"><a href="#焦点事件的种类" class="headerlink" title="焦点事件的种类"></a>焦点事件的种类</h3><p>焦点事件发生在元素节点和<code>document</code>对象上面，与获得或失去焦点相关。它主要包括以下四个事件。</p>
<ul>
<li><code>focus</code>：元素节点获得焦点后触发，该事件不会冒泡。</li>
<li><code>blur</code>：元素节点失去焦点后触发，该事件不会冒泡。</li>
<li><code>focusin</code>：元素节点将要获得焦点时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li>
<li><code>focusout</code>：元素节点将要失去焦点时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li>
</ul>
<h1 id="十三、其他常见事件"><a href="#十三、其他常见事件" class="headerlink" title="十三、其他常见事件"></a>十三、其他常见事件</h1><h2 id="资源事件（用于window、document、图片等等）"><a href="#资源事件（用于window、document、图片等等）" class="headerlink" title="资源事件（用于window、document、图片等等）"></a>资源事件（用于window、document、图片等等）</h2><p>这三个事件实际上属于进度事件，不仅发生在<code>document</code>对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像（image）、样式表（style sheet）、脚本（script）、视频（video）、音频（audio）、Ajax请求（XMLHttpRequest）等等。这些资源和<code>document</code>对象、<code>window</code>对象、XMLHttpRequestUpload 对象，都会触发<code>load</code>事件和<code>error</code>事件。</p>
<h3 id="beforeunload-事件"><a href="#beforeunload-事件" class="headerlink" title="beforeunload 事件"></a>beforeunload 事件</h3><p><strong><code>beforeunload</code></strong> 事件触发于 window、document 和它们的资源即将卸载时。 它可以用来防止用户不小心卸载资源。</p>
<p>如果该事件对象的<code>returnValue</code>属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.returnValue = <span class="string">&#x27;你确定离开吗？&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>浏览器对这个事件的行为很不一致，有的浏览器调用<code>event.preventDefault()</code>，也会弹出对话框。IE 浏览器需要显式返回一个非空的字符串，才会弹出对话框。而且，大多数浏览器在对话框中不显示指定文本，只显示默认文本。因此，可以采用下面的写法，取得最大的兼容性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> confirmationMessage = <span class="string">&quot;\o/&quot;</span>;</span><br><span class="line"></span><br><span class="line">  (e || <span class="built_in">window</span>.event).returnValue = confirmationMessage;     <span class="comment">//Gecko + IE</span></span><br><span class="line">  <span class="keyword">return</span> confirmationMessage;                                <span class="comment">//Webkit, Safari, Chrome etc.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="unload-事件"><a href="#unload-事件" class="headerlink" title="unload 事件"></a>unload 事件</h3><p><code>unload</code>事件在窗口关闭或者<code>document</code>对象将要卸载时触发。</p>
<p>它在下面两个事件后被触发:</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9iZWZvcmV1bmxvYWRfZXZlbnQ=">beforeunload</span> (可取消默认行为的事件)</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9wYWdlaGlkZV9ldmVudA==">pagehide</span></li>
</ol>
<p>文档处于以下状态：</p>
<ul>
<li>所有资源仍存在 (图片, iframe 等.)</li>
<li>对于终端用户所有资源均不可见</li>
<li>界面交互无效 (<code>window.open</code>, <code>alert</code>, <code>confirm</code> 等.)</li>
<li>错误不会停止卸载文档的过程</li>
</ul>
<p>手机上，浏览器或系统可能会直接丢弃网页，这时该事件根本不会发生。而且跟<code>beforeunload</code>事件一样，一旦使用了<code>unload</code>事件，浏览器就不会缓存当前网页，理由同上。因此，任何情况下都不应该依赖这个事件，指定网页卸载时要执行的代码，可以考虑完全不使用这个事件。</p>
<p>该事件可以用<code>pagehide</code>代替。</p>
<h3 id="load-事件"><a href="#load-事件" class="headerlink" title="load 事件"></a>load 事件</h3><p>当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发<code>load</code>事件。</p>
<p>它与<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/DOMContentLoaded_event"><code>DOMContentLoaded</code></a>不同，后者只要页面DOM加载完成（纯HTML被完全加载以及解析）就触发，不必等待样式表，图片或者子框架完成加载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;page is fully loaded&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>最后，页面的<code>load</code>事件也可以用<code>pageshow</code>事件代替。</p>
<p>因为只有第一次加载页面的时候才会触发load事件，从缓存加载时，<code>load</code>事件不会触发。</p>
<p>同理，DOMContentLoaded 事件的监听函数也不会执行。</p>
</blockquote>
<h3 id="abort事件"><a href="#abort事件" class="headerlink" title="abort事件"></a>abort事件</h3><p>The <strong><code>abort</code></strong> event is fired when the resource was not fully loaded, but not as the result of an error.</p>
<h3 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h3><p><code>error</code>事件是在页面或资源加载失败时触发。<code>abort</code>事件在用户取消加载时触发。</p>
<h2 id="会话历史事件"><a href="#会话历史事件" class="headerlink" title="会话历史事件"></a>会话历史事件</h2><p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。</p>
<h3 id="pageshow-事件，pagehide-事件"><a href="#pageshow-事件，pagehide-事件" class="headerlink" title="pageshow 事件，pagehide 事件"></a>pageshow 事件，pagehide 事件</h3><p><code>pageshow</code>事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。</p>
<p>下面两个事件的触发顺序:</p>
<ol>
<li>load</li>
<li>pageshow</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;pageshow: &#x27;</span>, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>pageshow事件有如下属性：</p>
<ul>
<li>target：The event target (the topmost target in the DOM tree).</li>
<li>type：The type of event.</li>
<li>bubbles：Whether the event normally bubbles or not.</li>
<li>cancelable：Whether the event is cancellable or not.</li>
<li>persisted：页面第一次加载时，这个属性是<code>false</code>；当页面从缓存加载时，这个属性是<code>true</code>。</li>
</ul>
<p><code>pagehide</code>事件与<code>pageshow</code>事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与 unload 事件的区别在于，如果在 window 对象上定义<code>unload</code>事件的监听函数之后，页面不会保存在缓存中，而使用<code>pagehide</code>事件，页面会保存在缓存中。</p>
<p><code>pagehide</code>事件实例也有一个<code>persisted</code>属性，将这个属性设为<code>true</code>，就表示页面要保存在缓存中；设为<code>false</code>，表示网页不保存在缓存中，这时如果设置了unload 事件的监听函数，该函数将在 pagehide 事件后立即运行。</p>
<p>如果页面包含<code>&lt;frame&gt;</code>或<code>&lt;iframe&gt;</code>元素，则<code>&lt;frame&gt;</code>页面的<code>pageshow</code>事件和<code>pagehide</code>事件，都会在主页面之前触发。</p>
<p>注意，这两个事件只在浏览器的<code>history</code>对象发生变化时触发，跟网页是否可见没有关系。</p>
<h3 id="popstate-事件"><a href="#popstate-事件" class="headerlink" title="popstate 事件"></a>popstate 事件</h3><p><code>popstate</code>事件在浏览器的<code>history</code>对象的当前记录发生显式切换时触发。包括</p>
<ul>
<li>鼠标点击“后退/前进”按钮</li>
<li>脚本中调用history.back()、history.forward()、history.go() </li>
</ul>
<p>不包括：</p>
<ul>
<li>history.pushState()</li>
<li>history.replaceState()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;state: &#x27;</span> + event.state);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>浏览器对于页面首次加载，是否触发<code>popstate</code>事件，处理不一样，Firefox 不触发该事件。</p>
<h3 id="hashchange-事件"><a href="#hashchange-事件" class="headerlink" title="hashchange 事件"></a>hashchange 事件</h3><p><code>hashchange</code>事件在 URL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发。该事件一般在<code>window</code>对象上监听。</p>
<p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL 是 http://www.example.com/</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, myFunction);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.oldURL);</span><br><span class="line">  <span class="built_in">console</span>.log(e.newURL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location.hash = <span class="string">&#x27;part2&#x27;</span>;</span><br><span class="line"><span class="comment">// http://www.example.com/</span></span><br><span class="line"><span class="comment">// http://www.example.com/#part2</span></span><br></pre></td></tr></table></figure>



<h2 id="网页状态事件"><a href="#网页状态事件" class="headerlink" title="网页状态事件"></a>网页状态事件</h2><h3 id="DOMContentLoaded-事件"><a href="#DOMContentLoaded-事件" class="headerlink" title="DOMContentLoaded 事件"></a>DOMContentLoaded 事件</h3><p>在上面load事件中有提到了区别， 不多赘述。</p>
<h3 id="readystatechange-事件"><a href="#readystatechange-事件" class="headerlink" title="readystatechange 事件"></a>readystatechange 事件</h3><p><code>readystatechange</code>事件当 Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发。</p>
<p><code>document.readyState</code>有三个可能的值：</p>
<ul>
<li><code>loading</code>（网页正在加载）</li>
<li><code>interactive</code>（网页已经解析完成，但是外部资源仍然处在加载状态）</li>
<li><code>complete</code>（网页和所有外部资源已经结束加载，<code>load</code>事件即将触发）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.readyState === <span class="string">&#x27;interactive&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个事件可以看作<code>DOMContentLoaded</code>事件的另一种实现方法。</p>
<h2 id="窗口事件"><a href="#窗口事件" class="headerlink" title="窗口事件"></a>窗口事件</h2><h3 id="scroll-事件"><a href="#scroll-事件" class="headerlink" title="scroll 事件"></a>scroll 事件</h3><p><code>scroll</code>事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, callback);</span><br></pre></td></tr></table></figure>

<p>该事件会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用<code>requestAnimationFrame</code>或<code>setTimeout</code>控制该事件的触发频率，然后可以结合<code>customEvent</code>抛出一个新事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">type, name, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> running = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (running) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">      running = <span class="literal">true</span>;</span><br><span class="line">      requestAnimationFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        obj.dispatchEvent(<span class="keyword">new</span> CustomEvent(name));</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.addEventListener(type, func);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 scroll 事件转为 optimizedScroll 事件</span></span><br><span class="line">  throttle(<span class="string">&#x27;scroll&#x27;</span>, <span class="string">&#x27;optimizedScroll&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;optimizedScroll&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Resource conscious scroll callback!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>throttle()</code>函数用于控制事件触发频率，它有一个内部函数<code>func()</code>，每次<code>scroll</code>事件实际上触发的是这个函数。<code>func()</code>函数内部使用<code>requestAnimationFrame()</code>方法，保证只有每次页面重绘时（每秒60次），才可能会触发<code>optimizedScroll</code>事件，从而实际上将<code>scroll</code>事件转换为<code>optimizedScroll</code>事件，触发频率被控制在每秒最多60次。</p>
<p>改用<code>setTimeout()</code>方法，可以放置更大的时间间隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, scrollThrottler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scrollTimeout;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scrollThrottler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!scrollTimeout) &#123;</span><br><span class="line">      scrollTimeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        scrollTimeout = <span class="literal">null</span>;</span><br><span class="line">        actualScrollHandler();</span><br><span class="line">      &#125;, <span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">actualScrollHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>上面代码中，每次<code>scroll</code>事件都会执行<code>scrollThrottler</code>函数。该函数里面有一个定时器<code>setTimeout</code>，每66毫秒触发一次（每秒15次）真正执行的任务<code>actualScrollHandler</code>。</p>
<p>下面是一个更一般的<code>throttle</code>函数的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((time + wait - <span class="built_in">Date</span>.now()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      time = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, throttle(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>上面的代码将<code>scroll</code>事件的触发频率，限制在一秒一次。</p>
<p><code>lodash</code>函数库提供了现成的<code>throttle</code>函数，可以直接使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, _.throttle(callback, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>本书前面介绍过<code>debounce</code>的概念，<code>throttle</code>与它区别在于，<code>throttle</code>是“节流”，确保一段时间内只执行一次，而<code>debounce</code>是“防抖”，要连续操作结束后再执行。以网页滚动为例，<code>debounce</code>要等到用户停止滚动后才执行，<code>throttle</code>则是如果用户一直在滚动网页，那么在滚动过程中还是会执行。</p>
<h3 id="resize-事件"><a href="#resize-事件" class="headerlink" title="resize 事件"></a>resize 事件</h3><p><code>resize</code>事件在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resizeMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.body.clientWidth &lt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;移动设备的视口&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, resizeMethod, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>该事件也会连续地大量触发，所以最好像上面的<code>scroll</code>事件一样，通过<code>throttle</code>函数控制事件触发频率。</p>
<h3 id="fullscreenchange-事件，fullscreenerror-事件"><a href="#fullscreenchange-事件，fullscreenerror-事件" class="headerlink" title="fullscreenchange 事件，fullscreenerror 事件"></a>fullscreenchange 事件，fullscreenerror 事件</h3><p><code>fullscreenchange</code>事件在进入或退出全屏状态时触发，该事件发生在<code>document</code>对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;fullscreenchange&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.fullscreenElement);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fullscreenerror</code>事件在浏览器无法切换到全屏状态时触发。</p>
<h2 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h2><p>以下三个事件属于剪贴板操作的相关事件。</p>
<ul>
<li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。</li>
<li><code>copy</code>：进行复制动作时触发。</li>
<li><code>paste</code>：剪贴板内容粘贴到文档后触发。</li>
</ul>
<p>举例来说，如果希望禁止输入框的粘贴事件，可以使用下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputElement.addEventListener(<span class="string">&#x27;paste&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> e.preventDefault());</span><br></pre></td></tr></table></figure>

<p>上面的代码使得用户无法在<code>&lt;input&gt;</code>输入框里面粘贴内容。</p>
<p><code>cut</code>、<code>copy</code>、<code>paste</code>这三个事件的事件对象都是<code>ClipboardEvent</code>接口的实例。<code>ClipboardEvent</code>有一个实例属性<code>clipboardData</code>，是一个 DataTransfer 对象，存放剪贴的数据。具体的 API 接口和操作方法，请参见《拖拉事件》的 DataTransfer 对象部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;copy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line">  e.clipboardData.setData(<span class="string">&#x27;text/html&#x27;</span>, <span class="string">&#x27;&lt;b&gt;Hello, world!&lt;/b&gt;&#x27;</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使得复制进入剪贴板的，都是开发者指定的数据，而不是用户想要拷贝的数据。</p>
<h2 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h2><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CustomEvent(type, options)</span><br></pre></td></tr></table></figure>

<p><code>CustomEvent()</code>构造函数接受两个参数。第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p>
<ul>
<li><code>detail</code>：表示事件的附带数据，默认为<code>null</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;build&#x27;</span>, &#123; <span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;hello&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们手动定义了<code>build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code>detail</code>属性（即字符串<code>hello</code>）。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;myevent&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">detail</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">cancelable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">&#x27;myevent&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>

<p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code>detail</code>属性。</p>
<h1 id="还有更多！"><a href="#还有更多！" class="headerlink" title="还有更多！"></a>还有更多！</h1><p>事实上这里并没有列举完所有的事件，可以通过参考连接中的第三条进入查看更多更完整的事件。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9qYXZhc2NyaXB0L2V2ZW50cy9pbmRleC5odG1s">JavaScript教程</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzgxOTY5MTY2MzQ5">深入理解DOM事件机制</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvRXZlbnRz">MDN事件参考、事件汇总</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83MzA5MTcwNg==">https://zhuanlan.zhihu.com/p/73091706</span></li>
</ol>

      <div class="tags">
          <a href="/tags/JavaScript/" rel="tag"><i class="ic i-tag"></i> JavaScript</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-12-28 10:15:39" itemprop="dateModified" datetime="2021-12-28T10:15:39+08:00">2021-12-28</time>
  </span>
  <span id="FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript事件" class="item leancloud_visitors" data-flag-title="JavaScript事件" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>Monkey-HH <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6" title="JavaScript事件">https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript事件</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202109201019726.png" title="JavaScript原型与原型链">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> JavaScript</span>
  <h3>JavaScript原型与原型链</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%ADDOM%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202109201019726.png" title="JavaScript中DOM操作总结">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> JavaScript</span>
  <h3>JavaScript中DOM操作总结</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81DOM%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">一、DOM事件级别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-0%E7%BA%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">DOM 0级事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML%E7%9A%84on-%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.1.</span> <span class="toc-text">HTML的on-属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">JavaScript定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">this的指向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-2%E7%BA%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">DOM 2级事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTarget-addEventListener-%EF%BC%9A%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">EventTarget.addEventListener()：绑定事件的监听函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTarget-removeEventListener-%EF%BC%9A%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">EventTarget.removeEventListener()：移除事件的监听函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventTarget-dispatchEvent-%EF%BC%9A%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">EventTarget.dispatchEvent()：触发事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-3%E7%BA%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">DOM 3级事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81DOM%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">3.</span> <span class="toc-text">二、DOM事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7-Event-Capturing"><span class="toc-number">3.1.</span> <span class="toc-text">事件捕获(Event Capturing)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1-Event-Bubbling"><span class="toc-number">3.2.</span> <span class="toc-text">事件冒泡(Event Bubbling)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87DOM-2%E7%BA%A7%E4%BA%8B%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">3.3.</span> <span class="toc-text">通过DOM 2级事件进行事件监听</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Event-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A5%96%E5%85%88"><span class="toc-number">4.</span> <span class="toc-text">三、Event 接口：所有事件的祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Event-%E6%8E%A5%E5%8F%A3%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">Event 接口构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Event-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">Event 接口实例属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81UIEvent-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E5%BE%88%E5%A4%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%88%B6%E4%BA%B2"><span class="toc-number">5.</span> <span class="toc-text">四、UIEvent 接口：很多事件的父亲</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UIEvent-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">UIEvent 构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIEvent-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">UIEvent 实例属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIEvent-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">UIEvent 实例方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81GlobalEventHandlers-%E6%8E%A5%E5%8F%A3%EF%BC%9ADOM0%E7%BA%A7%E4%BA%8B%E4%BB%B6%E6%9D%A5%E6%BA%90"><span class="toc-number">6.</span> <span class="toc-text">五、GlobalEventHandlers 接口：DOM0级事件来源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">六、鼠标事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MouseEvent%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.1.</span> <span class="toc-text">MouseEvent接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MouseEvent%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.1.</span> <span class="toc-text">MouseEvent构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MouseEvent%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">7.1.2.</span> <span class="toc-text">MouseEvent实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MouseEvent%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.3.</span> <span class="toc-text">MouseEvent实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">鼠标事件的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.2.1.</span> <span class="toc-text">（1）点击事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A7%BB%E5%8A%A8%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.2.2.</span> <span class="toc-text">（2）移动事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.2.3.</span> <span class="toc-text">（3）其他事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WheelEvent%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.3.</span> <span class="toc-text">WheelEvent接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WheelEvent%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.1.</span> <span class="toc-text">WheelEvent构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">7.3.2.</span> <span class="toc-text">实例属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">七、键盘事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KeyboardEvent-%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.1.</span> <span class="toc-text">KeyboardEvent 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeyboardEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.1.</span> <span class="toc-text">KeyboardEvent 接口的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeyboardEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">8.1.2.</span> <span class="toc-text">KeyboardEvent 接口的实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeyboardEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.3.</span> <span class="toc-text">KeyboardEvent 接口的实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">键盘事件的种类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text">八、进度事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ProgressEvent-%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.1.</span> <span class="toc-text">ProgressEvent 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ProgressEvent-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.1.</span> <span class="toc-text">ProgressEvent  构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ProgressEvent-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">9.1.2.</span> <span class="toc-text">ProgressEvent 实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ProgressEvent-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.3.</span> <span class="toc-text">ProgressEvent 实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">进度事件的种类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">九、表单事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InputEvent%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.1.</span> <span class="toc-text">InputEvent接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InputEvent-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.1.1.</span> <span class="toc-text">InputEvent 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputEvent-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">10.1.2.</span> <span class="toc-text">InputEvent 实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputEvent-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.3.</span> <span class="toc-text">InputEvent 实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">10.2.</span> <span class="toc-text">表单事件的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-input%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.2.1.</span> <span class="toc-text">1.input事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-select%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.2.2.</span> <span class="toc-text">2. select事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-change%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.2.3.</span> <span class="toc-text">3.change事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-invalid%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.2.4.</span> <span class="toc-text">4.invalid事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-reset%E4%BA%8B%E4%BB%B6%E3%80%81submit%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.2.5.</span> <span class="toc-text">5.reset事件、submit事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%EF%BC%88%E9%80%9A%E5%B8%B8%E7%94%A8%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">十、触摸事件（通常用于移动端）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E6%93%8D%E4%BD%9C%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.</span> <span class="toc-text">触摸操作概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Touch%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.2.</span> <span class="toc-text">Touch接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Touch-%E6%8E%A5%E5%8F%A3%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.1.</span> <span class="toc-text">Touch 接口构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Touch%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">11.2.2.</span> <span class="toc-text">Touch接口的实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Touch%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.3.</span> <span class="toc-text">Touch接口的实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TouchList%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.</span> <span class="toc-text">TouchList接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TouchEvent%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.4.</span> <span class="toc-text">TouchEvent接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TouchEvent%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">11.4.1.</span> <span class="toc-text">TouchEvent构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TouchEvent%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">11.4.2.</span> <span class="toc-text">TouchEvent实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TouchEvent%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">11.4.3.</span> <span class="toc-text">TouchEvent实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">11.5.</span> <span class="toc-text">触摸事件的种类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">十一、拖拉事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DragEvent-%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.1.</span> <span class="toc-text">DragEvent 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DragEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">12.1.1.</span> <span class="toc-text">DragEvent 接口的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DragEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">12.1.2.</span> <span class="toc-text">DragEvent 接口的实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DragEvent-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.3.</span> <span class="toc-text">DragEvent 接口的实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DataTransfer-%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.2.</span> <span class="toc-text">DataTransfer 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataTransfer-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">12.2.1.</span> <span class="toc-text">DataTransfer 接口的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataTransfer-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">12.2.2.</span> <span class="toc-text">DataTransfer 接口的实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataTransfer-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.3.</span> <span class="toc-text">DataTransfer 接口的实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">12.3.</span> <span class="toc-text">拖拉事件的种类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6"><span class="toc-number">13.</span> <span class="toc-text">十二、焦点事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FocusEvent%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.0.1.</span> <span class="toc-text">FocusEvent接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">13.0.2.</span> <span class="toc-text">焦点事件的种类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.</span> <span class="toc-text">十三、其他常见事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E4%BA%8B%E4%BB%B6%EF%BC%88%E7%94%A8%E4%BA%8Ewindow%E3%80%81document%E3%80%81%E5%9B%BE%E7%89%87%E7%AD%89%E7%AD%89%EF%BC%89"><span class="toc-number">14.1.</span> <span class="toc-text">资源事件（用于window、document、图片等等）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeunload-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.1.1.</span> <span class="toc-text">beforeunload 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unload-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.1.2.</span> <span class="toc-text">unload 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.1.3.</span> <span class="toc-text">load 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abort%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.1.4.</span> <span class="toc-text">abort事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.1.5.</span> <span class="toc-text">error 事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%8E%86%E5%8F%B2%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.2.</span> <span class="toc-text">会话历史事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pageshow-%E4%BA%8B%E4%BB%B6%EF%BC%8Cpagehide-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.2.1.</span> <span class="toc-text">pageshow 事件，pagehide 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#popstate-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.2.2.</span> <span class="toc-text">popstate 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashchange-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.2.3.</span> <span class="toc-text">hashchange 事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.3.</span> <span class="toc-text">网页状态事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOMContentLoaded-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.3.1.</span> <span class="toc-text">DOMContentLoaded 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readystatechange-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.3.2.</span> <span class="toc-text">readystatechange 事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.4.</span> <span class="toc-text">窗口事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scroll-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.4.1.</span> <span class="toc-text">scroll 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.4.2.</span> <span class="toc-text">resize 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fullscreenchange-%E4%BA%8B%E4%BB%B6%EF%BC%8Cfullscreenerror-%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.4.3.</span> <span class="toc-text">fullscreenchange 事件，fullscreenerror 事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.5.</span> <span class="toc-text">剪贴板事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CustomEvent-%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.6.</span> <span class="toc-text">CustomEvent 接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E6%9B%B4%E5%A4%9A%EF%BC%81"><span class="toc-number">15.</span> <span class="toc-text">还有更多！</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">16.</span> <span class="toc-text">参考</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/jQuery%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8" rel="bookmark" title="jQuery基础知识入门">jQuery基础知识入门</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85" rel="bookmark" title="JavaScript作用域与闭包">JavaScript作用域与闭包</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE" rel="bookmark" title="JavaScript中的数据">JavaScript中的数据</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/BOM%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" rel="bookmark" title="BOM浏览器对象模型">BOM浏览器对象模型</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="bookmark" title="JavaScript原型与原型链">JavaScript原型与原型链</a></li><li class="active"><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6" rel="bookmark" title="JavaScript事件">JavaScript事件</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%ADDOM%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93" rel="bookmark" title="JavaScript中DOM操作总结">JavaScript中DOM操作总结</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" rel="bookmark" title="JavaScript中的前端模块化">JavaScript中的前端模块化</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" rel="bookmark" title="JavaScript执行上下文">JavaScript执行上下文</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88" rel="bookmark" title="JavaScript常用继承方案">JavaScript常用继承方案</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91JavaScript%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="bookmark" title="【手撕JavaScript系列】JavaScript中的浅拷贝和深拷贝">【手撕JavaScript系列】JavaScript中的浅拷贝和深拷贝</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/axios%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%85%A5%E9%97%A8" rel="bookmark" title="axios基础知识点入门">axios基础知识点入门</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91this%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E3%80%81bind%E3%80%81apply" rel="bookmark" title="【手撕JavaScript系列】this原理以及模拟实现call、bind、apply">【手撕JavaScript系列】this原理以及模拟实现call、bind、apply</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91Promise%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise" rel="bookmark" title="【手撕JavaScript系列】Promise介绍以及实现一个Promise">【手撕JavaScript系列】Promise介绍以及实现一个Promise</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" rel="bookmark" title="JavaScript事件循环">JavaScript事件循环</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81" rel="bookmark" title="【手撕JavaScript系列】JavaScript中的防抖与节流">【手撕JavaScript系列】JavaScript中的防抖与节流</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E6%A1%88" rel="bookmark" title="JavaScript中的异步编程方案">JavaScript中的异步编程方案</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Monkey-HH"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Monkey-HH</p>
  <div class="description" itemprop="description">Learn, share, make progress</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">37</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">14</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">18</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vbmtleS1ISA==" title="https:&#x2F;&#x2F;github.com&#x2F;monkey-HH"><i class="ic i-github"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOmhoanNjYXVAMTYzLmNvbQ==" title="mailto:hhjscau@163.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>Links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%ADDOM%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE" title="JavaScript中的数据">JavaScript中的数据</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/ComputerBasics/" title="In ComputerBasics">ComputerBasics</a>
<i class="ic i-angle-right"></i>
<a href="/categories/ComputerBasics/Operating-System/" title="In Operating_System">Operating_System</a>
</div>

    <span><a href="/ComputerBasics/Operating-System/ComputerBasics/Operating_System/%E7%A3%81%E7%9B%98%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" title="磁盘与常见磁盘调度算法">磁盘与常见磁盘调度算法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/NodeJS/" title="In NodeJS">NodeJS</a>
</div>

    <span><a href="/FrontEnd/NodeJS/FrontEnd/NodeJS/NodeJS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8" title="NodeJS基础知识入门">NodeJS基础知识入门</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/HTML/" title="In HTML">HTML</a>
</div>

    <span><a href="/FrontEnd/HTML/FrontEnd/HTML/HTML%E4%B8%AD%E7%9A%84meta%E6%A0%87%E7%AD%BE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86" title="HTML中的meta标签相关知识">HTML中的meta标签相关知识</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91this%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E3%80%81bind%E3%80%81apply" title="【手撕JavaScript系列】this原理以及模拟实现call、bind、apply">【手撕JavaScript系列】this原理以及模拟实现call、bind、apply</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E6%B5%8F%E8%A7%88%E5%99%A8Web%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2" title="浏览器Web安全攻防">浏览器Web安全攻防</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%ADDOM%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93" title="JavaScript中DOM操作总结">JavaScript中DOM操作总结</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/ComputerBasics/" title="In ComputerBasics">ComputerBasics</a>
<i class="ic i-angle-right"></i>
<a href="/categories/ComputerBasics/Computer-Networking/" title="In Computer_Networking">Computer_Networking</a>
</div>

    <span><a href="/ComputerBasics/Computer-Networking/ComputerBasics/Computer_Networking/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" title="HTTP基础知识点">HTTP基础知识点</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E6%96%B9%E6%A1%88%EF%BC%9ACookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E3%80%81%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95" title="接口鉴权方案：Cookie、Session、Token、JWT、单点登录">接口鉴权方案：Cookie、Session、Token、JWT、单点登录</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/%E3%80%90%E6%89%8B%E6%92%95JavaScript%E7%B3%BB%E5%88%97%E3%80%91Promise%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAPromise" title="【手撕JavaScript系列】Promise介绍以及实现一个Promise">【手撕JavaScript系列】Promise介绍以及实现一个Promise</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Monkey-HH @ Monkey's Blog</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="Symbols count total">495k words</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="Reading time total">7:30</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript事件',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
