



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://monkeyhh.top/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://monkeyhh.top/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://monkeyhh.top/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="JavaScript" />


<link rel="canonical" href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">



  <title>
JavaScript事件循环 - JavaScript - FrontEnd |
Monkey's Blog = </title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">JavaScript事件循环
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-04-25 09:28:32">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-04-25T09:28:32+08:00">2021-04-25</time>
  </span>
  <span class="item" title="Symbols count in article">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">Symbols count in article</span>
    <span>20k</span>
    <span class="text">words</span>
  </span>
  <span class="item" title="Reading time">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">Reading time</span>
    <span>18 mins.</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Monkey's Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202109201018875.jpg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/" itemprop="item" rel="index" title="In FrontEnd"><span itemprop="name">FrontEnd</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/FrontEnd/JavaScript/" itemprop="item" rel="index" title="In JavaScript"><span itemprop="name">JavaScript</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Monkey-HH">
    <meta itemprop="description" content=", Learn, share, make progress">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>作为一名 JavaScript 开发人员，了解幕后真正发生的事情以及从我们这里抽象出来的这些复杂性中的大多数如何真正起作用变得越来越重要。它可以帮助我们做出更明智的决策，进而可以显着提高我们的代码性能。</p>
<p>JavaScript 程序员喜欢使用诸如“事件循环”、“非阻塞”、“回调”、“异步”、“单线程”和“并发”之类的词。</p>
<p>我们会说“不要阻塞事件循环”、“确保你的代码以每秒 60 帧的速度运行”、“当然，它不会工作，该函数是一个异步回调！”</p>
<p>如果你和我一样，你点头同意，好像这一切都很明显，即使你实际上不知道这些词是什么意思；然而，要找到 JavaScript 实际<em>工作原理的</em>良好解释并不是那么容易，所以让我们学习吧！</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><strong>JavaScript Engine 和 JavaScript Runtime</strong></p>
<p>简单来说，为了让 JavaScript 运行起来，要完成两部分工作（当然实际比这复杂的多）：</p>
<ul>
<li>编译并执行 JavaScript 代码，完成内存分配、垃圾回收等；</li>
<li>为 JavaScript 提供一些对象或机制，使它能够与外界交互。</li>
</ul>
<p><em>这里的第一部分，是 Engine（执行引擎）；第二部分，是 Runtime（执行环境）。</em></p>
<blockquote>
<p>举个栗子：<br>Chrome 和 Node.js 都使用了 V8 Engine：<strong>V8 实现并提供了 ECMAScript 标准</strong>中的所有数据类型、操作符、对象和方法（注意并没有 <code>DOM</code>）。<br>但它们的 Runtime 并不一样：Chrome 提供了 <code>window</code>、<code>DOM</code>，而 Node.js 则是 <code>require</code>、<code>process</code> 等等。</p>
</blockquote>
<h1 id="关于JavaScript的一些概念"><a href="#关于JavaScript的一些概念" class="headerlink" title="关于JavaScript的一些概念"></a>关于JavaScript的一些概念</h1><p>在我们继续之前，我希望我们回到最基础的一步。JavaScript 到底是什么？我们可以将 JavaScript 定义为；</p>
<blockquote>
<p>JavaScript 是一种高级、解释性、单线程、非阻塞、异步、并发语言。</p>
</blockquote>
<p>等等，这是什么？书本般的定义？🤔</p>
<p>让我们进一步解释它！</p>
<p>本文的关键词是<strong>单线程</strong>、<strong>非阻塞、并发</strong>和<strong>异步</strong>。</p>
<blockquote>
<p>❓：为什么要选择单线程？</p>
</blockquote>
<p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p>
<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<blockquote>
<p>❓既然JavaScript是单线程了，为什么又是异步、并发语言呢，这不是矛盾了吗？</p>
</blockquote>
<p>单线程和异步确实不能同时成为一个语言的特性。</p>
<p>JavaScript选择了成为单线程的语言，这意味着它一次只能执行一项任务或操作。这意味着它将从头到尾执行整个过程，而不会中断或停止线程。所以它本身不可能是异步的，但JavaScript的宿主环境（比如浏览器）是多线程的，宿主环境通过某种方式（事件驱动，下文会讲）使得JavaScript具备了异步的属性。</p>
<p>JavaScript是单线程语言，浏览器只分配给JavaScript一个主线程，用来执行任务（函数），但一次只能执行一个任务，这些任务形成一个任务队列排队等候执行，但前端的某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让他们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。所以，浏览器为这些耗时任务开辟了另外的线程，主要包括HTTP请求线程，浏览器定时触发器，浏览器事件触发线程，这些任务是异步的。下图说明了浏览器的主要线程（注：此处的浏览器GUI渲染线程和JavaScript引擎线程是两个互斥线程）。关于更多浏览器进程与线程的知识，可以看另外我的一篇文章</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210910210757108.png" alt="image-20210910210757108"></p>
<p>那么浏览器中是怎么运行JavaScript代码的呢？答案就是V8引擎。</p>
<h2 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h2><p>是 Google 用 C++ 编写的用于 JavaScript 的高性能、开源 Web 程序集运行时引擎。大多数浏览器使用 V8 引擎运行 JavaScript，甚至流行的 Node.js运行时环境也使用它。</p>
<p>简单来说，V8 是一个 C++ 程序，它接收 JavaScript 代码，编译并执行它。在 JavaScript 运行的时候，JavaScript Engine 会创建和维护相应的堆（Heap）和栈（Stack）</p>
<p>V8 主要做了两件事；</p>
<ul>
<li>内存堆分配</li>
<li>调用堆栈执行上下文</li>
</ul>
<p><img data-src="https://geekflare.com/wp-content/uploads/2019/10/v8.png" alt="v8"></p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210911003347660.png" alt="image-20210911003347660"></p>
<blockquote>
<p>调用栈是什么?</p>
<p><strong>一个线程  ===   一个调用栈   ===   同时只能干一件事</strong></p>
</blockquote>
<p>既然 V8 只有一个调用栈，那么 JavaScript 如何在不阻塞主执行线程的情况下并发异步运行呢？</p>
<p>下面我们试着通过写一段简单但通用的异步代码找出来，一起分析一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;step 1&quot;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&quot;step 2&quot;</span>),<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;step 3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//PS D:\1project\vue_p\webConnection\src&gt; node .\new_file.js</span></span><br><span class="line"><span class="comment">//step 1</span></span><br><span class="line"><span class="comment">//step 3</span></span><br><span class="line"><span class="comment">//step 2</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 逐行运行每个代码，一个接一个（单线程）。正如预期的那样，第一行在这里打印在控制台中，但为什么在Timeout代码之前打印最后一行？为什么执行过程在继续运行最后一行之前不等待Timeout代码（阻塞）？</p>
<p><strong>其他一些线程似乎帮助我们执行了Timeout</strong>，因为我们非常确定一个线程在任何时间点只能执行一个任务。</p>
<p>让我们先偷看一下<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4">V8 源代码</span>。</p>
<p>等等……什么？？！！！V8没有定时器功能，没有DOM？没有活动？没有AJAX？…. 耶耶！！！</p>
<p>事件、DOM、计时器等不是 JavaScript 核心实现的一部分，JavaScript 严格遵守 Ecma Scripts 规范，并且根据其 Ecma Scripts Specifications (ES X) 经常引用它的各种版本。</p>
<p>另外，还需要注意的是：Event Loop 并不是在 ECMAScript 标准中定义的，而是在 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCUyM2V2ZW50LWxvb3Bz">HTML 标准</span>中定义的：</p>
<blockquote>
<p>To coordinate events, user interaction, scripts, rendering, networking, and so forth…</p>
</blockquote>
<p>在 JavaScript Engine 中（以 V8 为例），只是实现了 ECMAScript 标准，而并不关心什么 Event Loop。也就是说 <strong>Event Loop 是属于 JavaScript Runtime</strong> 的，是由宿主环境提供的（比如浏览器）。所以千万不要搞错了，这也是前面介绍 JavaScript Engine 和 Runtime 的原因。</p>
<p>敲黑板！下面开始正题！</p>
<p>敲黑板！下面开始正题！</p>
<p>敲黑板！下面开始正题！</p>
<p>为了协调事件、用户交互、脚本、UI 渲染、网络请求，用户代理必须使用 eventloop。</p>
<p>任何 JavaScript 程序的执行工作流都包含三个主要部分：调用栈、Web API 和任务队列。</p>
<h1 id="调用栈Call-Stack"><a href="#调用栈Call-Stack" class="headerlink" title="调用栈Call Stack"></a>调用栈Call Stack</h1><p>堆栈是一种数据结构，其中添加的最后一个元素总是最先从堆栈中移除，您可以将其视为一个盘子的堆栈，其中只有最后添加的第一个盘子才能首先移除。</p>
<p>调用堆栈只是一个堆栈数据结构，JavaScript任务或代码正在Call Stack相应地执行。</p>
<p>举个例子，如下图，初始的时候调用栈为空</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210910234629043.png" alt="image-20210910234629043"></p>
<p>当你调用函数时<code>printSquare()</code>，它被压入调用堆栈，<code>printSquare()</code>函数调用 square() 函数。该<code>square()</code>函数被压入堆栈并调用该<code>multiply()</code>函数。乘法函数被压入堆栈。由于乘法函数返回并且是最后一个被压入堆栈的东西，它首先被解析并从堆栈中移除，然后是<code>square()</code>函数，然后是<code>printSquare()</code>函数。于是就变成了下面的样子。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210910234748719.png" alt="image-20210910234748719"></p>
<p>接着就是JavaScript的逐个执行，即逐个弹出栈，先执行<code>multiply()</code>函数，得到返回值，把顶层的<code>multiply()</code>弹出栈，以此类推，最终，Call Stack清空，一切回归安详</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210910234629043.png" alt="image-20210910234629043"></p>
<p>我们再看一个例子</p>
<p>该例子中，最后foo函数抛出了一个错误，在浏览器中可以看到对应的Call Stack栈的样子，和上面例子是一致的方式。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210910235235485.png" alt="image-20210910235235485"></p>
<p>那么Call Stack会不会导致内存溢出呢？会</p>
<p>下面的例子中，每个foo都调用一次foo，最后调用栈溢出，直接爆炸。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210910235359372.png" alt="image-20210910235359372"></p>
<p><img data-src="C:/Users/monkey/AppData/Roaming/Typora/typora-user-images/image-20210910235447258.png" alt="image-20210910235447258"></p>
<blockquote>
<p>❓那么问题来了，如果有个函数代码执行地很慢（webapi事件，如Ajax网路请求、DOM操作例如鼠标点击事件、setTimeout事件）呢？</p>
<p>是不是让栈底函数等它上一个函数执行完了再执行呢？咦？但是JavaScript是非阻塞的啊？</p>
</blockquote>
<p>为了解决这个问题，引入了一个模型，可以看到下方多了一个Callback queue，叫法不同，一般也叫task queue</p>
<p><img data-src="https://miro.medium.com/max/700/1*7GXoHZiIUhlKuKGT22gHmA.png" alt="img"></p>
<h1 id="task-queue-任务队列"><a href="#task-queue-任务队列" class="headerlink" title="task queue 任务队列"></a>task queue 任务队列</h1><p>我们通过下面的例子来理解这个玩意，首先很显然先把第一行代码入栈，随后发现可以执行，直接执行掉，输出HI</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210911000344714.png" alt="image-20210911000344714"></p>
<p>随后将第二条语句入栈</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210911000545488.png" alt="image-20210911000545488"></p>
<p>第二条语句setTimeout是异步函数，此时浏览器开了一个新的线程去处理这个函数</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210911000615264.png" alt="image-20210911000615264"></p>
<p>随后就是把setTimeout出栈，最后一行代码入栈，此时变成这样子</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210911000719683.png" alt="image-20210911000719683"></p>
<p>此时就在等webapis完成，当这个timer完成之后，会将回调函数cb放入到任务队列中，如下图</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210911000901186.png" alt="image-20210911000901186"></p>
<p>而JavaScript的事件循环机制，会检查到任务队列里有活没干完，就会把任务队列里的活压入调用栈，如下图所实，并进行输出</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210911001034244.png" alt="image-20210911001034244"></p>
<p>再来一个例子，加深印象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>); </span><br><span class="line">    	&#125;,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br><span class="line"><span class="comment">//	Output</span></span><br><span class="line"><span class="comment">//	A</span></span><br><span class="line"><span class="comment">//	C</span></span><br><span class="line"><span class="comment">//  B</span></span><br></pre></td></tr></table></figure>

<p>这里我们有一个 main 函数，它有 2 个 console.log 命令将“A”和“C”记录到控制台。夹在它们之间的是 setTimeout 调用，它以 0 毫秒的等待时间将“B”记录到控制台。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210911003056624.png" alt="image-20210911003056624"></p>
<ol>
<li>对 main 函数的调用首先被压入堆栈（作为一个框架）。然后浏览器将主函数中的第一条语句压入栈中，即console.log(‘A’)。执行此语句，并在完成后弹出该帧。字母 A 显示在控制台中。</li>
<li>下一条语句（带有回调 exec() 和 0ms 等待时间的 setTimeout()）被推入调用堆栈并开始执行。setTimeout 函数使用浏览器 API 来延迟对所提供函数的回调。一旦切换到浏览器完成（对于计时器），框架（带有 setTimeout）就会弹出。</li>
<li>当计时器在浏览器中运行以回调 exec() 函数时，console.log(‘C’) 被推送到堆栈。在这种特殊情况下，由于提供的延迟为 0 毫秒，因此只要浏览器接收到回调（理想情况下），回调就会被添加到消息队列中。</li>
<li>在 main 函数中的最后一条语句执行完毕后，main() 帧被从调用栈中弹出，从而使其为空。对于浏览器将任何消息从队列推送到调用堆栈，调用堆栈必须首先为空。这就是为什么即使 setTimeout() 中提供的延迟为 0 秒，对 exec() 的回调也必须等到调用堆栈中所有帧的执行完成。</li>
<li>现在回调 exec() 被推入调用堆栈并执行。字母 C 显示在控制台上。这是 javascript 的事件循环。</li>
</ol>
<blockquote>
<p>所以 setTimeout(function, delayTime) 中的延迟参数并不代表函数执行后的精确时间延迟。它代表最短等待时间，在此之后的某个时间点将执行该函数。即使delayTime为0，他也是</p>
</blockquote>
<p>此处放一个链接<a target="_blank" rel="noopener" href="http://latentflip.com/loupe/"><em>http://latentflip.com/loupe/，可以直观地模拟以上的过程</em></a></p>
<h1 id="任务队列进阶"><a href="#任务队列进阶" class="headerlink" title="任务队列进阶"></a>任务队列进阶</h1><h2 id="任务是什么"><a href="#任务是什么" class="headerlink" title="任务是什么"></a>任务是什么</h2><p>咱们前面聊了那么久的任务队列，那么到底什么是任务？</p>
<blockquote>
<p>Formally, a task is a <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cnVjdA==">struct</span> which has:</p>
<ul>
<li><p>Steps</p>
<p>A series of steps specifying the work to be done by the task.</p>
</li>
<li><p>A source</p>
<p>One of the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdGFzay1zb3VyY2U=">task sources</span>, used to group and serialize related tasks.</p>
</li>
<li><p>A document</p>
<p>A <code>Document</code> associated with the task, or null for tasks that are not in a <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jd2luZG93LWV2ZW50LWxvb3A=">window event loop</span>.</p>
</li>
<li><p>A script evaluation environment settings object set</p>
<p>A <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI29yZGVyZWQtc2V0">set</span> of <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZW52aXJvbm1lbnQtc2V0dGluZ3Mtb2JqZWN0">environment settings objects</span> used for tracking script evaluation during the task.</p>
</li>
</ul>
<p>A <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC10YXNr">task</span> is runnable if its <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC10YXNrLWRvY3VtZW50">document</span> is either null or <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZnVsbHktYWN0aXZl">fully active</span>.</p>
<p>Per its <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC10YXNrLXNvdXJjZQ==">source</span> field, each <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC10YXNr">task</span> is defined as coming from a specific task source. For each <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span>, every <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdGFzay1zb3VyY2U=">task source</span> must be associated with a specific <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdGFzay1xdWV1ZQ==">task queue</span>.</p>
</blockquote>
<p>翻译一下：</p>
<p>形式化地，任务 是一个具有如下属性的 <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cnVjdA==">结构</span> 结构：</p>
<ul>
<li><p>steps</p>
<p>一系列的步骤，指定了要完成的工作。</p>
</li>
<li><p>source</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">任务来源</span> 之一，用于分组和序列化相关任务。</p>
</li>
<li><p>document</p>
<p>和任务关联的 <code>Document</code>，对于不在 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3dpbmRvdy1ldmVudC1sb29w">窗口事件循环</span> 里的任务为 null。</p>
</li>
<li><p>A script evaluation environment settings object set</p>
<p>用于在任务期间跟踪脚本执行的 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2Vudmlyb25tZW50LXNldHRpbmdzLW9iamVjdA==">环境设置对象</span> 的 <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI29yZGVyZWQtc2V0">集合</span>。</p>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzaw==">任务</span> 是 可执行的 当且仅当它的 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzay1kb2N1bWVudA==">document</span> 为 null 或 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2Z1bGx5LWFjdGl2ZQ==">完全激活</span>。</p>
<p>至于它的 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzay1zb3VyY2U=">source</span> 字段，每个 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzaw==">任务</span> 都来自一个特定的任务源。 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2V2ZW50LWxvb3A=">事件循环</span> 中的每个 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">任务源</span> 必须关联 特定的 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stcXVldWU=">任务队列</span>。</p>
<p><em>本质上，</em><span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">任务源</span> <em>用于分离逻辑上不同类型的任务，user agent可能希望区分它们。 user agent使用</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stcXVldWU=">任务队列</span> <em>来在给定的</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2V2ZW50LWxvb3A=">事件循环</span> <em>内合并任务源。</em></p>
<p>例如，user agent可能有一个管理鼠标和键盘事件的 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stcXVldWU=">任务队列</span> （与之关联的是 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3VzZXItaW50ZXJhY3Rpb24tdGFzay1zb3VyY2U=">用户交互任务源</span>），以及另一个和其他所有 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">任务源</span> 关联的任务队列。然后利用 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2V2ZW50LWxvb3AtcHJvY2Vzc2luZy1tb2RlbA==">事件循环处理模型</span> 的初始化步骤提供的自由， 它可以优先处理键盘和鼠标事件，比其他任务多四分之三的时间。这样可以在不让其他任务队列饥饿的情况下保持 UI 可响应。 注意在这个配置下，处理模型仍然强制用户代理不会乱序执行任意 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">任务源</span> 里的时间。</p>
<h2 id="任务封装算法"><a href="#任务封装算法" class="headerlink" title="任务封装算法"></a>任务封装算法</h2><p>下面再来讲讲每个任务封装的算法</p>
<blockquote>
<p>Tasks encapsulate algorithms that are responsible for such work as:</p>
<ul>
<li><p>Events</p>
<p>Dispatching an <code>Event</code> object at a particular <code>EventTarget</code> object is often done by a dedicated task.Not all events are dispatched using the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdGFzay1xdWV1ZQ==">task queue</span>; many are dispatched during other tasks.</p>
</li>
<li><p>Parsing</p>
<p>The <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbC1wYXJzZXI=">HTML parser</span> tokenizing one or more bytes, and then processing any resulting tokens, is typically a task.</p>
</li>
<li><p>Callbacks</p>
<p>Calling a callback is often done by a dedicated task.</p>
</li>
<li><p>Using a resource</p>
<p>When an algorithm <span class="exturl" data-url="aHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZmV0Y2g=">fetches</span> a resource, if the fetching occurs in a non-blocking fashion then the processing of the resource once some or all of the resource is available is performed by a task.</p>
</li>
<li><p>Reacting to DOM manipulation</p>
<p>Some elements have tasks that trigger in response to DOM manipulation, e.g. when that element is <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaW5zZXJ0LWFuLWVsZW1lbnQtaW50by1hLWRvY3VtZW50">inserted into the document</span>.</p>
</li>
</ul>
</blockquote>
<p>任务封装的算法负责类似这样的工作：</p>
<ul>
<li><p>事件</p>
<p>在特定的 <code>EventTarget</code> (一个具有监听订阅模式列表的对象)上派发一个 <code>Event</code> 对象， 通常由专门的任务完成。不是所有事件都是由 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stcXVldWU=">任务队列</span> 派发的， 很多是在其他任务执行过程中派发的。</p>
</li>
<li><p>解析</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2h0bWwtcGFyc2Vy">HTML 解析器</span> 标记化一个或更多字节， 然后处理结果标token。</p>
</li>
<li><p>回调</p>
<p>由专门的Task触发回调函数</p>
</li>
<li><p>使用资源</p>
<p>当该算法 <span class="exturl" data-url="aHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZmV0Y2g=">获取</span> 资源的时候，如果该阶段是以非阻塞方式发生，那么一旦部分或者全部资源可用，则由Task进行后续处理</p>
</li>
<li><p>对 DOM 操作作出反应</p>
<p> 通过dom操作触发的任务，例如插入一个节点到document</p>
</li>
</ul>
<h2 id="任务的分类和来源"><a href="#任务的分类和来源" class="headerlink" title="任务的分类和来源"></a>任务的分类和来源</h2><ol>
<li>⭐task，也有人叫这个是macrotask宏任务，但whatwg规范里没有这个说法，下面谈一下任务来源。</li>
</ol>
<blockquote>
<p>The following <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">task sources</span> are used by a number of mostly unrelated features in this and other specifications.</p>
<ul>
<li><p>The DOM manipulation task source</p>
<p>This <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">task source</span> is used for features that react to DOM manipulations, such as things that happen in a non-blocking fashion when an element is <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2luc2VydC1hbi1lbGVtZW50LWludG8tYS1kb2N1bWVudA==">inserted into the document</span>.</p>
</li>
<li><p>The user interaction task source</p>
<p>This <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">task source</span> is used for features that react to user interaction, for example keyboard or mouse input.Events sent in response to user input (e.g. <code>click</code> events) must be fired using <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzaw==">tasks</span> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3F1ZXVlLWEtdGFzaw==">queued</span> with the <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3VzZXItaW50ZXJhY3Rpb24tdGFzay1zb3VyY2U=">user interaction task source</span>. [<span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3JlZnNVSUVWRU5UUw==">UIEVENTS]</span></p>
</li>
<li><p>The networking task source</p>
<p>This <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">task source</span> is used for features that trigger in response to network activity.</p>
</li>
<li><p>The history traversal task source</p>
<p>This <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stc291cmNl">task source</span> is used to queue calls to <code>history.back()</code> and similar APIs.</p>
</li>
</ul>
</blockquote>
<p>翻译一下：</p>
<ul>
<li>DOM 操作任务源：如元素以非阻塞方式插入文档</li>
<li>用户交互任务源：如鼠标键盘事件。用户输入事件（如 click） 必须使用 task 队列</li>
<li>网络任务源：如 XHR 回调</li>
<li>history 回溯任务源：使用 history.back() 或者类似 API</li>
</ul>
<p>此外还有以下来源</p>
<ul>
<li>script(整体代码)</li>
<li>setTimeout</li>
<li>setInterval    </li>
<li>I/O    </li>
<li>UI交互事件    </li>
<li>postMessage    </li>
<li>MessageChannel    </li>
<li>setImmediate(Node.js 环境)</li>
</ul>
<ol start="2">
<li>⭐microtask微任务。</li>
</ol>
<p>每个 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2V2ZW50LWxvb3A=">事件循环</span> 有一个 微任务队列， 它是一个 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI21pY3JvdGFzaw==">微任务</span> 的 <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3F1ZXVl">队列</span>，初始为空。 微任务 是一个通俗的叫法，指由 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3F1ZXVlLWEtbWljcm90YXNr">入队微任务</span> 算法创建的 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzaw==">任务</span>。</p>
<p>一般来说，microtask 包括：</p>
<ul>
<li><p>Promise.then</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jbm90ZXM=">Promise 规范</span>中提及 Promise.then 的具体实现由平台把握，可以是 microtask 或 task。当前的共识是使用 microtask 实现。</p>
<p>promise.resolve是宏任务，这个面试题很常见的知识点</p>
</blockquote>
</li>
<li><p>MutationObserver</p>
</li>
<li><p>Object.observe</p>
</li>
</ul>
<p>顺便提一下微任务的排队算法</p>
<blockquote>
<p>To queue a microtask which performs a series of steps steps, optionally given an event loop event loop and a document document:</p>
<ol>
<li>If event loop was not given, set event loop to the <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2ltcGxpZWQtZXZlbnQtbG9vcA==">implied event loop</span>.</li>
<li>If document was not given, set document to the <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2ltcGxpZWQtZG9jdW1lbnQ=">implied document</span>.</li>
<li>Let microtask be a new <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzaw==">task</span>.</li>
<li>Set microtask’s <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzay1zdGVwcw==">steps</span> to steps.</li>
<li>Set microtask’s <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzay1zb3VyY2U=">source</span> to the microtask task source.</li>
<li>Set microtask’s <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzay1kb2N1bWVudA==">document</span> to document.</li>
<li>Set task’s <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3NjcmlwdC1ldmFsdWF0aW9uLWVudmlyb25tZW50LXNldHRpbmdzLW9iamVjdC1zZXQ=">script evaluation environment settings object set</span> to an empty <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI29yZGVyZWQtc2V0">set</span>.</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3F1ZXVlLWVucXVldWU=">Enqueue</span> task on event loop’s <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI21pY3JvdGFzay1xdWV1ZQ==">microtask queue</span>.</li>
</ol>
</blockquote>
<p>如果未提供event loop，设置一个隐式event loop。<br>如果未提供document，设置一个隐式document.<br>创建一个Task作为新的微任务<br>设置setp、source、document到新的Task上<br>设置Task的环境配置对象为空集<br>添加到event loop的微任务队列中</p>
<p>好了，whatwg文档中还有一点有趣</p>
<blockquote>
<p><em>It is possible for a</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI21pY3JvdGFzaw==">microtask</span> <em>to be moved to a regular</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stcXVldWU=">task queue</span><em>, if, during its initial execution, it</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3NwaW4tdGhlLWV2ZW50LWxvb3A=">spins the event loop</span><em>. This is the only case in which the</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzay1zb3VyY2U=">source</span><em>,</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzay1kb2N1bWVudA==">document</span><em>, and</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3NjcmlwdC1ldmFsdWF0aW9uLWVudmlyb25tZW50LXNldHRpbmdzLW9iamVjdC1zZXQ=">script evaluation environment settings object set</span> <em>of the microtask are consulted; they are ignored by the</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3BlcmZvcm0tYS1taWNyb3Rhc2stY2hlY2twb2ludA==">perform a microtask checkpoint</span> <em>algorithm.</em></p>
<p>微任务有可能被移到一个宏任务队列，只有当在初始化的过程中，旋转了事件循环流程，使得它被微任务检查点算法所错过，至于如何旋转事件循环 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3NwaW4tdGhlLWV2ZW50LWxvb3A=">https://whatwg-cn.github.io/html/#spin-the-event-loop</span></p>
</blockquote>
<h2 id="任务队列的分类"><a href="#任务队列的分类" class="headerlink" title="任务队列的分类"></a>任务队列的分类</h2><p>上面我们提到了任务队列的方式解决异步调用的问题，那么任务队列是不是只有一个，有没有更多的不同优先级的任务队列呢？答案是有的，看看whatwg怎么说</p>
<blockquote>
<p>An <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span> has one or more task queues. A <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdGFzay1xdWV1ZQ==">task queue</span> is a <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI29yZGVyZWQtc2V0">set</span> of <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC10YXNr">tasks</span>.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2V2ZW50LWxvb3A=">事件循环</span> 有一个或更多的 任务队列。 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stcXVldWU=">任务队列</span> 是一个 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzaw==">任务</span> 的 <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI29yZGVyZWQtc2V0">集合</span>。</p>
<p>值得注意的一点是：<span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3Rhc2stcXVldWU=">任务队列</span> <em>是</em> <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI29yZGVyZWQtc2V0">集合</span> <em>而非</em> <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3F1ZXVl">队列</span><em>， 因为</em> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3N0ZXAx">事件循环处理模型的第一步</span> <em>会从选中的队列中取第一个</em> <a target="_blank" rel="noopener" href="https://whatwg-cn.github.io/html/#concept-task-runnable"><em>可运行</em></a> <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzaw==">任务</span><em>，而不是</em> <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3F1ZXVlLWRlcXVldWU=">出列</span> <em>第一个任务。</em></p>
<p>但是!</p>
<p>微任务队列是一个入对出对的队列。详细看下面提到微任务检查点的时候可以看到，会选一个最老的微任务，防止饿死</p>
<p>When a user agent is to perform a microtask checkpoint:</p>
<ol>
<li><p>If the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span>‘s <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jcGVyZm9ybWluZy1hLW1pY3JvdGFzay1jaGVja3BvaW50">performing a microtask checkpoint</span> is true, then return.</p>
</li>
<li><p>Set the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span>‘s <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jcGVyZm9ybWluZy1hLW1pY3JvdGFzay1jaGVja3BvaW50">performing a microtask checkpoint</span> to true.</p>
</li>
<li><p>While the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span>‘s <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbWljcm90YXNrLXF1ZXVl">microtask queue</span> is not <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2xpc3QtaXMtZW1wdHk=">empty</span>:</p>
<ol>
<li><p>Let oldestMicrotask be the result of <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3F1ZXVlLWRlcXVldWU=">dequeuing</span> from the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span>‘s <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbWljcm90YXNrLXF1ZXVl">microtask queue</span>.</p>
</li>
<li><p>Set the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span>‘s <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY3VycmVudGx5LXJ1bm5pbmctdGFzaw==">currently running task</span> to oldestMicrotask.</p>
</li>
<li><p>Run oldestMicrotask.</p>
<p>This might involve invoking scripted callbacks, which eventually calls the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY2xlYW4tdXAtYWZ0ZXItcnVubmluZy1zY3JpcHQ=">clean up after running script</span> steps, which call this <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jcGVyZm9ybS1hLW1pY3JvdGFzay1jaGVja3BvaW50">perform a microtask checkpoint</span> algorithm again, which is why we use the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jcGVyZm9ybWluZy1hLW1pY3JvdGFzay1jaGVja3BvaW50">performing a microtask checkpoint</span> flag to avoid reentrancy.</p>
</li>
<li><p>Set the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span>‘s <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY3VycmVudGx5LXJ1bm5pbmctdGFzaw==">currently running task</span> back to null.</p>
</li>
</ol>
</li>
<li><p>For each <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZW52aXJvbm1lbnQtc2V0dGluZ3Mtb2JqZWN0">environment settings object</span> whose <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jcmVzcG9uc2libGUtZXZlbnQtbG9vcA==">responsible event loop</span> is this <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span>, <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm90aWZ5LWFib3V0LXJlamVjdGVkLXByb21pc2Vz">notify about rejected promises</span> on that <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZW52aXJvbm1lbnQtc2V0dGluZ3Mtb2JqZWN0">environment settings object</span>.</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93M2MuZ2l0aHViLmlvL0luZGV4ZWREQi8jY2xlYW51cC1pbmRleGVkLWRhdGFiYXNlLXRyYW5zYWN0aW9ucw==">Cleanup Indexed Database transactions</span>.</p>
</li>
<li><p>Perform <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jbGVhci1rZXB0LW9iamVjdHM=">ClearKeptObjects</span>().</p>
<p>When <code>WeakRef.prototype.deref()</code> returns an object, that object is kept alive until the next invocation of <span class="exturl" data-url="aHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jbGVhci1rZXB0LW9iamVjdHM=">ClearKeptObjects</span>(), after which it is again subject to garbage collection.</p>
</li>
<li><p>Set the <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcA==">event loop</span>‘s <span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jcGVyZm9ybWluZy1hLW1pY3JvdGFzay1jaGVja3BvaW50">performing a microtask checkpoint</span> to false.</p>
</li>
</ol>
<p>翻译一下：</p>
<p>当用户代理 执行微任务检查点 时：</p>
<p>1.如果微任务检查标志为true，直接return<br>2.设置微任务检查标志为true<br>3.如果微任务队里不为空(也就是说微任务添加的微任务也会在这个循环中出现，直到微任务队列为空)：<br>4.从微任务队列中找出最老的任务(防饿死)<br>5.设置当前执行任务为这个最老的任务<br>6.执行<br>7.重置当前执行任务为null<br>8.通知环境配置对象的promise进行reject操作<br>9.清理indexdb事务(不太明白这一步，如果有读者了解，烦请点拨一下)<br>10.设置微任务检查标志为false</p>
</blockquote>
<p>每个 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2V2ZW50LWxvb3A=">事件循环</span> 有一个 当前正在执行的任务， 它是一个 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzaw==">任务</span> 或 null，初始为 null。用来处理再进入的情况。</p>
<p>每个 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2V2ZW50LWxvb3A=">事件循环</span> 有一个 微任务队列， 它是一个 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI21pY3JvdGFzaw==">微任务</span> 的 <span class="exturl" data-url="aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3F1ZXVl">队列</span>，初始为空。 微任务 是一个通俗的叫法，指由 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI3F1ZXVlLWEtbWljcm90YXNr">入队微任务</span> 算法创建的 <span class="exturl" data-url="aHR0cHM6Ly93aGF0d2ctY24uZ2l0aHViLmlvL2h0bWwvI2NvbmNlcHQtdGFzaw==">任务</span>。</p>
<p>与上面提到的任务一样，主要有两种队列</p>
<ul>
<li>task queue，也有人叫这个是macrotask queue（宏任务队列，但其实whatwg规范里没这个叫法，只是为了和微任务队列做个区分）</li>
<li>microtask queue，即常说的微任务队列，优先级高于前者</li>
</ul>
<h2 id="事件循环的处理模型"><a href="#事件循环的处理模型" class="headerlink" title="事件循环的处理模型"></a>事件循环的处理模型</h2><p>看一下whatwg上面的相关定义</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210914110708140.png" alt="image-20210914110708140"></p>
<p>再附上一份机翻</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210914110829828.png" alt="image-20210914110829828"></p>
<p>是不是有点长，用一个图来表示，可以看到啊</p>
<ol>
<li>JS引擎首先从macrotask queue中取出第一个任务，执行完毕后，将microtask queue中的所有任务取出，按顺序全部执行；</li>
<li>然后再从macrotask queue（宏任务队列）中取下一个，执行完毕后，再次将microtask queue（微任务队列）中的全部取出；</li>
<li>循环往复，直到两个queue中的任务都取完。</li>
</ol>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/eventloop-1.png" alt="eventloop-1"></p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/202109210104051.jpeg" alt="image"></p>
<p>⚠看到这里，有的读者可能会和我一样，产生一个疑问，微任务队列的优先级不是高于任务队列吗？为什么图里是先执行宏任务，再执行微任务，是不是，哪里出了问题？记住结论：<u><strong>微任务的优先级比宏任务高，但是宏任务才会触发新一轮的tick</strong></u></p>
<p>比如说下面一个例子，产生了这个误解的读者可能会觉得结果是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的结果</span></span><br><span class="line">script start</span><br><span class="line">script end</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实的结果</span></span><br><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure>

<p>那么下面再解释一下子哈</p>
<p>最最最开始的时候，宏任务和微任务队列都是空的，然后把script加入到了宏任务队列</p>
<p>然后走图的流程script先作为一个宏任务执行，先输出了“script start”，这里相信不会有疑问</p>
<p>随后，把setTimeout放入宏任务，promise的两个then放入微任务</p>
<p>随后，执行最后一条语句，输出“script end”，这时候的一个宏任务即script就执行完了</p>
<p>然后，看模型图，执行完一个宏任务之后，就会去查微任务队列里有没有任务，欸，发现有，然后就执行输出了promise的两条语句，后面的就不用我解释啦，详细的过程可以去看<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84MDA3NDI3NA==">https://zhuanlan.zhihu.com/p/80074274</span></p>
<p>其实产生了这个疑问的读者忽略了一点，script整体代码也是一个宏任务，看一下下面两个例子加深一下印象</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 脚本 1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="comment">// 同步</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">&#x27;start1&#x27;</span>)</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 异步宏</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>), <span class="number">0</span>)</span></span><br><span class="line"><span class="javascript">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="comment">// 同步</span></span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>)</span></span><br><span class="line"><span class="javascript">		resolve()</span></span><br><span class="line"><span class="javascript">	&#125;).then(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="comment">// 异步微</span></span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="string">&#x27;then1&#x27;</span>)</span></span><br><span class="line"><span class="javascript">	&#125;)</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 同步</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">&#x27;end1&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 脚本 2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="comment">// 同步</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">&#x27;start2&#x27;</span>)</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 异步宏</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>), <span class="number">0</span>)</span></span><br><span class="line"><span class="javascript">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="comment">// 同步</span></span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="string">&#x27;p2&#x27;</span>)</span></span><br><span class="line"><span class="javascript">		resolve()</span></span><br><span class="line"><span class="javascript">	&#125;).then(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="comment">// 异步微</span></span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(<span class="string">&#x27;then2&#x27;</span>)</span></span><br><span class="line"><span class="javascript">	&#125;)</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 同步</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="string">&#x27;end2&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 同步</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;start1&#x27;</span>)</span><br><span class="line">	<span class="comment">// 异步宏</span></span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>), <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 同步</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">		resolve()</span><br><span class="line">	&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 异步微</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;then1&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 同步</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;end1&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 同步</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;start2&#x27;</span>)</span><br><span class="line">	<span class="comment">// 异步宏</span></span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>), <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 同步</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line">		resolve()</span><br><span class="line">	&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// 异步微</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;then2&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 同步</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;end2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两个例子的结果都是</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/20210714231316627.png" alt="在这里插入图片描述"></p>
<p>两个结果是一样的，所以证实了 <code>&lt;script&gt;&lt;/script&gt;</code> 整体跟 <code>setTimeout</code> 一样是宏任务。</p>
<blockquote>
<p>PS：这里笔者没明白一点，宏任务不应该都是异步任务吗，script也是异步任务吗？欢迎探讨</p>
</blockquote>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	consoawait async2()</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">		resolve()</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果如下</span></span><br><span class="line">script start</span><br><span class="line">async2 end</span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">script start</span><br><span class="line">async2 end</span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">script end</span><br><span class="line">async2 end1</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以分2种情况来理解async：</p>
<ol>
<li><p>如果await 后面是同步函数语句，例如await 1，或者如第一段代码：</p>
<p>​        这种情况的话相当于直接把await后面的代码注册为一个微任务，可以简单理解为promise.then(await下面的代码)。然后跳出async1函数，执行其他代码，当遇到promise函数的时候，会注册promise.then()函数到微任务队列，注意此时微任务队列里面已经存在await后面的微任务。所以这种情况会先执行await后面的代码（async1 end），再执行async1函数后面注册的微任务代码(promise1,promise2)。</p>
</li>
<li><p>如果await后面跟的是一个异步函数的调用，比如上面的第二段代码：</p>
<p>​        因为async里返回一个异步函数，所以到这里的时候会将这个语句加入到微服务语句，此时相当于未执行完await，所以不会将async1的那个打印语句注册刀微服务，而是往下走，把两个promise.then加到微服务，后面按顺序执行到async2的对应的微服务后，发现await完成了，此时才把async1里的那句注册到微服务里。</p>
</li>
</ol>
<h1 id="Node-JS里的事件循环"><a href="#Node-JS里的事件循环" class="headerlink" title="Node.JS里的事件循环"></a>Node.JS里的事件循环</h1><p>新版本nodejs里的运行结果和浏览器端的一样了，可以看看官网的例子<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9sZWFybi90aGUtbm9kZWpzLWV2ZW50LWxvb3A=">http://nodejs.cn/learn/the-nodejs-event-loop</span></p>
<h2 id="事件循环机制解析"><a href="#事件循环机制解析" class="headerlink" title="事件循环机制解析"></a>事件循环机制解析</h2><p>当 Node.js 启动后，它会初始化事件循环，处理已提供的输入脚本（或丢入 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9yZXBsLmh0bWwjcmVwbF9yZXBs">REPL</span>，本文不涉及到），它可能会调用一些异步的 API、调度定时器，或者调用 <code>process.nextTick()</code>，然后开始处理事件循环。</p>
<p>下面的图表展示了事件循环操作顺序的简化概览。</p>
<p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210914160743057.png" alt="image-20210914160743057"></p>
<p><em>注意：每个框被称为事件循环机制的一个阶段。</em></p>
<p>每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段，等等。</p>
<p>由于这些操作中的任何一个都可能调度 <em>更多的</em> 操作和由内核排列在<strong>轮询</strong>阶段被处理的新事件， 且在处理轮询中的事件时，轮询事件可以排队。因此，长时间运行的回调可以允许轮询阶段运行长于计时器的阈值时间。有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#timers"><strong>计时器</strong></a> 和 <a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/#poll"><strong>轮询</strong></a> 部分。</p>
<p>从上图中，大致看出node中的事件循环的顺序：</p>
<p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p>
<ul>
<li>timers：这个阶段执行timer（setTimeout、setInterval）的回调</li>
<li>pending callbacks：处理一些上一轮循环中的少数未执行的 I/O 回调</li>
<li>idle, prepare：仅系统内部使用</li>
<li>poll：检索新的 I/O 事件;执行与 I/O 相关的回调（除了close的回调函数、由计时器scheduled 的和 <code>setImmediate()</code> 之外的所有情况），其余情况 node 将在适当的时候在此阻塞。</li>
<li>check：<code>setImmediate()</code> 回调函数在这里执行。</li>
<li>close callbacks：一些close的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code>。</li>
</ul>
<p>在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。</p>
<h2 id="阶段的详细概述"><a href="#阶段的详细概述" class="headerlink" title="阶段的详细概述"></a>阶段的详细概述</h2><h3 id="（1）timer定时器检测阶段"><a href="#（1）timer定时器检测阶段" class="headerlink" title="（1）timer定时器检测阶段"></a>（1）timer定时器检测阶段</h3><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p>
<h3 id="（2）poll轮询阶段"><a href="#（2）poll轮询阶段" class="headerlink" title="（2）poll轮询阶段"></a>（2）poll轮询阶段</h3><p><img data-src="https://gitee.com/monkey-HH/picBed/raw/master/picbed/img/image-20210914164656093.png" alt="image-20210914164656093"></p>
<p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。</p>
<p>如果没有定时器, 会去看回调函数队列。</p>
<ul>
<li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>
<li>如果 poll 队列为空时，会有两件事发生<ul>
<li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li>
<li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。</li>
</ul>
</li>
</ul>
<h3 id="（3）check检查阶段"><a href="#（3）check检查阶段" class="headerlink" title="（3）check检查阶段"></a>（3）check检查阶段</h3><p>check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="setTimeout-和-setImmediate"><a href="#setTimeout-和-setImmediate" class="headerlink" title="setTimeout 和 setImmediate"></a>setTimeout 和 setImmediate</h3><p>二者非常相似，区别主要在于调用时机不同。</p>
<ul>
<li>setImmediate 设计在poll阶段完成时执行，即check阶段；</li>
<li>setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> <span class="title">immediate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</li>
<li>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</li>
<li>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</li>
</ul>
<p>但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.readFile(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</p>
<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h3><p>process.nextTick 是一个独立于 eventLoop 的任务队列。</p>
<p>在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。</p>
<p>看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout1&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;promise resolve&#x27;</span>))</span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;next tick1&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2&#x27;</span>)</span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;next tick2&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timeout3&#x27;</span>));</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;timeout4&#x27;</span>));</span><br></pre></td></tr></table></figure>



<p>在 node11 之后，process.nextTick 是微任务的一种,因此上述代码是先进入 check 阶段，执行一个 setImmediate 宏任务，然后执行其微任务队列，再执行下一个宏任务及其微任务,因此输出为</p>
<p><code>timeout1=&gt;next tick1=&gt;promise resolve=&gt;timeout2=&gt;next tick2=&gt;timeout3=&gt;timeout4</code></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>- [1] <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj04YUdoWlFrb0ZiUQ==">菲利普·罗伯茨：到底什么是Event Loop呢？</span></p>
<p>-[2]<span class="exturl" data-url="aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZXZlbnQtbG9vcHM=">https://html.spec.whatwg.org/#event-loops</span></p>
<p>- [3] <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2Zyb250LWVuZC13ZWVrbHkvamF2YXNjcmlwdC1ldmVudC1sb29wLWV4cGxhaW5lZC00Y2QyNmFmMTIxZDQ=">JavaScript 事件循环解释 阿努普·拉文德兰</span></p>
<p>-[4]<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNhcmJvbmZpdmUuY29tL3RoZS1qYXZhc2NyaXB0LWV2ZW50LWxvb3AtZXhwbGFpbmVkLw==">https://blog.carbonfive.com/the-javascript-event-loop-explained/</span></p>
<p>-[5]<span class="exturl" data-url="aHR0cHM6Ly9nZWVrZmxhcmUuY29tL2phdmFzY3JpcHQtZXZlbnQtbG9vcHMv">https://geekflare.com/javascript-event-loops/</span></p>
<p>-[6]<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE0LzEwL2V2ZW50LWxvb3AuaHRtbA==">https://www.ruanyifeng.com/blog/2014/10/event-loop.html</span></p>
<p>-[7]<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rhb2Jhb2ppc2h1L2FydGljbGUvZGV0YWlscy8xMTM5MDM5NTU/b3BzX3JlcXVlc3RfbWlzYz0lMjU3QiUyNTIycmVxdWVzdCUyNTVGaWQlMjUyMiUyNTNBJTI1MjIxNjMxMjY1Mzc0MTY3ODAyNjQwNzEwOTUlMjUyMiUyNTJDJTI1MjJzY20lMjUyMiUyNTNBJTI1MjIyMDE0MDcxMy4xMzAxMDIzMzQucGMlMjU1RmJsb2cuJTI1MjIlMjU3RCZhbXA7cmVxdWVzdF9pZD0xNjMxMjY1Mzc0MTY3ODAyNjQwNzEwOTUmYW1wO2Jpel9pZD0wJmFtcDt1dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfc2VhcmNoX3Jlc3VsdC5ub25lLXRhc2stYmxvZy0yfmJsb2d+Zmlyc3RfcmFua192Mn5yYW5rX3YyOS0xLTExMzkwMzk1NS5wY192Ml9yYW5rX2Jsb2dfZGVmYXVsdCZhbXA7dXRtX3Rlcm09JUU0JUJBJThCJUU0JUJCJUI2JUU1JUJFJUFBJUU3JThFJUFGJmFtcDtzcG09MTAxOC4yMjI2LjMwMDEuNDQ1MA==">https://blog.csdn.net/Taobaojishu/article/details/113903955?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163126537416780264071095%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=163126537416780264071095&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-113903955.pc_v2_rank_blog_default&amp;utm_term=%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF&amp;spm=1018.2226.3001.4450</span></p>
<p>-[8]<span class="exturl" data-url="aHR0cHM6Ly9jb2RlYnVyc3QuaW8vaXMtamF2YXNjcmlwdC1zaW5nbGUtdGhyZWFkZWQteW91cmUta2lkZGluZy1tZS04MGIxMWQ3NGY0ZTU=">https://codeburst.io/is-javascript-single-threaded-youre-kidding-me-80b11d74f4e5</span> </p>
<p>-[9]<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIyOTMyMw==">https://zhuanlan.zhihu.com/p/34229323</span></p>
<p>-[10]<span class="exturl" data-url="aHR0cHM6Ly93d3cuNDA0Zm9yZXN0LmNvbS8yMDE3LzA3LzE4L2hvdy1qYXZhc2NyaXB0LWFjdHVhbGx5LXdvcmtzLWV2ZW50bG9vcC1hbmQtdWlyZW5kZXJpbmcv">https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/</span></p>
<p>-[11]<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDM2ODY2L2FydGljbGUvZGV0YWlscy8xMDY5NDEzNTA=">https://blog.csdn.net/qq_34436866/article/details/106941350</span></p>
<p>-[12]<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MDc5MzUzNzA4NTU3I2hlYWRpbmctMg==">https://juejin.cn/post/6844904079353708557#heading-2</span></p>
<p>-[13]<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNzYxOTQ5NzUzMzUyI2hlYWRpbmctMTY=">https://juejin.cn/post/6844903761949753352#heading-16</span></p>
<p>-[14]<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MDc5MzUzNzA4NTU3I2hlYWRpbmctMTE=">https://juejin.cn/post/6844904079353708557#heading-11</span></p>

      <div class="tags">
          <a href="/tags/JavaScript/" rel="tag"><i class="ic i-tag"></i> JavaScript</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-10-25 18:40:40" itemprop="dateModified" datetime="2021-10-25T18:40:40+08:00">2021-10-25</time>
  </span>
  <span id="FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript事件循环" class="item leancloud_visitors" data-flag-title="JavaScript事件循环" title="Views">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">Views</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">times</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>Monkey-HH <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" title="JavaScript事件循环">https://monkeyhh.top/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript事件循环</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202109201018875.jpg" title="JavaScript常用继承方案">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> JavaScript</span>
  <h3>JavaScript常用继承方案</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;monkey-HH&#x2F;picBed&#x2F;raw&#x2F;master&#x2F;picbed&#x2F;img&#x2F;202109201019726.png" title="JavaScript中的前端模块化">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> JavaScript</span>
  <h3>JavaScript中的前端模块化</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB"><span class="toc-number">1.</span> <span class="toc-text">导读</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EJavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">关于JavaScript的一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#V8%E5%BC%95%E6%93%8E"><span class="toc-number">3.1.</span> <span class="toc-text">V8引擎</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%A0%88Call-Stack"><span class="toc-number">4.</span> <span class="toc-text">调用栈Call Stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#task-queue-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">task queue 任务队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E8%BF%9B%E9%98%B6"><span class="toc-number">6.</span> <span class="toc-text">任务队列进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.</span> <span class="toc-text">任务是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%B0%81%E8%A3%85%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">任务封装算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%9D%A5%E6%BA%90"><span class="toc-number">6.3.</span> <span class="toc-text">任务的分类和来源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.4.</span> <span class="toc-text">任务队列的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.5.</span> <span class="toc-text">事件循环的处理模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Node-JS%E9%87%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.</span> <span class="toc-text">Node.JS里的事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">8.1.</span> <span class="toc-text">事件循环机制解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E7%9A%84%E8%AF%A6%E7%BB%86%E6%A6%82%E8%BF%B0"><span class="toc-number">8.2.</span> <span class="toc-text">阶段的详细概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89timer%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A3%80%E6%B5%8B%E9%98%B6%E6%AE%B5"><span class="toc-number">8.2.1.</span> <span class="toc-text">（1）timer定时器检测阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89poll%E8%BD%AE%E8%AF%A2%E9%98%B6%E6%AE%B5"><span class="toc-number">8.2.2.</span> <span class="toc-text">（2）poll轮询阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89check%E6%A3%80%E6%9F%A5%E9%98%B6%E6%AE%B5"><span class="toc-number">8.2.3.</span> <span class="toc-text">（3）check检查阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">8.3.</span> <span class="toc-text">注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-%E5%92%8C-setImmediate"><span class="toc-number">8.3.1.</span> <span class="toc-text">setTimeout 和 setImmediate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#process-nextTick"><span class="toc-number">8.3.2.</span> <span class="toc-text">process.nextTick</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">9.</span> <span class="toc-text">参考链接</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="bookmark" title="JavaScript数据类型">JavaScript数据类型</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="bookmark" title="JavaScript原型和原型链">JavaScript原型和原型链</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" rel="bookmark" title="JavaScript执行上下文">JavaScript执行上下文</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84this" rel="bookmark" title="JavaScript中的this">JavaScript中的this</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85" rel="bookmark" title="JavaScript作用域与闭包">JavaScript作用域与闭包</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88" rel="bookmark" title="JavaScript常用继承方案">JavaScript常用继承方案</a></li><li class="active"><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF" rel="bookmark" title="JavaScript事件循环">JavaScript事件循环</a></li><li><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" rel="bookmark" title="JavaScript中的前端模块化">JavaScript中的前端模块化</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Monkey-HH"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Monkey-HH</p>
  <div class="description" itemprop="description">Learn, share, make progress</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">17</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">6</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">8</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vbmtleS1ISA==" title="https:&#x2F;&#x2F;github.com&#x2F;monkey-HH"><i class="ic i-github"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOmhoanNjYXVAMTYzLmNvbQ==" title="mailto:hhjscau@163.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>Links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/CSS/" title="In CSS">CSS</a>
</div>

    <span><a href="/FrontEnd/CSS/FrontEnd/CSS/CSS%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93" title="CSS布局总结">CSS布局总结</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85" title="JavaScript作用域与闭包">JavaScript作用域与闭包</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%BB%8B%E7%BB%8D" title="浏览器本地存储介绍">浏览器本地存储介绍</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Computer-Networking/" title="In Computer-Networking">Computer-Networking</a>
</div>

    <span><a href="/Computer-Networking/Computer-Networking/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9" title="HTTP基础知识点">HTTP基础知识点</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87" title="JavaScript执行上下文">JavaScript执行上下文</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/Browser/" title="In Browser">Browser</a>
</div>

    <span><a href="/FrontEnd/Browser/FrontEnd/Browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" title="浏览器原理介绍">浏览器原理介绍</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E5%8E%9F%E5%BD%A2%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE" title="JavaScript原型和原型链">JavaScript原型和原型链</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/HelloWorld/" title="In HelloWorld">HelloWorld</a>
</div>

    <span><a href="/HelloWorld/hello-world" title="hello-world">hello-world</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84this" title="JavaScript中的this">JavaScript中的this</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/FrontEnd/" title="In FrontEnd">FrontEnd</a>
<i class="ic i-angle-right"></i>
<a href="/categories/FrontEnd/JavaScript/" title="In JavaScript">JavaScript</a>
</div>

    <span><a href="/FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" title="JavaScript中的前端模块化">JavaScript中的前端模块化</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Monkey-HH @ Monkey's Blog</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="Symbols count total">187k words</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="Reading time total">2:50</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'FrontEnd/JavaScript/FrontEnd/JavaScript/JavaScript事件循环',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
